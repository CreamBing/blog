<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[利用redis实现多线程安全自增ID]]></title>
    <url>%2Fblog%2F2019%2F11%2F07%2F%E5%88%A9%E7%94%A8redis%E5%AE%9E%E7%8E%B0%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E8%87%AA%E5%A2%9EID%2F</url>
    <content type="text"><![CDATA[正文 添加依赖 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.2.1.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;&lt;/parent&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt; &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.56&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;RELEASE&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt; &lt;/dependency&gt;&lt;/dependencies&gt;&lt;repositories&gt; &lt;repository&gt; &lt;id&gt;maven-public&lt;/id&gt; &lt;url&gt;http://172.20.1.100:8081/repository/maven-public/&lt;/url&gt; &lt;releases&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;updatePolicy&gt;always&lt;/updatePolicy&gt; &lt;/releases&gt; &lt;snapshots&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;updatePolicy&gt;always&lt;/updatePolicy&gt; &lt;/snapshots&gt; &lt;/repository&gt; &lt;repository&gt; &lt;id&gt;3rdParty&lt;/id&gt; &lt;name&gt;company private&lt;/name&gt; &lt;url&gt;http://172.20.1.100:8081/repository/3rdParty/&lt;/url&gt; &lt;/repository&gt; &lt;repository&gt; &lt;id&gt;maven-snapshots&lt;/id&gt; &lt;name&gt;company snapshots&lt;/name&gt; &lt;url&gt;http://172.20.1.100:8081/repository/maven-snapshots/&lt;/url&gt; &lt;/repository&gt;&lt;/repositories&gt;&lt;pluginRepositories&gt; &lt;pluginRepository&gt; &lt;id&gt;maven-public&lt;/id&gt; &lt;url&gt;http://172.20.1.100:8081/repository/maven-public/&lt;/url&gt; &lt;releases&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;updatePolicy&gt;always&lt;/updatePolicy&gt; &lt;/releases&gt; &lt;snapshots&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;updatePolicy&gt;always&lt;/updatePolicy&gt; &lt;/snapshots&gt; &lt;/pluginRepository&gt;&lt;/pluginRepositories&gt;&lt;distributionManagement&gt; &lt;repository&gt; &lt;id&gt;maven-releases&lt;/id&gt; &lt;url&gt; http://172.20.1.100:8081/repository/maven-releases/ &lt;/url&gt; &lt;/repository&gt; &lt;snapshotRepository&gt; &lt;id&gt;maven-snapshots&lt;/id&gt; &lt;url&gt; http://172.20.1.100:8081/repository/maven-snapshots/ &lt;/url&gt; &lt;/snapshotRepository&gt;&lt;/distributionManagement&gt; 添加配置类 FastJson2JsonRedisSerializer.java 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465package com.creambing.redis.conf;import com.alibaba.fastjson.JSON;import com.alibaba.fastjson.parser.ParserConfig;import com.alibaba.fastjson.serializer.SerializerFeature;import com.fasterxml.jackson.databind.JavaType;import com.fasterxml.jackson.databind.ObjectMapper;import com.fasterxml.jackson.databind.type.TypeFactory;import org.springframework.data.redis.serializer.RedisSerializer;import org.springframework.data.redis.serializer.SerializationException;import org.springframework.util.Assert;import java.nio.charset.Charset;/** * FileName: FastJson2JsonRedisSerializer * Author: creambing * Date: 2019-05-10 16:40 * Description: fastjson序列化代替redis自己的序列化 * History: * &lt;author&gt; &lt;time&gt; &lt;version&gt; &lt;desc&gt; * 作者姓名 修改时间 版本号 描述 */public class FastJson2JsonRedisSerializer&lt;T&gt; implements RedisSerializer&lt;T&gt; &#123; private ObjectMapper objectMapper = new ObjectMapper(); public static final Charset DEFAULT_CHARSET = Charset.forName("UTF-8"); private Class&lt;T&gt; clazz; static &#123; ParserConfig.getGlobalInstance().setAutoTypeSupport(true); //如果遇到反序列化autoType is not support错误，请添加并修改一下包名到bean文件路径 // ParserConfig.getGlobalInstance().addAccept("com.xxxxx.xxx"); &#125; public FastJson2JsonRedisSerializer(Class&lt;T&gt; clazz) &#123; super(); this.clazz = clazz; &#125; public byte[] serialize(T t) throws SerializationException &#123; if (t == null) &#123; return new byte[0]; &#125; return JSON.toJSONString(t, SerializerFeature.WriteClassName).getBytes(DEFAULT_CHARSET); &#125; public T deserialize(byte[] bytes) throws SerializationException &#123; if (bytes == null || bytes.length &lt;= 0) &#123; return null; &#125; String str = new String(bytes, DEFAULT_CHARSET); return JSON.parseObject(str, clazz); &#125; public void setObjectMapper(ObjectMapper objectMapper) &#123; Assert.notNull(objectMapper, "'objectMapper' must not be null"); this.objectMapper = objectMapper; &#125; protected JavaType getJavaType(Class&lt;?&gt; clazz) &#123; return TypeFactory.defaultInstance().constructType(clazz); &#125;&#125; RedisConfig.java 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697package com.creambing.redis.conf;import com.fasterxml.jackson.annotation.JsonAutoDetect;import com.fasterxml.jackson.annotation.PropertyAccessor;import com.fasterxml.jackson.databind.ObjectMapper;import io.lettuce.core.RedisURI;import io.lettuce.core.cluster.ClusterClientOptions;import io.lettuce.core.cluster.RedisClusterClient;import io.lettuce.core.cluster.api.StatefulRedisClusterConnection;import io.lettuce.core.resource.ClientResources;import org.springframework.beans.factory.annotation.Value;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.data.redis.connection.RedisConnectionFactory;import org.springframework.data.redis.core.RedisTemplate;import org.springframework.data.redis.serializer.StringRedisSerializer;import org.springframework.util.StringUtils;/** * FileName: RedisConfig * Author: creambing * Date: 2019-05-10 16:38 * Description: redis设置 * History: * &lt;author&gt; &lt;time&gt; &lt;version&gt; &lt;desc&gt; * 作者姓名 修改时间 版本号 描述 */@Configurationpublic class RedisConfig &#123; @Value("$&#123;spring.redis.cluster.nodes&#125;") private String clusterNodes; @Value("$&#123;spring.redis.password&#125;") private String password; @Bean public RedisTemplate&lt;Object, Object&gt; redisFastJsonTemplate(RedisConnectionFactory connectionFactory) &#123; RedisTemplate&lt;Object, Object&gt; template = new RedisTemplate&lt;&gt;(); template.setConnectionFactory(connectionFactory); //使用Jackson2JsonRedisSerializer来序列化和反序列化redis的value值 //Jackson2JsonRedisSerializer serializer = new Jackson2JsonRedisSerializer(Object.class); //使用Fastjson2JsonRedisSerializer来序列化和反序列化redis的value值 by zhengkai FastJson2JsonRedisSerializer serializer = new FastJson2JsonRedisSerializer(Object.class); ObjectMapper mapper = new ObjectMapper(); mapper.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY); mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL); serializer.setObjectMapper(mapper); template.setValueSerializer(serializer); template.setHashValueSerializer(serializer); //使用StringRedisSerializer来序列化和反序列化redis的key值 template.setKeySerializer(new StringRedisSerializer()); template.setHashKeySerializer(new StringRedisSerializer()); template.afterPropertiesSet(); return template; &#125; @Bean(name="clusterRedisURI") RedisURI clusterRedisURI()&#123; String[] nodes = clusterNodes.split(","); if(nodes.length&lt;1)&#123; throw new RuntimeException("redis 集群配置有问题,请检查!"); &#125; String[] oneNode = nodes[0].split(":"); if(oneNode.length&lt;2)&#123; throw new RuntimeException("redis 集群配置第一个有问题,请检查!"); &#125; String ip = oneNode[0]; String port = oneNode[1]; RedisURI.Builder builder = RedisURI.builder().withHost(ip).withPort(Integer.valueOf(port)); if (StringUtils.isEmpty(password))&#123; return builder.build(); &#125; return builder.withPassword(password).build(); &#125; @Bean ClusterClientOptions clusterClientOptions()&#123; return ClusterClientOptions.builder().autoReconnect(true).maxRedirects(1).build(); &#125; @Bean RedisClusterClient redisClusterClient(ClientResources clientResources, ClusterClientOptions clusterClientOptions, RedisURI clusterRedisURI)&#123; RedisClusterClient redisClusterClient= RedisClusterClient.create(clientResources,clusterRedisURI); redisClusterClient.setOptions(clusterClientOptions); return redisClusterClient; &#125; /** * 集群连接 */ @Bean(destroyMethod = "close") StatefulRedisClusterConnection&lt;String,String&gt; statefulRedisClusterConnection(RedisClusterClient redisClusterClient)&#123; return redisClusterClient.connect(); &#125;&#125; RedisIncrIdUtils.java 给一个唯一值 userId 根据它在redis中建立一个唯一的数字 id 123456789101112131415161718192021222324252627282930313233343536373839404142434445package com.creambing.redis.conf;import lombok.extern.slf4j.Slf4j;import org.springframework.stereotype.Component;import javax.annotation.Resource;/** * FileName: RedisIncrIdUtils * Author: creambing * Date: 2019-11-07 16:22 * Description: * History: * &lt;author&gt; &lt;time&gt; &lt;version&gt; &lt;desc&gt; * 作者姓名 修改时间 版本号 描述 */@Component@Slf4jpublic class RedisIncrIdUtils &#123; private static final String REDIS_KEY_USERID2NUMID = "userid2numid"; private static final long MAX_NUMID = Math.round(Math.pow(2,32)-1); private static final String REDIS_KEY_NUMID = "numid"; @Resource private RedisUtils redisUtils; public synchronized Long getNumId(String userId)&#123; Object numId = redisUtils.hget(REDIS_KEY_USERID2NUMID,userId); if(numId!=null)&#123; return Long.parseLong(String.valueOf(numId)); &#125;else &#123; log.warn("userId [&#123;&#125;] has no numid,i will create",userId); long newNumId = redisUtils.incr(REDIS_KEY_NUMID,1); redisUtils.hset(REDIS_KEY_USERID2NUMID,userId,newNumId); if(newNumId&gt;MAX_NUMID)&#123; log.error("numid [&#123;&#125;] exceeds the maximum value [&#123;&#125;]",newNumId,MAX_NUMID); &#125; log.info("userId [&#123;&#125;] had a numid [&#123;&#125;]",userId,newNumId); return newNumId; &#125; &#125;&#125; RedisUtils.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579package com.creambing.redis.conf;/** * FileName: RedisUtils * Author: creambing * Date: 2019-05-27 18:29 * Description: redis工具类 * History: * &lt;author&gt; &lt;time&gt; &lt;version&gt; &lt;desc&gt; * 作者姓名 修改时间 版本号 描述 */import org.springframework.beans.factory.annotation.Autowired;import org.springframework.beans.factory.annotation.Qualifier;import org.springframework.data.redis.core.RedisTemplate;import org.springframework.stereotype.Component;import org.springframework.util.CollectionUtils;import java.util.List;import java.util.Map;import java.util.Set;import java.util.concurrent.TimeUnit;@Componentpublic class RedisUtils &#123; @Qualifier("redisFastJsonTemplate") @Autowired RedisTemplate&lt;Object, Object&gt; redisTemplate; /** * 指定缓存失效时间 * * @param key 键 * @param time 时间(秒) * @return */ public boolean expire(String key, long time) &#123; try &#123; if (time &gt; 0) &#123; redisTemplate.expire(key, time, TimeUnit.SECONDS); &#125; return true; &#125; catch (Exception e) &#123; e.printStackTrace(); return false; &#125; &#125; /** * 根据key 获取过期时间 * * @param key 键 不能为null * @return 时间(秒) 返回0代表为永久有效 */ public long getExpire(String key) &#123; return redisTemplate.getExpire(key, TimeUnit.SECONDS); &#125; /** * 判断key是否存在 * * @param key 键 * @return true 存在 false不存在 */ public boolean hasKey(String key) &#123; try &#123; return redisTemplate.hasKey(key); &#125; catch (Exception e) &#123; e.printStackTrace(); return false; &#125; &#125; /** * 删除缓存 * * @param key 可以传一个值 或多个 */ @SuppressWarnings("unchecked") public void del(String... key) &#123; if (key != null &amp;&amp; key.length &gt; 0) &#123; if (key.length == 1) &#123; redisTemplate.delete(key[0]); &#125; else &#123; redisTemplate.delete(CollectionUtils.arrayToList(key)); &#125; &#125; &#125; //============================String============================= /** * 普通缓存获取 * * @param key 键 * @return 值 */ public Object get(String key) &#123; return key == null ? null : redisTemplate.opsForValue().get(key); &#125; /** * 普通缓存放入 * * @param key 键 * @param value 值 * @return true成功 false失败 */ public boolean set(String key, Object value) &#123; try &#123; redisTemplate.opsForValue().set(key, value); return true; &#125; catch (Exception e) &#123; e.printStackTrace(); return false; &#125; &#125; /** * 普通缓存放入并设置时间 * * @param key 键 * @param value 值 * @param time 时间(秒) time要大于0 如果time小于等于0 将设置无限期 * @return true成功 false 失败 */ public boolean set(String key, Object value, long time) &#123; try &#123; if (time &gt; 0) &#123; redisTemplate.opsForValue().set(key, value, time, TimeUnit.SECONDS); &#125; else &#123; set(key, value); &#125; return true; &#125; catch (Exception e) &#123; e.printStackTrace(); return false; &#125; &#125; /** * 递增 * * @return */ public long incr(String key, long delta) &#123; if (delta &lt; 0) &#123; throw new RuntimeException("递增因子必须大于0"); &#125; return redisTemplate.opsForValue().increment(key, delta); &#125; /** * 递减 * * @return */ public long decr(String key, long delta) &#123; if (delta &lt; 0) &#123; throw new RuntimeException("递减因子必须大于0"); &#125; return redisTemplate.opsForValue().increment(key, -delta); &#125; //================================Map================================= /** * HashGet * * @param key 键 不能为null * @param item 项 不能为null * @return 值 */ public Object hget(String key, String item) &#123; return redisTemplate.opsForHash().get(key, item); &#125; /** * 获取hashKey对应的所有键值 * * @return 对应的多个键值 */ public Map&lt;Object, Object&gt; hmget(String key) &#123; return redisTemplate.opsForHash().entries(key); &#125; /** * HashSet * * @param key 键 * @param map 对应多个键值 * @return true 成功 false 失败 */ public boolean hmset(String key, Map&lt;String, Object&gt; map) &#123; try &#123; redisTemplate.opsForHash().putAll(key, map); return true; &#125; catch (Exception e) &#123; e.printStackTrace(); return false; &#125; &#125; /** * HashSet 并设置时间 * * @param key 键 * @param map 对应多个键值 * @param time 时间(秒) * @return true成功 false失败 */ public boolean hmset(String key, Map&lt;String, Object&gt; map, long time) &#123; try &#123; redisTemplate.opsForHash().putAll(key, map); if (time &gt; 0) &#123; expire(key, time); &#125; return true; &#125; catch (Exception e) &#123; e.printStackTrace(); return false; &#125; &#125; /** * 向一张hash表中放入数据,如果不存在将创建 * * @param key 键 * @param item 项 * @param value 值 * @return true 成功 false失败 */ public boolean hset(String key, String item, Object value) &#123; try &#123; redisTemplate.opsForHash().put(key, item, value); return true; &#125; catch (Exception e) &#123; e.printStackTrace(); return false; &#125; &#125; /** * 向一张hash表中放入数据,如果不存在将创建 * * @param key 键 * @param item 项 * @param value 值 * @param time 时间(秒)注意:如果已存在的hash表有时间,这里将会替换原有的时间 * @return true 成功 false失败 */ public boolean hset(String key, String item, Object value, long time) &#123; try &#123; redisTemplate.opsForHash().put(key, item, value); if (time &gt; 0) &#123; expire(key, time); &#125; return true; &#125; catch (Exception e) &#123; e.printStackTrace(); return false; &#125; &#125; /** * 删除hash表中的值 * * @param key 键 不能为null * @param item 项 可以使多个 不能为null */ public void hdel(String key, Object... item) &#123; try &#123; redisTemplate.opsForHash().delete(key, item); &#125;catch (Exception e)&#123; e.printStackTrace(); &#125; &#125; /** * 判断hash表中是否有该项的值 * * @param key 键 不能为null * @param item 项 不能为null * @return true 存在 false不存在 */ public boolean hHasKey(String key, String item) &#123; return redisTemplate.opsForHash().hasKey(key, item); &#125; /** * hash递增 如果不存在,就会创建一个 并把新增后的值返回 * * @param key 键 * @param item 项 * @param by 要增加几(大于0) * @return */ public double hincr(String key, String item, double by) &#123; return redisTemplate.opsForHash().increment(key, item, by); &#125; /** * hash递减 * * @param key 键 * @param item 项 * @param by 要减少记(小于0) * @return */ public double hdecr(String key, String item, double by) &#123; return redisTemplate.opsForHash().increment(key, item, -by); &#125; //============================set============================= /** * 根据key获取Set中的所有值 * * @param key 键 * @return */ public Set&lt;Object&gt; sGet(String key) &#123; try &#123; return redisTemplate.opsForSet().members(key); &#125; catch (Exception e) &#123; e.printStackTrace(); return null; &#125; &#125; /** * 根据value从一个set中查询,是否存在 * * @param key 键 * @param value 值 * @return true 存在 false不存在 */ public boolean sHasKey(String key, Object value) &#123; try &#123; return redisTemplate.opsForSet().isMember(key, value); &#125; catch (Exception e) &#123; e.printStackTrace(); return false; &#125; &#125; /** * 将数据放入set缓存 * * @param key 键 * @param values 值 可以是多个 * @return 成功个数 */ public long sSet(String key, Object... values) &#123; try &#123; return redisTemplate.opsForSet().add(key, values); &#125; catch (Exception e) &#123; e.printStackTrace(); return 0; &#125; &#125; /** * 将set数据放入缓存 * * @param key 键 * @param time 时间(秒) * @param values 值 可以是多个 * @return 成功个数 */ public long sSetAndTime(String key, long time, Object... values) &#123; try &#123; Long count = redisTemplate.opsForSet().add(key, values); if (time &gt; 0) expire(key, time); return count; &#125; catch (Exception e) &#123; e.printStackTrace(); return 0; &#125; &#125; /** * 获取set缓存的长度 * * @param key 键 * @return */ public long sGetSetSize(String key) &#123; try &#123; return redisTemplate.opsForSet().size(key); &#125; catch (Exception e) &#123; e.printStackTrace(); return 0; &#125; &#125; /** * 移除值为value的 * * @param key 键 * @param values 值 可以是多个 * @return 移除的个数 */ public long setRemove(String key, Object... values) &#123; try &#123; Long count = redisTemplate.opsForSet().remove(key, values); return count; &#125; catch (Exception e) &#123; e.printStackTrace(); return 0; &#125; &#125; //===============================list================================= /** * 获取list缓存的内容 * * @param key 键 * @param start 开始 * @param end 结束0 到 -1代表所有值 * @return */ public List&lt;Object&gt; lGet(String key, long start, long end) &#123; try &#123; return redisTemplate.opsForList().range(key, start, end); &#125; catch (Exception e) &#123; e.printStackTrace(); return null; &#125; &#125; /** * 获取list缓存的长度 * * @param key 键 * @return */ public long lGetListSize(String key) &#123; try &#123; return redisTemplate.opsForList().size(key); &#125; catch (Exception e) &#123; e.printStackTrace(); return 0; &#125; &#125; /** * 通过索引 获取list中的值 * * @param key 键 * @param index 索引index&gt;=0时， 0 表头，1 第二个元素，依次类推；index&lt;0时，-1，表尾，-2倒数第二个元素，依次类推 * @return */ public Object lGetIndex(String key, long index) &#123; try &#123; return redisTemplate.opsForList().index(key, index); &#125; catch (Exception e) &#123; e.printStackTrace(); return null; &#125; &#125; /** * 将list放入缓存 * * @param key 键 * @param value 值 * @return */ public boolean lSet(String key, Object value) &#123; try &#123; redisTemplate.opsForList().rightPush(key, value); return true; &#125; catch (Exception e) &#123; e.printStackTrace(); return false; &#125; &#125; /** * 将list放入缓存 * * @param key 键 * @param value 值 * @param time 时间(秒) * @return */ public boolean lSet(String key, Object value, long time) &#123; try &#123; redisTemplate.opsForList().rightPush(key, value); if (time &gt; 0) expire(key, time); return true; &#125; catch (Exception e) &#123; e.printStackTrace(); return false; &#125; &#125; /** * 将list放入缓存 * * @param key 键 * @param value 值 * @return */ public boolean lSet(String key, List&lt;Object&gt; value) &#123; try &#123; redisTemplate.opsForList().rightPushAll(key, value); return true; &#125; catch (Exception e) &#123; e.printStackTrace(); return false; &#125; &#125; /** * 将list放入缓存 * * @param key 键 * @param value 值 * @param time 时间(秒) * @return */ public boolean lSet(String key, List&lt;Object&gt; value, long time) &#123; try &#123; redisTemplate.opsForList().rightPushAll(key, value); if (time &gt; 0) expire(key, time); return true; &#125; catch (Exception e) &#123; e.printStackTrace(); return false; &#125; &#125; /** * 根据索引修改list中的某条数据 * * @param key 键 * @param index 索引 * @param value 值 * @return */ public boolean lUpdateIndex(String key, long index, Object value) &#123; try &#123; redisTemplate.opsForList().set(key, index, value); return true; &#125; catch (Exception e) &#123; e.printStackTrace(); return false; &#125; &#125; /** * 移除N个值为value * * @param key 键 * @param count 移除多少个 * @param value 值 * @return 移除的个数 */ public long lRemove(String key, long count, Object value) &#123; try &#123; Long remove = redisTemplate.opsForList().remove(key, count, value); return remove; &#125; catch (Exception e) &#123; e.printStackTrace(); return 0; &#125; &#125; public RedisTemplate&lt;Object, Object&gt; getRedisTemplate()&#123; return redisTemplate; &#125;&#125; 配置文件添加 12spring.redis.cluster.nodes=172.20.1.202:7000,172.20.1.202:7001,172.20.1.202:7002,172.20.1.202:7003,172.20.1.202:7004,172.20.1.202:7005spring.redis.password= 测试多线程 RedisThread.java 中利用 incr() 获取自增id 1234567891011121314151617181920212223242526272829303132package com.creambing.redis.conf;/** * FileName: RedisThread * Author: creambing * Date: 2019-11-07 15:17 * Description: * History: * &lt;author&gt; &lt;time&gt; &lt;version&gt; &lt;desc&gt; * 作者姓名 修改时间 版本号 描述 */public class RedisThread implements Runnable &#123; private final RedisUtils redisUtils; public RedisThread(RedisUtils redisUtils) &#123; this.redisUtils = redisUtils; &#125; @Override public void run() &#123; for(int i=0;i&lt;10;i++)&#123; try &#123; System.out.println(redisUtils.incr("id",1)); Thread.sleep(10); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; Thread.yield(); &#125; &#125;&#125; RedisUtilsTest.java 12345678910111213141516171819202122232425262728293031323334353637383940414243444546package com.creambing.redis.conf;import com.creambing.redis.RedisApplicationTests;import org.junit.jupiter.api.Test;import javax.annotation.Resource;import java.util.ArrayList;import java.util.List;import java.util.concurrent.Executor;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;import java.util.stream.Collectors;import java.util.stream.IntStream;import static org.junit.jupiter.api.Assertions.*;/** * Created by [zhaobing] [creambing.github.io] * Date: 2019/11/7 * Time: 15:16 */class RedisUtilsTest extends RedisApplicationTests &#123; @Resource RedisUtils redisUtils; @Test void incr() &#123; List&lt;Thread&gt; threads = IntStream.range(0, 10).mapToObj(i -&gt; new Thread(new RedisThread(redisUtils))).collect(Collectors.toList()); threads.forEach(Thread::start); for (Thread t : threads) &#123; try &#123; t.join(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; System.out.println("redisId:" + redisUtils.get("id")); &#125; @Test void decr() &#123; &#125;&#125; 参考资料]]></content>
      <categories>
        <category>springboot2</category>
        <category>redis</category>
      </categories>
      <tags>
        <tag>springboot2</tag>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图解java多线程-Guarded_Suspension_模式]]></title>
    <url>%2Fblog%2F2019%2F11%2F06%2F%E5%9B%BE%E8%A7%A3java%E5%A4%9A%E7%BA%BF%E7%A8%8B-Guarded-Suspension-%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[正文 Guarded 是被守护,被保卫,被保护的意思, Suspension 则是暂停的意思.如果执行现在的处理会出现问题,就让处理问题的线程进行等待–这就是 Guarded Suspension 模式 利用 LinkedList 实现 LinkedBlockingQueue? 下面整个 MyBlockQueue api 就是利用了整个模式,当队列为空时,就让 调用 take 的线程一直等待,直到调用 put 后再唤醒 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172package com.creambing.concurrent.chapterthree;import java.util.LinkedList;import java.util.List;import java.util.Queue;import java.util.stream.Collectors;import java.util.stream.IntStream;/** * FileName: MyBlockQueue * Author: creambing * Date: 2019-10-31 11:27 * Description: * History: * &lt;author&gt; &lt;time&gt; &lt;version&gt; &lt;desc&gt; * 作者姓名 修改时间 版本号 描述 */public class MyBlockQueue&lt;T&gt; &#123; private Queue&lt;T&gt; queue = new LinkedList&lt;&gt;(); public synchronized void put(T t) &#123; queue.add(t); notifyAll(); &#125; public synchronized T take() throws InterruptedException &#123; while (queue.peek() == null) &#123; wait(); &#125; return queue.poll(); &#125; public synchronized int size() &#123; return queue.size(); &#125; static class TestQueue implements Runnable &#123; private final MyBlockQueue&lt;Integer&gt; queue; public TestQueue(MyBlockQueue&lt;Integer&gt; queue) &#123; this.queue = queue; &#125; @Override public void run() &#123; IntStream.range(0, 10).forEach(i -&gt; &#123; queue.put(i); try &#123; System.out.println(queue.take()); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;); &#125; &#125; public static void main(String[] args) &#123; MyBlockQueue&lt;Integer&gt; myBlockQueue = new MyBlockQueue&lt;&gt;(); List&lt;Thread&gt; list = IntStream.range(0, 10).mapToObj(i -&gt; new Thread(new TestQueue(myBlockQueue))).collect(Collectors.toList()); list.forEach(Thread::start); for (Thread thread : list) &#123; try &#123; thread.join(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; System.out.println("size:"+myBlockQueue.size()); &#125;&#125; wait和锁的关系 调用 wait 的时候必须先获取锁 我们先说明一下等待队列,当调用 wait() 方法时,该线程就会放入等待队列中,并同时释放在进入 wait() 方法之前获取的锁 所有实例都拥有一个等待队列,它是在实例的 wait 方法执行后停止操作的线程的队列,打个比方来说,就是为每个实例准备的线程休息室 在执行 wait 方法后,线程便会暂停操作,进入等待队列这个休息室.除非发生下列某一情况,否则线程便会一直在等待队列中休眠.当下列任意一种情况发生时,线程便会退出等待队列 1234有其他线程的 notify 方法来唤醒线程有其他线程的 notifyAll 方法来唤醒线程有其他线程的 interrupt 方法来唤醒线程wait 方法超时 如果 wait 和 notifyAll 需要放在 synchronized 代码块中需要如何改造? 123456789101112131415161718// 线程 A 的代码synchronized(obj_A)&#123; while(!condition)&#123; obj_A.wait(); &#125; // do something &#125;// 线程 B 的代码synchronized(obj_A)&#123; if(!condition)&#123; // do something ... condition = true; obj_A.notify(); &#125;&#125; 因为调用 wait() 会挂起该线程同时释放锁,因为 synchronized 代码块中 obj_A 可以时任意对象,所以需要调用该对象的 wait 和 notifyAll 方法 当调用 notifyAll 方法时,此时锁还在 notifyAll 线程上,它并不像 wait 调用后会直接释放锁,它只是通知那些等待队列中的线程,可以退出等待,出来竞争锁了,此时如果 notifyAll 的线程执行完锁中的代码,释放锁之后,那些线程谁获取到锁就继续执行下去 同 wait 方法一样,若要执行 notify 或者 notifyAll 方法,线程必须持有要调用实例的锁 参考资料]]></content>
      <categories>
        <category>书籍</category>
        <category>java</category>
        <category>多线程</category>
        <category>图解java多线程设计模式</category>
      </categories>
      <tags>
        <tag>书籍</tag>
        <tag>java</tag>
        <tag>多线程</tag>
        <tag>图解java多线程设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java手撸线程池]]></title>
    <url>%2Fblog%2F2019%2F11%2F04%2Fjava%E6%89%8B%E6%92%B8%E7%BA%BF%E7%A8%8B%E6%B1%A0%2F</url>
    <content type="text"><![CDATA[正文 如何新建线程池 根据《阿里巴巴java开发手册》中关于线程的规约,建议我们手动 ThreadPoolExecutor 来创建线程池 上图已经说明了为什么这么规范?我在这里再说明以下,比如我们创建一个固定任务的线程池 1ExecutorService THREAD_POOL = Executors.newFixedThreadPool(10); 但是由于源码中 newFixedThreadPool 使用的 LinkedBlockingQueue 并没有固定大小,这个队列就是保存的就是我们提交的任务 123456789public static ExecutorService newFixedThreadPool(int nThreads) &#123; return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;());&#125; public LinkedBlockingQueue() &#123; this(Integer.MAX_VALUE);&#125; 这样设置会有如下影响 1234当线程池中的线程数达到 corePoolSize 后，新任务将在无界队列中等待，因此线程池中的线程数不会超过 corePoolSize。由于1，使用无界队列时 maximumPoolSize 将是一个无效参数。 由于1和2，使用无界队列时 keepAliveTime 将是一个无效参数。由于使用无界队列，运行中的 FixedThreadPool（未执行方法 shutdown() 或 shutdownNow() ）不会拒绝任务（不会调用 RejectedExecutionHandler.rejectedExecution 方法）。 在我们自定义的时候我们先来看看 jdk 给我们提供的工具类是如何新建的 1、newCachedThreadPool：创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。（线程最大并发数不可控制） 2、newFixedThreadPool：创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。 3、newScheduledThreadPool：创建一个定长线程池，支持定时及周期性任务执行。 4、newSingleThreadExecutor：创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。 newCachedThreadPool 12345public static ExecutorService newCachedThreadPool() &#123; return new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;()); &#125; newFixedThreadPool 12345public static ExecutorService newFixedThreadPool(int nThreads) &#123; return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;()); &#125; newScheduledThreadPool 1234567891011121314151617public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) &#123; return new ScheduledThreadPoolExecutor(corePoolSize); &#125;public ScheduledThreadPoolExecutor(int corePoolSize) &#123; super(corePoolSize, Integer.MAX_VALUE, 0, NANOSECONDS, new DelayedWorkQueue()); &#125;public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue) &#123; this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, Executors.defaultThreadFactory(), defaultHandler); &#125; newSingleThreadExecutor 123456public static ExecutorService newSingleThreadExecutor() &#123; return new FinalizableDelegatedExecutorService (new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;())); &#125; 所以根据上面的各个线程池的模板,我们可以根据业务的特性构建我们自己的线程池 下面这个线程池 newFixedThreadPool 适用于提交已经固定的线程数量,这些线程内部是死循环消费队列来处理事件 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061package com.creambing.utils.encrypt;import java.util.concurrent.*;import java.util.concurrent.atomic.AtomicInteger;/** * FileName: ExecutorServiceUtils * Author: creambing * Date: 2019-11-04 19:18 * Description: * History: * &lt;author&gt; &lt;time&gt; &lt;version&gt; &lt;desc&gt; * 作者姓名 修改时间 版本号 描述 */public class ExecutorServiceUtils &#123; public static ExecutorService newFixedThreadPool(int nThreads, String threadName) &#123; return newThreadPool(nThreads, nThreads, 0l , TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;(nThreads), new NamedThreadFactory(threadName), new ThreadPoolExecutor.AbortPolicy()); &#125; public static ExecutorService newThreadPool(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) &#123; return new ThreadPoolExecutor(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, threadFactory, handler); &#125; static class NamedThreadFactory implements ThreadFactory &#123; private static final AtomicInteger poolNumber = new AtomicInteger(1); private final ThreadGroup group; private final AtomicInteger threadNumber = new AtomicInteger(1); private final String namePrefix; private NamedThreadFactory(String namePrefix) &#123; this.namePrefix = namePrefix + "-" + poolNumber.getAndIncrement(); SecurityManager s = System.getSecurityManager(); group = (s != null) ? s.getThreadGroup() : Thread.currentThread().getThreadGroup(); &#125; public Thread newThread(Runnable r) &#123; Thread t = new Thread(group, r, namePrefix + threadNumber.getAndIncrement(), 0); if (t.isDaemon()) t.setDaemon(false); if (t.getPriority() != Thread.NORM_PRIORITY) t.setPriority(Thread.NORM_PRIORITY); return t; &#125; &#125;&#125; 参数讲解 1.当线程池小于corePoolSize时，新提交任务将创建一个新线程执行任务，即使此时线程池中存在空闲线程。 2.当线程池达到corePoolSize时，新提交任务将被放入workQueue中，等待线程池中任务调度执行 3.当workQueue已满，且maximumPoolSize&gt;corePoolSize时，新提交任务会创建新线程执行任务 4.当提交任务数超过maximumPoolSize时，新提交任务由RejectedExecutionHandler处理 5.当线程池中超过corePoolSize线程，空闲时间达到keepAliveTime时，关闭空闲线程 6.当设置allowCoreThreadTimeOut(true)时，线程池中corePoolSize线程空闲时间达到keepAliveTime也将关闭 ThreadPoolExecutor 的拒绝机制可以通过 setRejectedExecutionHandler() 方法动态修改 AbortPolicy:放弃任务执行，并抛出RejectedException异常，通过捕获该异常，可以执行相应的处理方法 CallerRunPolicy:调用者运行，该机制会将任务会退给调用者，从而降低新任务的流量。他会在调用了execute的线程中执行任务，从而阻止主线程向线程池提交新的任务，该机制通常适用Socket服务处理，但对Servlet服务并不适用，因为Servlet本身即为多线程机制，主线程的阻塞无法达到减缓请求速度的效果 DiscardPolicy:抛弃任务 DiscardOldPolicy:抛弃最旧的任务，即抛弃下一个将被执行的任务 还可以实现RejecetExecutionHandler接口，自定义任务的拒绝方法 修改线程池线程名字 当我们想给线程池中的线程命名时,除了实现 ThreadFactory 接口并传入,另外就是在线程类的 run 方法中修改 Thread 的名字，这个方法不够灵活,不建议使用 1Thread.currentThread().setName("xxx"+"-"+Thread.currentThread().getId()); 参考资料]]></content>
      <categories>
        <category>java</category>
        <category>基础</category>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>多线程</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java自定义注解]]></title>
    <url>%2Fblog%2F2019%2F11%2F01%2Fjava%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[正文 java 自定义注解 Java注解又称Java标注，是Java语言5.0版本开始支持加入源代码的特殊语法元数据。为我们在代码中添加信息提供了一种形式化的方法，使我们可以在稍后某个时刻非常方便的使用这些数据。 Java语言中的类、方法、变量、参数和包等都可以被标注。和Javadoc不同，Java标注可以通过反射获取注解内容。在编译器生成类文件时，注解可以被嵌入到字节码中。Java虚拟机可以保留注解内容，在运行时可以获取到注解内容 内置注解 Java 定义了一套注解，共有 7 个，3 个在 java.lang 中，剩下 4 个在 java.lang.annotation 中。 1、作用在代码的注解是 123@Override - 检查该方法是否是重写方法。如果发现其父类，或者是引用的接口中并没有该方法时，会报编译错误。@Deprecated - 标记过时方法。如果使用该方法，会报编译警告。@SuppressWarnings - 指示编译器去忽略注解中声明的警告。 2、作用在其他注解的注解(或者说元注解)是: 1234@Retention - 标识这个注解怎么保存，是只在代码中，还是编入class文件中，或者是在运行时可以通过反射访问。@Documented - 标记这些注解是否包含在用户文档中。@Target - 标记这个注解应该是哪种 Java 成员。@Inherited - 标记这个注解是继承于哪个注解类(默认 注解并没有继承于任何子类) 3、从 Java 7 开始，额外添加了 3 个注解: 123@SafeVarargs - Java 7 开始支持，忽略任何使用参数为泛型变量的方法或构造函数调用产生的警告。@FunctionalInterface - Java 8 开始支持，标识一个匿名函数或函数式接口。@Repeatable - Java 8 开始支持，标识某注解可以在同一个声明上使用多次。 元注解 1、@Retention @Retention annotation指定标记注释的存储方式： 123RetentionPolicy.SOURCE - 标记的注释仅保留在源级别中，并由编译器忽略。RetentionPolicy.CLASS - 标记的注释在编译时由编译器保留，但Java虚拟机（JVM）会忽略。RetentionPolicy.RUNTIME - 标记的注释由JVM保留，因此运行时环境可以使用它。 2、@Documented @Documented 注释表明，无论何时使用指定的注释，都应使用Javadoc工具记录这些元素。（默认情况下，注释不包含在Javadoc中。）有关更多信息，请参阅 Javadoc工具页面。 3、@Target @Target 注释标记另一个注释，以限制可以应用注释的Java元素类型。目标注释指定以下元素类型之一作为其值 12345678910ElementType.TYPE 可以应用于类的任何元素。ElementType.FIELD 可以应用于字段或属性。ElementType.METHOD 可以应用于方法级注释。ElementType.PARAMETER 可以应用于方法的参数。ElementType.CONSTRUCTOR 可以应用于构造函数。ElementType.LOCAL_VARIABLE 可以应用于局部变量。ElementType.ANNOTATION_TYPE 可以应用于注释类型。ElementType.PACKAGE 可以应用于包声明。ElementType.TYPE_PARAMETERElementType.TYPE_USE 4、@Inherited @Inherited 注释表明注释类型可以从超类继承。当用户查询注释类型并且该类没有此类型的注释时，将查询类的超类以获取注释类型（默认情况下不是这样）。此注释仅适用于类声明。 5、@Repeatable Repeatable Java SE 8中引入的，@Repeatable注释表明标记的注释可以多次应用于相同的声明或类型使用(即可以重复在同一个类、方法、属性等上使用)。 自定义注解 现在有一个场景,比如有一些线程类需要放在线程池中运行,如果有多个消费者,那么这段代码就会复制几遍,我们可以利用自定义注解,在需要放入线程池中运行的类上注解,扫描这个注解,循环调用这段代码 123ExecutorService PROGRAM_THREAD_POOL = Executors.newFixedThreadPool(10);List&lt;ProgramConsumer&gt; programEventsList = IntStream.range(0, 10).mapToObj(i -&gt; new ProgramConsumer(EventType.PROGRAM)).collect(Collectors.toList());programEventsList.forEach(PROGRAM_THREAD_POOL::submit);0 添加自定义注解 12345678@Documented@Retention(RetentionPolicy.RUNTIME)@Target(&#123;ElementType.TYPE&#125;)public @interface StartConsumer &#123; String value() default "null"; EventType type();&#125; 注意这里 type 并没有添加默认值,所以这个注解在使用的时候一定要注入这个值,另外一个 value 表示从配置文件中获取的该线程的启动个数 1234567891011121314@Slf4j@StartConsumer(type = EventType.PROGRAM,value = "programNumberThreads")public class ProgramConsumer extends Consumer &#123; public ProgramConsumer(EventType eventType) &#123; super(eventType); &#125; @Override protected boolean staticize(EpgPublishEventDetail obj) &#123; log.info("program staticize start"); return true; &#125;&#125; 扫描注解类,这里利用的是 reflections 工具类,适合没有交给 spring 管理得类 引入依赖 12345&lt;dependency&gt; &lt;groupId&gt;org.reflections&lt;/groupId&gt; &lt;artifactId&gt;reflections&lt;/artifactId&gt; &lt;version&gt;0.9.11&lt;/version&gt;&lt;/dependency&gt; 实例 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859@Component@Slf4j@Order(1)public class ConsumerStart implements ApplicationRunner &#123; @Autowired private Environment env; @Override public void run(ApplicationArguments args) throws Exception &#123; log.info("event consumer start"); Reflections reflections = new Reflections("com.utstar.emc.executor.consumer"); Set&lt;Class&lt;?&gt;&gt; set = reflections.getTypesAnnotatedWith(StartConsumer.class); List&lt;ConsumerInit&gt; consumerInitList = new ArrayList&lt;&gt;(); for (Class&lt;?&gt; c : set) &#123; final StartConsumer annotation = c.getAnnotation(StartConsumer.class); Constructor constructor = c.getConstructor(EventType.class); String threadsProperty = annotation.value(); String threads = env.getProperty(threadsProperty); //默认为10 int threadsInt = 10; if (StringUtils.isNotBlank(threads)) &#123; try &#123; threadsInt = Integer.parseInt(threads); &#125; catch (Exception e) &#123; log.error("[&#123;&#125;] property is error,is not number", threadsProperty); &#125; &#125; ExecutorService THREAD_POOL = Executors.newFixedThreadPool(threadsInt); List&lt;Consumer&gt; consumers = IntStream.range(0, threadsInt).mapToObj(i -&gt; &#123; try &#123; return (Consumer) constructor.newInstance(annotation.type()); &#125; catch (Exception e) &#123; e.printStackTrace(); return null; &#125; &#125;).collect(Collectors.toList()); ConsumerInit consumerInit = new ConsumerInit(annotation.type().name(), consumers, THREAD_POOL); consumerInitList.add(consumerInit); &#125; for (ConsumerInit consumerInit : consumerInitList) &#123; log.info("type [&#123;&#125;] event consumer start,has [&#123;&#125;] threads", consumerInit.type,consumerInit.consumer.size()); consumerInit.consumer.forEach(consumerInit.executorService::submit); log.info("type [&#123;&#125;] event consumer end,has [&#123;&#125;] threads", consumerInit.type,consumerInit.consumer.size()); &#125; &#125; static final class ConsumerInit &#123; private final String type; private final List&lt;Consumer&gt; consumer; private final ExecutorService executorService; public ConsumerInit(String type, List&lt;Consumer&gt; consumer, ExecutorService executorService) &#123; this.type = type; this.consumer = consumer; this.executorService = executorService; &#125; &#125;&#125; 如果是springboot环境,可以利用 ApplicationContext 拿到,当然前提是你的这个类是交给 spring 管理的,这里有一个应用: 1Map&lt;String,Object&gt; beans = event.getApplicationContext().getBeansWithAnnotation(OnsConsumer.class); springboot+Aop+自定义注解实现日志记录 参考资料 https://blog.csdn.net/yuruixin_china/article/details/88827401 springboot扫描自定义类注解、方法注解 https://blog.csdn.net/u010928589/article/details/90293703 自定义spring boot-starter,实现自动配置,自定义注解扫描注入(类似dubbo-starter)]]></content>
      <categories>
        <category>java</category>
        <category>基础</category>
        <category>注解</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>注解</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图解java多线程-Immutable_模式]]></title>
    <url>%2Fblog%2F2019%2F11%2F01%2F%E5%9B%BE%E8%A7%A3java%E5%A4%9A%E7%BA%BF%E7%A8%8B-Immutable-%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[正文 使用 Immutable 模式的要点 实例创建后,状态不再发生变化 如下定义一个 Persion 类,注意 class 为 final,表示不能被继承,并且类的属性也是不可变的 1234567891011121314151617181920212223242526public final class Persion &#123; private final String name; private final String address; public Persion(String name, String address) &#123; this.name = name; this.address = address; &#125; public String getName() &#123; return name; &#125; public String getAddress() &#123; return address; &#125; @Override public String toString() &#123; return "Persion&#123;" + "name='" + name + '\'' + ", address='" + address + '\'' + '&#125;'; &#125;&#125; 比如下面这个类就不是不可变的,原因在于 Point 不是不可变的,因为外部可能还保存 Point 的引用 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public final class Line &#123; private final Point startPoint; private final Point endPoint; public Line(Point startPoint, Point endPoint) &#123; this.startPoint = startPoint; this.endPoint = endPoint; &#125; public Point getStartPoint() &#123; return startPoint; &#125; public Point getEndPoint() &#123; return endPoint; &#125; @Override public String toString() &#123; return "Line&#123;" + "startPoint=" + startPoint + ", endPoint=" + endPoint + '&#125;'; &#125; public static void main(String[] args) &#123; Point startPoint = new Point(1,1); Point endPoint = new Point(2,2); Line line = new Line(startPoint,endPoint); System.out.println(line); startPoint.x = 3; startPoint.y = 3; System.out.println(line); &#125; static final class Point&#123; private int x; private int y; public Point(int x, int y) &#123; this.x = x; this.y = y; &#125; @Override public String toString() &#123; return "Point&#123;" + "x=" + x + ", y=" + y + '&#125;'; &#125; &#125;&#125;运行结果:Line&#123;startPoint=Point&#123;x=1, y=1&#125;, endPoint=Point&#123;x=2, y=2&#125;&#125;Line&#123;startPoint=Point&#123;x=3, y=3&#125;, endPoint=Point&#123;x=2, y=2&#125;&#125; 上面的类可以将 Point 类改为不可变的,也可以改一下 Line 的构造方法,让外部不再持有引用,但是这样反射可能还是可以修改,一般这种类在程序中表示常量，而可以用枚举 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374public final class Line1 &#123; private final Point startPoint; private final Point endPoint; public Line1(Point startPoint, Point endPoint) &#123; this.startPoint = new Point(startPoint.x,startPoint.y); this.endPoint = new Point(endPoint.x,endPoint.y); &#125; public Point getStartPoint() &#123; return startPoint; &#125; public Point getEndPoint() &#123; return endPoint; &#125; @Override public String toString() &#123; return "Line1&#123;" + "startPoint=" + startPoint + ", endPoint=" + endPoint + '&#125;'; &#125; public static void main(String[] args) &#123; Point startPoint = new Point(1,1); Point endPoint = new Point(2,2); Line1 line = new Line1(startPoint,endPoint); System.out.println(line); startPoint.x = 3; startPoint.y = 3; System.out.println(line); try &#123; Field f = line.getClass().getDeclaredField("startPoint"); Object obj = f.get(line); Field fx = obj.getClass().getDeclaredField("x"); fx.setAccessible(true); Field fy = obj.getClass().getDeclaredField("y"); fy.setAccessible(true); fx.set(obj,3); fy.set(obj,3); fx.setAccessible(false); fy.setAccessible(false); System.out.println(line); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; static final class Point&#123; private int x; private int y; public Point(int x, int y) &#123; this.x = x; this.y = y; &#125; @Override public String toString() &#123; return "Point&#123;" + "x=" + x + ", y=" + y + '&#125;'; &#125; &#125;&#125;运行结果:Line1&#123;startPoint=Point&#123;x=1, y=1&#125;, endPoint=Point&#123;x=2, y=2&#125;&#125;Line1&#123;startPoint=Point&#123;x=1, y=1&#125;, endPoint=Point&#123;x=2, y=2&#125;&#125;Line1&#123;startPoint=Point&#123;x=3, y=3&#125;, endPoint=Point&#123;x=2, y=2&#125;&#125; 实例是共享的，且被频繁访问时 Immutable 模式的优点是&quot;不需要使用synchronized进行保护&quot;.能够在不失去安全性和生存性的前提下提高性能 考虑成对的 mutable 类和 immutable 类 比如jdk中的 StringBuffer 和 String 类. StringBuffer 类表示字符串的 mutable 类.它表示字符串可以随便改写,为了确保安全,改写时需要妥善使用 synchronized.而 String 类表示字符串的 immutable 类 StringBuffer 类中有一个以 String 为参数的构造函数,而 String 类中也有一个以 StringBuffer 为参数的构造函数.也就是说, StringBuffer 和 String 实例可以互相转换 参考资料]]></content>
      <categories>
        <category>书籍</category>
        <category>java</category>
        <category>多线程</category>
        <category>图解java多线程设计模式</category>
      </categories>
      <tags>
        <tag>书籍</tag>
        <tag>java</tag>
        <tag>多线程</tag>
        <tag>图解java多线程设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图解java多线程-Single_Threaded_Execution_模式]]></title>
    <url>%2Fblog%2F2019%2F10%2F31%2F%E5%9B%BE%E8%A7%A3java%E5%A4%9A%E7%BA%BF%E7%A8%8B-Single-Threaded-Execution-%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[正文 BadCount1 我来举一个例子,例如下面的代码 这里我定义了一个 Count 的接口,用来计数,方法有增加计数 add,减少计数 remove 以及获取当前计数 getCount 我根据这个接口实现了一个糟糕的计数类 BadCount1,该类可以用来记录某个房间到底进入了多少人,当有人进入则调用 add(),出去调用 remove() 我写了个测试类 CountThread 来测试这个计数类有多糟糕,它是一个线程类,线程中的方法是进入房间然后出去100次,测试方法 check 表示启动十个测试类,每个进出100次，当所有线程执行结束,打印房间中的人数,很明显理论上应该是0,然而结果有可能不是甚至是负数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566public interface Count &#123; void add(); void remove(); int getCount();&#125;public class BadCount1 implements Count &#123; private int count = 0; @Override public void add() &#123; count++; &#125; @Override public void remove() &#123; count--; &#125; @Override public int getCount() &#123; return count; &#125; /** * 3 */ public static void main(String[] args) &#123; BadCount1 badCount = new BadCount1(); CountThread.check(badCount); &#125;&#125;public class CountThread&lt;T extends Count&gt; implements Runnable &#123; private T t; public CountThread(T t) &#123; this.t = t; &#125; @Override public void run() &#123; for (int i = 0; i &lt; 100; i++) &#123; t.add(); t.remove(); &#125; &#125; public static &lt;K extends Count&gt; void check(K count) &#123; List&lt;Thread&gt; list = IntStream.range(0, 10).mapToObj(i -&gt; new Thread(new CountThread&lt;&gt;(count))).collect(Collectors.toList()); list.forEach(Thread::start); for (Thread thread : list) &#123; try &#123; thread.join(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; System.out.println(count.getCount()); &#125;&#125; 观察上面的代码,我们主要看以下线程中的方法 1234for (int i = 0; i &lt; 100; i++) &#123; t.add(); t.remove();&#125; 这个方法中调用的 add 和 remove 针对 count 变量做了 ++ 和 - - 操作,有可能发生如下操作 WorseCount1 上面 BadCount1 可能需要多执行几次才会看到效果,为了更快的出错,我写了个更糟糕的计数类 WorseCount1 1234567891011121314151617181920212223242526272829303132public class WorseCount1 implements Count &#123; private int count; @Override public void add() &#123; int tmp = count + 1; Thread.yield(); count = tmp; &#125; @Override public void remove() &#123; int tmp = count - 1; Thread.yield(); count = tmp; &#125; @Override public int getCount() &#123; return count; &#125; /** * -7 * */ public static void main(String[] args) &#123; WorseCount1 badCount = new WorseCount1(); CountThread.check(badCount); &#125;&#125; 那么怎么将这个糟糕的计数类变成安全可用的了,问题在于首先这个计数类是一个公用的类,所有的线程都公用这一个计数类,当其中一个线程将值修改之后,其他线程并不知道,导致所有线程对于 count 字段的修改并没有完全作用在 count 字段上，然而线程本来就是并发的,当他们运行到需要修改 count 的时候,需要让他们一个一个作用在 count,就像过独木桥一样,所有线程都要一个一个走在桥上. SafeCount 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public class SafeCount implements Count &#123; private volatile int count = 0; @Override public synchronized void add() &#123; count++; &#125; @Override public synchronized void remove() &#123; count--; &#125; @Override public synchronized int getCount() &#123; return count; &#125; /** * 0 */ public static void main(String[] args) &#123; SafeCount badCount = new SafeCount(); CountThread.check(badCount); &#125;&#125;public class SafeCount1 implements Count &#123; private AtomicInteger count = new AtomicInteger(0); @Override public void add() &#123; count.incrementAndGet(); &#125; @Override public void remove() &#123; count.decrementAndGet(); &#125; @Override public int getCount() &#123; return count.get(); &#125; /** * 0 */ public static void main(String[] args) &#123; SafeCount1 badCount = new SafeCount1(); CountThread.check(badCount); &#125;&#125; 这里千万不要认为是执行了 add() 又执行 remove() 所以有线程问题,就算线程里面只执行 add() 操作同样也会有线程问题,比如增加到100的时候突然切换线程,另外一根线程100-&gt;101,然后又切换回来,同样为100-&gt;101,所以其中的一次加就被省略了,因为切换的那次加法没有作用在切换后的线程中.]]></content>
      <categories>
        <category>书籍</category>
        <category>java</category>
        <category>多线程</category>
        <category>图解java多线程设计模式</category>
      </categories>
      <tags>
        <tag>书籍</tag>
        <tag>java</tag>
        <tag>多线程</tag>
        <tag>图解java多线程设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[maven私服相关操作]]></title>
    <url>%2Fblog%2F2019%2F10%2F24%2Fmaven%E7%A7%81%E6%9C%8D%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[正文 上传开发包到私服 自己开发的 jar 包 package 后,通过以下命令上传到私服 1mvn deploy:deploy-file -DgroupId=com.oracle -DartifactId=ojdbc6 -Dversion=1.0.0 -Dpackaging=jar -Dfile=C:\Users\Administrator\Downloads\Compressed\ojdbc-full\OJDBC-Full\ojdbc6.jar -Durl=http://172.20.1.100:8081/repository/3rdParty/ -DrepositoryId=3rdParty 上面没有指定pom文件,私服会默认生成一个空的pom文件,里面没有相关依赖,所以当你引用这个 jar 的时候,会发生某些他所依赖的类不存在 1mvn deploy:deploy-file -DgroupId=com.xuxueli -DartifactId=xxl-job-core -Dversion=1.9.1.RELEASE -Dpackaging=jar -Dfile=E:\DEV\xxl-job-core-1.9.1-SNAPSHOT.jar -Durl=http://172.20.1.100:8081/repository/3rdParty/ -DrepositoryId=3rdParty -DpomFile=E:\DEV\pom.xml 参考资料]]></content>
      <categories>
        <category>java</category>
        <category>maven</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>build tools</tag>
        <tag>maven</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[oracle相关命令]]></title>
    <url>%2Fblog%2F2019%2F10%2F23%2Foracle%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[正文 新建一个库 12345su - oraclesqlplus / as sysdbacreate tablespace xxljob datafile '/opt/oracle/db01/app/oracle/product/11.2.0/oradata/orcl/xxljob.dbf' size 3000m;create user xxljob identified by xxljob default tablespace xxljob quota 1000m on users;grant all privileges to xxljob; 这样就建立了一个xxljob的库，用户名为xxljob 密码为xxljob 参考资料]]></content>
      <categories>
        <category>后台</category>
        <category>数据库</category>
        <category>oracle</category>
      </categories>
      <tags>
        <tag>后台</tag>
        <tag>数据库</tag>
        <tag>oracle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java工具类之加密相关]]></title>
    <url>%2Fblog%2F2019%2F10%2F22%2Fjava%E5%B7%A5%E5%85%B7%E7%B1%BB%E4%B9%8B%E5%8A%A0%E5%AF%86%E7%9B%B8%E5%85%B3%2F</url>
    <content type="text"><![CDATA[正文 异或(XOR)加密 原理 一个整数 a 和任意一个整数 b 异或两次,得到的结果是整数 a 本身，即: a == a ^ b ^ b 这里的 a 就是需要加密的原数据,b 则是密钥.a ^ b 就是加密过程,异或的结果就是加密后的密文 密文 (a ^ b) 再与密钥 b 异或,就是解密过程，得到的结果就是原数据 a 本身 源码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788package com.utstar.filemonitoring.utils;import java.io.*;import java.nio.charset.StandardCharsets;/** * FileName: XORUtils * Author: creambing */public class XORUtils &#123; public static byte[] encrypt(byte[] data, String key) &#123; byte[] keyByte = key.getBytes(StandardCharsets.UTF_8); return encrypt(data,keyByte); &#125; /** * 异或算法加密/解密 * * @param data 数据（密文/明文） * @param key 密钥 * @return 返回解密/加密后的数据 */ public static byte[] encrypt(byte[] data, byte[] key) &#123; if (data == null || data.length == 0 || key == null || key.length == 0) &#123; return data; &#125; byte[] result = new byte[data.length]; // 使用密钥字节数组循环加密或解密 for (int i = 0; i &lt; data.length; i++) &#123; // 数据与密钥异或, 再与循环变量的低8位异或（增加复杂度） result[i] = (byte) (data[i] ^ key[i % key.length] ^ (i &amp; 0xFF)); &#125; return result; &#125; /** * 对文件异或算法加密/解密 * * @param inFile 输入文件（密文/明文） * @param outFile 结果输出文件 * @param key 密钥 */ public static void encryptFile(File inFile, File outFile, byte[] key) throws Exception &#123; InputStream in = null; OutputStream out = null; try &#123; // 文件输入流 in = new FileInputStream(inFile); // 结果输出流, 异或运算时, 字节是一个一个读取和写入, 这里必须使用缓冲流包装, // 等缓冲到一定数量的字节（10240字节）后再写入磁盘（否则写磁盘次数太多, 速度会非常慢） out = new BufferedOutputStream(new FileOutputStream(outFile), 10240); int b; long i = 0; // 每次循环读取文件的一个字节, 使用密钥字节数组循环加密或解密 while ((b = in.read()) != -1) &#123; // 数据与密钥异或, 再与循环变量的低8位异或（增加复杂度） b = (b ^ key[(int) (i % key.length)] ^ (int) (i &amp; 0xFF)); // 写入一个加密/解密后的字节 out.write(b); // 循环变量递增 i++; &#125; out.flush(); &#125; finally &#123; close(in); close(out); &#125; &#125; private static void close(Closeable c) &#123; if (c != null) &#123; try &#123; c.close(); &#125; catch (IOException e) &#123; // nothing &#125; &#125; &#125;&#125; 调用方式 123456789101112public static void main(String[] args) &#123; String s = &quot;hello world&quot;; String key = &quot;key&quot;; byte[] encrypt = XORUtils.encrypt(s.getBytes(StandardCharsets.UTF_8),key); System.out.println(&quot;encrypt:&quot;+new String(encrypt, StandardCharsets.UTF_8)); byte[] decrypt = XORUtils.encrypt(encrypt,key); System.out.println(&quot;decrypt:&quot;+new String(decrypt, StandardCharsets.UTF_8));&#125;result:口口口decrypt:hello world DES加密 源码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172package com.creambing.utils.encrypt;import lombok.extern.slf4j.Slf4j;import javax.crypto.Cipher;import javax.crypto.SecretKey;import javax.crypto.SecretKeyFactory;import javax.crypto.spec.DESKeySpec;import java.io.PrintWriter;import java.io.StringWriter;import java.nio.charset.StandardCharsets;import java.security.SecureRandom;/** * Date: 2019-7-25 14:22 * Description: */@Slf4jpublic class DesUtils &#123; /** * DES加密 * * @param data 加密内容的byte数组 * @param key 加密key * @return byte[] */ public static byte[] encryptByKey(byte[] data, String key) &#123; byte[] result = null; try &#123; // 可信任的随机数 SecureRandom secureRandom = new SecureRandom(); DESKeySpec keySpec = new DESKeySpec(key.getBytes(StandardCharsets.UTF_8)); SecretKeyFactory keyFactory = SecretKeyFactory.getInstance("DES"); SecretKey secretKey = keyFactory.generateSecret(keySpec); Cipher cipher = Cipher.getInstance("DES"); cipher.init(Cipher.ENCRYPT_MODE, secretKey, secureRandom); result = cipher.doFinal(data); &#125; catch (Exception e) &#123; StringWriter stringWriter = new StringWriter(); e.printStackTrace(new PrintWriter(stringWriter)); log.error("encryptByKey exception:" + stringWriter.toString()); &#125; return result; &#125; public static byte[] decryptByKey(byte[] data, String key) &#123; // 可信任的随机数 SecureRandom secureRandom = new SecureRandom(); DESKeySpec keySpec; byte[] result = null; try &#123; keySpec = new DESKeySpec(key.getBytes(StandardCharsets.UTF_8)); SecretKeyFactory keyFactory = SecretKeyFactory.getInstance("DES"); SecretKey secretKey = keyFactory.generateSecret(keySpec); Cipher cipher = Cipher.getInstance("DES"); cipher.init(Cipher.DECRYPT_MODE, secretKey, secureRandom); result = cipher.doFinal(data); &#125; catch (Exception e) &#123; StringWriter stringWriter = new StringWriter(); e.printStackTrace(new PrintWriter(stringWriter)); log.error("decryptByKey exception:" + stringWriter.toString()); &#125; return result; &#125; public static void main(String[] args) &#123; &#125;&#125; 由于上面用了lombok注解来调用日志,所以需要添加如下依赖 123456789101112131415161718192021&lt;lombock.version&gt;1.18.8&lt;/lombock.version&gt;&lt;slf4j-api.version&gt;1.7.26&lt;/slf4j-api.version&gt;&lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;$&#123;lombock.version&#125;&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt; &lt;version&gt;$&#123;slf4j-api.version&#125;&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;artifactId&gt;logback-classic&lt;/artifactId&gt; &lt;version&gt;1.2.3&lt;/version&gt;&lt;/dependency&gt; 调用方式 123456789101112131415161718192021222324252627282930313233package com.creambing.utils.encrypt;import org.junit.Assert;import org.junit.Test;import java.nio.charset.StandardCharsets;import java.util.Base64;/** * Created by [creambing.github.io] * Date: 2019/10/22 * Time: 16:24 */public class DesUtilsTest &#123; private String key = "1234567890"; private String s = "hello world"; private String encryptS = "KNugLrX23UddguNoHIO7dw=="; @Test public void encryptByKey() &#123; byte[] encryptByte = DesUtils.encryptByKey(s.getBytes(StandardCharsets.UTF_8), key); String encryptStr = new String(Base64.getEncoder().encode(encryptByte), StandardCharsets.UTF_8); Assert.assertEquals(encryptS, encryptStr); &#125; @Test public void decryptByKey() &#123; byte[] decryptByte = DesUtils.decryptByKey(Base64.getDecoder().decode(encryptS), key); String decryptStr = new String(decryptByte, StandardCharsets.UTF_8); Assert.assertEquals(s, decryptStr); &#125;&#125; 上面加密的结果于下面网站一样 https://tool.lami.fun/jiami/des 参考资料]]></content>
      <categories>
        <category>java</category>
        <category>utils</category>
        <category>加密</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>utils</tag>
        <tag>加密</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[elementui自定义校验]]></title>
    <url>%2Fblog%2F2019%2F10%2F22%2Felementui%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A0%A1%E9%AA%8C%2F</url>
    <content type="text"><![CDATA[正文 vue中elementui自定义校验 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104&lt;el-dialog title="Agent 信息" :visible.sync="dialogFormVisible"&gt; &lt;el-form :model="form" ref="form" :rules="rules"&gt; &lt;el-form-item label="EMC静态目录" prop="sourcedir" :label-width="formLabelWidth"&gt; &lt;el-input v-model="form.sourcedir" autocomplete="off"&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;el-form-item label="Agent 监控目录" prop="monitoringdir" :label-width="formLabelWidth"&gt; &lt;el-input v-model="form.monitoringdir" autocomplete="off"&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;el-form-item label="监听事件" :label-width="formLabelWidth"&gt; &lt;el-input v-model="form.monitoringevent" autocomplete="off" :disabled="true"&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;el-form-item label="消息加密KEY" :label-width="formLabelWidth"&gt; &lt;el-input v-model="form.encryptionkey" autocomplete="off" :disabled="true"&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;el-form-item label="防篡改开关" :label-width="formLabelWidth"&gt; &lt;el-switch v-model="form.switchstatus" active-color="#13ce66" inactive-color="#ff4949"&gt;&lt;/el-switch&gt; &lt;/el-form-item&gt; &lt;el-form-item label="IP" prop="ip" :label-width="formLabelWidth"&gt; &lt;el-input v-model="form.ip" autocomplete="off"&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;el-form-item label="DomainID" prop="domainid" :label-width="formLabelWidth"&gt; &lt;el-input v-model.number="form.domainid" autocomplete="off"&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;/el-form&gt; &lt;div slot="footer" class="dialog-footer"&gt; &lt;el-button @click="dialogFormVisible = false"&gt;取 消&lt;/el-button&gt; &lt;el-button type="primary" @click="onSubmit('form')"&gt;确 定&lt;/el-button&gt; &lt;/div&gt;&lt;/el-dialog&gt;&lt;script&gt;export default &#123; name: "SchedualIndex", data() &#123; var validcodeip = (rule, value, callback) =&gt; &#123; const reg = /^(\d&#123;1,2&#125;|1\d\d|2[0-4]\d|25[0-5])\.(\d&#123;1,2&#125;|1\d\d|2[0-4]\d|25[0-5])\.(\d&#123;1,2&#125;|1\d\d|2[0-4]\d|25[0-5])\.(\d&#123;1,2&#125;|1\d\d|2[0-4]\d|25[0-5])$/; if (reg.test(value)) &#123; callback(); &#125; else &#123; return callback(new Error("输入IP格式不合法!")); &#125; &#125;; return &#123; tableData: [], STATUSS: &#123; DOWN: &#123; status: "离线", type: "danger" &#125;, UP: &#123; status: "在线", type: "primary" &#125; &#125;, dialogFormVisible: false, form: &#123; sourcedir: "", monitoringdir: "", monitoringevent: "create,delete,modify", encryptionkey: "SqHonEP2", switchstatus: true, ip: "", domainid: "" &#125;, formLabelWidth: "120px", rules: &#123; sourcedir: [ &#123; required: true, message: "静态化目录不能为空", trigger: "blur" &#125; ], monitoringdir: [ &#123; required: true, message: "Agent 监控目录不能为空", trigger: "blur" &#125; ], ip: [ &#123; required: true, message: "IP 不能为空", trigger: "blur" &#125;, &#123; validator: validcodeip, trigger: "blur" &#125; ], domainid: [ &#123; required: true, message: "DomainID 不能为空", trigger: "blur" &#125;, &#123; type: "number", message: "DomainID 必须为数字值", trigger: "blur" &#125; ] &#125; &#125;; &#125;&#125;;&lt;/script&gt;``` 注意其中&#123;% img /images/front/elementui/elementui1.png %&#125;ip和mac校验```javascript/*ip正则验证*/var validcodeip = (rule, value, callback) =&gt; &#123; const reg = /^(\d&#123;1,2&#125;|1\d\d|2[0-4]\d|25[0-5])\.(\d&#123;1,2&#125;|1\d\d|2[0-4]\d|25[0-5])\.(\d&#123;1,2&#125;|1\d\d|2[0-4]\d|25[0-5])\.(\d&#123;1,2&#125;|1\d\d|2[0-4]\d|25[0-5])$/; if (reg.test(value)) &#123; callback(); &#125; else &#123; return callback(new Error('输入格式不合法！')); &#125;&#125;;/*mac正则验证*/var validcodemac = (rule, value, callback) =&gt; &#123; const reg = /[A-F\d]&#123;2&#125;:[A-F\d]&#123;2&#125;:[A-F\d]&#123;2&#125;:[A-F\d]&#123;2&#125;:[A-F\d]&#123;2&#125;:[A-F\d]&#123;2&#125;/; if (reg.test(value)) &#123; callback(); &#125; else &#123; return callback(new Error('输入格式不合法！')); &#125;&#125;; 目前自己支持 123456789101112131415string: Must be of type string. This is the default type.number: Must be of type number.boolean: Must be of type boolean.method: Must be of type function.regexp: Must be an instance of RegExp or a string that does not generate an exception when creating a new RegExp.integer: Must be of type number and an integer.float: Must be of type number and a floating point number.array: Must be an array as determined by Array.isArray.object: Must be of type object and not Array.isArray.enum: Value must exist in the enum.date: Value must be valid as determined by Dateurl: Must be of type url.hex: Must be of type hex.email: Must be of type email.any: Can be any type. 参考资料 elementui国内网址 https://element.eleme.cn/#/zh-CN/component/message-box async-validator https://github.com/yiminghe/async-validator]]></content>
      <categories>
        <category>前端</category>
        <category>elementui</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>elementui</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack注意事项]]></title>
    <url>%2Fblog%2F2019%2F10%2F22%2Fwebpack%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%2F</url>
    <content type="text"><![CDATA[正文 webpack代理设置 我们以vue-cli生成的架子为例,如下图设置的 dev 环境 123456proxyTable: &#123; '/api': &#123; target: 'http://localhost:10080', changeOrigin: true &#125; &#125; 注意:此配置需要起作用需要在webpack.dev.conf.js中配置 以上配置的作用是，我们在前端工程中调用的时候如下 如果我们前端工程启动的端口为8089 这样在调用接口 http://localhost:8089/api/agent/status 的时候会转为调用 http://localhost:10080/api/agent/status 这里跨域了,所以上面的配置 changeOrigin: true 就表示允许跨域 当然这个在浏览器上看到的效果是这样的,这里是404是正常的,因为服务端的接口地址为 http://localhost:10080/agent/status 这里我们可以加上如下配置 1234567proxyTable: &#123; '/api': &#123; target: 'http://localhost:10080', changeOrigin: true, pathRewrite: &#123; '/api': '/' &#125; &#125; &#125; 此时在 npm run dev,就可以调用通了,但是此种方法有一个问题,就是打包之后就无效了 打包成 dist 部署之后调用 http://localhost:8089/api/agent/status 还是会404,所以一般在 nginx 那里配置一下 /api 的代理 如果你是想打包直接放在springboot的resource文件夹里面直接方法那么就需要这么修改 springboot需要承担nginx的角色,所以首先后端接口需要一个统一前缀,比如后端接口改为 http://localhost:10080/api/agent/status 那么对于前端工程来说,需要把 pathRewrite: { ‘/api’: ‘/’ } 删掉,因为 /api 确实存在,打包之后直接放在springboot的 resource 的 static 文件下即可 如果springboot引入的是web,那么直接访问 http://localhost:10080 即可 springboot1.5.8 如果引入的是webflux,那么需要把静态资源暴露出来,需要访问 http://localhost:10080/index.html springboot2.1.4.RELEASE 1234@BeanRouterFunction&lt;ServerResponse&gt; staticResourceRouter()&#123; return RouterFunctions.resources("/**", new ClassPathResource("static/"));&#125; 参考资料]]></content>
      <categories>
        <category>前端</category>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[logback常用配置]]></title>
    <url>%2Fblog%2F2019%2F10%2F08%2Flogback%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[正文 添加依赖 12345678910111213141516&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.1.4.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;&lt;/parent&gt;&lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;&lt;/dependency&gt; 添加配置 RollingFileAppender使用 在resources文件夹下面添加logback.xml文件,配置如下 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;configuration debug="false" scan="true" scanPeriod="1 seconds"&gt; &lt;contextName&gt;logback&lt;/contextName&gt; &lt;property name="log.path" value="./log"/&gt; &lt;property name="pattern" value="%d&#123;yyyyMMdd:HH:mm:ss.SSS&#125; [%thread] %-5level %msg%n"/&gt; &lt;property name="CONSOLE_LOG_PATTERN" value="%date&#123;yyyy-MM-dd HH:mm:ss&#125; | %highlight(%-5level) | %boldYellow(%thread) | %boldGreen(%logger) | %msg%n"/&gt; &lt;appender name="console" class="ch.qos.logback.core.ConsoleAppender"&gt; &lt;!-- 字符串System.out（默认）或者System.err --&gt; &lt;target&gt;System.out&lt;/target&gt; &lt;!-- 对记录事件进行格式化 --&gt; &lt;encoder class="ch.qos.logback.classic.encoder.PatternLayoutEncoder"&gt; &lt;pattern&gt;$&#123;CONSOLE_LOG_PATTERN&#125;&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;appender name="file" class="ch.qos.logback.core.rolling.RollingFileAppender"&gt; &lt;!-- 被写入的文件名，可以是相对目录，也可以是绝对目录，如果上级目录不存在会自动创建 --&gt; &lt;file&gt;$&#123;log.path&#125;/xxx.log&lt;/file&gt; &lt;!-- 当发生滚动时，决定RollingFileAppender的行为，涉及文件移动和重命名。属性class定义具体的滚动策略类 --&gt; &lt;rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy"&gt; &lt;!-- 必要节点，包含文件名及"%d"转换符，"%d"可以包含一个java.text.SimpleDateFormat指定的时间格式，默认格式是 yyyy-MM-dd --&gt; &lt;fileNamePattern&gt;$&#123;log.path&#125;/xxx_%d&#123;yyyy-MM-dd&#125;.%i.zip&lt;/fileNamePattern&gt; &lt;timeBasedFileNamingAndTriggeringPolicy class="ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP"&gt; &lt;maxFileSize&gt;50MB&lt;/maxFileSize&gt; &lt;/timeBasedFileNamingAndTriggeringPolicy&gt; &lt;!-- 可选节点，控制保留的归档文件的最大数量，超出数量就删除旧文件。假设设置每个月滚动，如果是6，则只保存最近6个月的文件，删除之前的旧文件 --&gt; &lt;maxHistory&gt;6&lt;/maxHistory&gt; &lt;/rollingPolicy&gt; &lt;encoder class="ch.qos.logback.classic.encoder.PatternLayoutEncoder"&gt; &lt;pattern&gt;$&#123;CONSOLE_LOG_PATTERN&#125;&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;root level="info"&gt; &lt;appender-ref ref="console"/&gt; &lt;appender-ref ref="file"/&gt; &lt;/root&gt;&lt;/configuration&gt; 以上配置会让文件显示为彩色,并且生成文件还会每天压缩,在服务器上用 tail 或者 cat 命令会显示颜色,但是用 vim 打开并不会,相反会出现一些 口口 这样的字符 SiftingAppender使用 这里一个服务端对应多个客户端,需要在服务端将各个客户端的日志打印在不同的 log 日志里面,由于服务端和客户端已经建立的 netty 通信,所以这里就没有使用 Receiver 下面是服务端的配置,比上面不同的就是增加了一个 SIFT 的appender,以及一个 logger(这个类打印才是各个客户端上报的日志) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;configuration debug="false" scan="true" scanPeriod="1 seconds"&gt; &lt;contextName&gt;logback&lt;/contextName&gt; &lt;property name="log.path" value="./log"/&gt; &lt;property name="pattern" value="%d&#123;yyyyMMdd:HH:mm:ss.SSS&#125; [%thread] %-5level %msg%n"/&gt; &lt;property name="CONSOLE_LOG_PATTERN" value="%date&#123;yyyy-MM-dd HH:mm:ss&#125; | %highlight(%-5level) | %boldYellow(%thread) | %boldGreen(%logger) | %msg%n"/&gt; &lt;appender name="console" class="ch.qos.logback.core.ConsoleAppender"&gt; &lt;!-- 字符串System.out（默认）或者System.err --&gt; &lt;target&gt;System.out&lt;/target&gt; &lt;!-- 对记录事件进行格式化 --&gt; &lt;encoder class="ch.qos.logback.classic.encoder.PatternLayoutEncoder"&gt; &lt;pattern&gt;$&#123;CONSOLE_LOG_PATTERN&#125;&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;appender name="file" class="ch.qos.logback.core.rolling.RollingFileAppender"&gt; &lt;!-- 被写入的文件名，可以是相对目录，也可以是绝对目录，如果上级目录不存在会自动创建 --&gt; &lt;file&gt;$&#123;log.path&#125;/antitamperserver.log&lt;/file&gt; &lt;!-- 当发生滚动时，决定RollingFileAppender的行为，涉及文件移动和重命名。属性class定义具体的滚动策略类 --&gt; &lt;rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy"&gt; &lt;!-- 必要节点，包含文件名及"%d"转换符，"%d"可以包含一个java.text.SimpleDateFormat指定的时间格式，默认格式是 yyyy-MM-dd --&gt; &lt;fileNamePattern&gt;$&#123;log.path&#125;/antitamperserver_%d&#123;yyyy-MM-dd&#125;.%i.zip&lt;/fileNamePattern&gt; &lt;timeBasedFileNamingAndTriggeringPolicy class="ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP"&gt; &lt;maxFileSize&gt;50MB&lt;/maxFileSize&gt; &lt;/timeBasedFileNamingAndTriggeringPolicy&gt; &lt;!-- 可选节点，控制保留的归档文件的最大数量，超出数量就删除旧文件。假设设置每个月滚动，如果是6，则只保存最近6个月的文件，删除之前的旧文件 --&gt; &lt;maxHistory&gt;6&lt;/maxHistory&gt; &lt;/rollingPolicy&gt; &lt;encoder class="ch.qos.logback.classic.encoder.PatternLayoutEncoder"&gt; &lt;pattern&gt;$&#123;CONSOLE_LOG_PATTERN&#125;&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;appender name="SIFT" class="ch.qos.logback.classic.sift.SiftingAppender"&gt; &lt;!-- 在缺少 class 属性的情况下，默认的 discriminator 类型为 ch.qos.logback.classic.sift.MDCBasedDiscriminator --&gt; &lt;discriminator&gt; &lt;key&gt;clientId&lt;/key&gt; &lt;defaultValue&gt;unknown&lt;/defaultValue&gt; &lt;/discriminator&gt; &lt;sift&gt; &lt;appender name="FILE-$&#123;clientId&#125;" class="ch.qos.logback.core.rolling.RollingFileAppender"&gt; &lt;file&gt;$&#123;log.path&#125;/agent/agent_$&#123;clientId&#125;.log&lt;/file&gt; &lt;rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy"&gt; &lt;!-- 必要节点，包含文件名及"%d"转换符，"%d"可以包含一个java.text.SimpleDateFormat指定的时间格式，默认格式是 yyyy-MM-dd --&gt; &lt;fileNamePattern&gt;$&#123;log.path&#125;/agent_$&#123;clientId&#125;%d&#123;yyyy-MM-dd&#125;.%i.zip&lt;/fileNamePattern&gt; &lt;timeBasedFileNamingAndTriggeringPolicy class="ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP"&gt; &lt;maxFileSize&gt;50MB&lt;/maxFileSize&gt; &lt;/timeBasedFileNamingAndTriggeringPolicy&gt; &lt;!-- 可选节点，控制保留的归档文件的最大数量，超出数量就删除旧文件。假设设置每个月滚动，如果是6，则只保存最近6个月的文件，删除之前的旧文件 --&gt; &lt;maxHistory&gt;6&lt;/maxHistory&gt; &lt;/rollingPolicy&gt; &lt;encoder class="ch.qos.logback.classic.encoder.PatternLayoutEncoder"&gt; &lt;pattern&gt;%date&#123;yyyy-MM-dd HH:mm:ss&#125; | %X&#123;clientId&#125; | %highlight(%-5level) | %boldYellow(%thread) | %boldGreen(%logger) | %msg%n&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;/sift&gt; &lt;/appender&gt; &lt;logger name="com.utstar.filemonitoring.netty.handler.AgentLogHandler" level="INFO" additivity="false"&gt; &lt;appender-ref ref="SIFT"/&gt; &lt;/logger&gt; &lt;root level="info"&gt; &lt;appender-ref ref="console"/&gt; &lt;appender-ref ref="file"/&gt; &lt;/root&gt;&lt;/configuration&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758package com.utstar.filemonitoring.netty.handler;import com.alibaba.fastjson.JSON;import com.utstar.filemonitoring.bean.LoggerMessage;import com.utstar.filemonitoring.netty.Message;import lombok.extern.slf4j.Slf4j;import org.slf4j.MDC;/** * FileName: AgentLogHandler * Author: creambing * Date: 2019-10-08 10:42 * Description: * History: * &lt;author&gt; &lt;time&gt; &lt;version&gt; &lt;desc&gt; * 作者姓名 修改时间 版本号 描述 */@Slf4jpublic class AgentLogHandler implements MessageHandler &#123; @Override public void handlerMsg(Message msg) &#123; LoggerMessage loggerMessage = JSON.parseObject(msg.getMsgBody(), LoggerMessage.class); if (loggerMessage == null) &#123; log.error("U cmd to obj is null,the cmd is:[&#123;&#125;]", msg.getMsgBody()); return; &#125; MDC.put("clientId",msg.getClientId()); log.info(msg.getMsgBody()); &#125;&#125;package com.utstar.filemonitoring.bean;import lombok.AllArgsConstructor;import lombok.Builder;import lombok.Data;import lombok.NoArgsConstructor;/** * 〈一句话功能简述〉&lt;br&gt; * 〈日志封装实体类〉 * * @author creambing * @since 1.0.0 */@AllArgsConstructor@NoArgsConstructor@Data@Builderpublic class LoggerMessage &#123; private String body; private String timestamp; private String threadName; private String className; private String level;&#125; filter使用 如下是客户端的配置 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;configuration debug="false" scan="true" scanPeriod="1 seconds"&gt; &lt;contextName&gt;logback&lt;/contextName&gt; &lt;property name="log.path" value="./log"/&gt; &lt;property name="pattern" value="%d&#123;yyyyMMdd:HH:mm:ss.SSS&#125; [%thread] %-5level %msg%n"/&gt; &lt;property name="CONSOLE_LOG_PATTERN" value="%date&#123;yyyy-MM-dd HH:mm:ss&#125; | %highlight(%-5level) | %boldYellow(%thread) | %boldGreen(%logger) | %msg%n"/&gt; &lt;appender name="console" class="ch.qos.logback.core.ConsoleAppender"&gt; &lt;filter class="com.utstar.filemonitoring.filter.LogFilter"/&gt; &lt;!-- 字符串System.out（默认）或者System.err --&gt; &lt;target&gt;System.out&lt;/target&gt; &lt;!-- 对记录事件进行格式化 --&gt; &lt;encoder class="ch.qos.logback.classic.encoder.PatternLayoutEncoder"&gt; &lt;pattern&gt;$&#123;CONSOLE_LOG_PATTERN&#125;&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;appender name="file" class="ch.qos.logback.core.rolling.RollingFileAppender"&gt; &lt;!-- 被写入的文件名，可以是相对目录，也可以是绝对目录，如果上级目录不存在会自动创建 --&gt; &lt;file&gt;$&#123;log.path&#125;/antitamperagent.log&lt;/file&gt; &lt;!-- 当发生滚动时，决定RollingFileAppender的行为，涉及文件移动和重命名。属性class定义具体的滚动策略类 --&gt; &lt;rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy"&gt; &lt;!-- 必要节点，包含文件名及"%d"转换符，"%d"可以包含一个java.text.SimpleDateFormat指定的时间格式，默认格式是 yyyy-MM-dd --&gt; &lt;fileNamePattern&gt;$&#123;log.path&#125;/antitamperagent_%d&#123;yyyy-MM-dd&#125;.%i.zip&lt;/fileNamePattern&gt; &lt;timeBasedFileNamingAndTriggeringPolicy class="ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP"&gt; &lt;maxFileSize&gt;50MB&lt;/maxFileSize&gt; &lt;/timeBasedFileNamingAndTriggeringPolicy&gt; &lt;!-- 可选节点，控制保留的归档文件的最大数量，超出数量就删除旧文件。假设设置每个月滚动，如果是6，则只保存最近6个月的文件，删除之前的旧文件 --&gt; &lt;maxHistory&gt;6&lt;/maxHistory&gt; &lt;/rollingPolicy&gt; &lt;encoder class="ch.qos.logback.classic.encoder.PatternLayoutEncoder"&gt; &lt;pattern&gt;$&#123;CONSOLE_LOG_PATTERN&#125;&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;root level="info"&gt; &lt;appender-ref ref="console"/&gt; &lt;appender-ref ref="file"/&gt; &lt;/root&gt;&lt;/configuration&gt; 它与最上面的区别就是 console 的 appender 中多了下面这行,这行的作用是 console 捕获的消息都会被它拦截,在这里就可以把日志统一捕获并发送到服务端 1&lt;filter class="com.utstar.filemonitoring.filter.LogFilter"/&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041424344/** * Copyright (C), 2015-2019, 优地科技有限公司 * FileName: LogFilter * Author: creambing * Date: 2019-04-19 11:16 * Description: 日志拦截器 * History: * &lt;author&gt; &lt;time&gt; &lt;version&gt; &lt;desc&gt; * 作者姓名 修改时间 版本号 描述 */package com.utstar.filemonitoring.filter;import ch.qos.logback.classic.spi.ILoggingEvent;import ch.qos.logback.core.filter.Filter;import ch.qos.logback.core.spi.FilterReply;import com.utstar.filemonitoring.bean.LoggerMessage;import com.utstar.filemonitoring.netty.NettyClient;import java.text.DateFormat;import java.util.Date;/** * 〈一句话功能简述〉&lt;br&gt; * 〈日志拦截器〉 * * @author creambing * @create 2019-04-19 11:16 * @since 1.0.0 */public class LogFilter extends Filter&lt;ILoggingEvent&gt; &#123; @Override public FilterReply decide(ILoggingEvent event) &#123; LoggerMessage loggerMessage = new LoggerMessage( event.getMessage() , DateFormat.getDateTimeInstance().format(new Date(event.getTimeStamp())), event.getThreadName(), event.getLoggerName(), event.getLevel().levelStr ); NettyClient.sendUMsg(loggerMessage); return FilterReply.ACCEPT; &#125;&#125; 参考资料 logback中文手册 http://www.logback.cn/]]></content>
      <categories>
        <category>java</category>
        <category>springboot2</category>
        <category>logback</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>springboot2</tag>
        <tag>logback</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[spring2.x集成netty4.x]]></title>
    <url>%2Fblog%2F2019%2F09%2F17%2Fspring2-x%E9%9B%86%E6%88%90netty4-x%2F</url>
    <content type="text"><![CDATA[正文 添加依赖 maven 添加如下依赖 1234567891011121314151617181920&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.1.4.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;&lt;/parent&gt;&lt;properties&gt; &lt;netty.version&gt;4.1.22.Final&lt;/netty.version&gt;&lt;/properties&gt;&lt;dependencies&gt; &lt;!-- Netty --&gt; &lt;dependency&gt; &lt;groupId&gt;io.netty&lt;/groupId&gt; &lt;artifactId&gt;netty-all&lt;/artifactId&gt; &lt;version&gt;$&#123;netty.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- Netty --&gt;&lt;/dependencies&gt; 添加配置 application.properties 配置文件添加如下配置 12345netty.host=0.0.0.0netty.port=12268netty.bossNum=2netty.workerNum=4netty.backlog=4096 添加配置类和启动服务类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189package com.utstar.filemonitoring.netty;import lombok.Data;import org.springframework.beans.factory.annotation.Value;import org.springframework.boot.context.properties.ConfigurationProperties;import org.springframework.stereotype.Component;/** * FileName: NettyConf * Author: creambing * Date: 2019-09-17 11:13 * Description: * History: * &lt;author&gt; &lt;time&gt; &lt;version&gt; &lt;desc&gt; * 作者姓名 修改时间 版本号 描述 */@ConfigurationProperties(prefix = "netty")@Component@Datapublic class NettyConf &#123; private String host; private int port; private int bossNum; private int workerNum; private int backlog; private Long idleTime; @Value("$&#123;netty.host:127.0.0.1&#125;") public void setNettyHost(String nettyHost) &#123; NETTY_HOST = nettyHost; &#125; @Value("$&#123;netty.port:8888&#125;") public void setNettyPort(Integer nettyPort) &#123; NETTY_PORT = nettyPort; &#125; @Value("$&#123;netty.bossNum:1&#125;") public void setNettyBossnum(Integer nettyBossnum) &#123; NETTY_BOSSNUM = nettyBossnum; &#125; @Value("$&#123;netty.workerNum:2&#125;") public void setNettyWorkernum(Integer nettyWorkernum) &#123; NETTY_WORKERNUM = nettyWorkernum; &#125; @Value("$&#123;netty.backlog:1024&#125;") public void setNettyBacklog(Integer nettyBacklog) &#123; NETTY_BACKLOG = nettyBacklog; &#125; @Value("$&#123;netty.idleTime:60&#125;") public void setNettyIdletime(Long nettyIdletime) &#123; NETTY_IDLETIME = nettyIdletime; &#125; public static String NETTY_HOST; public static Integer NETTY_PORT; public static Integer NETTY_BOSSNUM; public static Integer NETTY_WORKERNUM; public static Integer NETTY_BACKLOG; public static Long NETTY_IDLETIME;&#125;package com.creambing.netty.server.thread;import com.creambing.netty.server.handler.*;import io.netty.bootstrap.ServerBootstrap;import io.netty.buffer.PooledByteBufAllocator;import io.netty.channel.*;import io.netty.channel.nio.NioEventLoopGroup;import io.netty.channel.socket.SocketChannel;import io.netty.channel.socket.nio.NioServerSocketChannel;import io.netty.handler.logging.LogLevel;import io.netty.handler.logging.LoggingHandler;import lombok.extern.slf4j.Slf4j;import org.springframework.context.annotation.DependsOn;import org.springframework.stereotype.Component;import javax.annotation.PreDestroy;import java.io.PrintWriter;import java.io.StringWriter;import static com.creambing.netty.server.conf.NettyConf.*;import static com.creambing.netty.server.constants.NettyConstants.*;/** * FileName: NettyThread * Author: creambing * Date: 2019-09-17 13:19 * Description: * History: * &lt;author&gt; &lt;time&gt; &lt;version&gt; &lt;desc&gt; * 作者姓名 修改时间 版本号 描述 */@DependsOn("nettyConf")@Component@Slf4jpublic class NettyThread implements Runnable &#123; private final EventLoopGroup bossGroup = new NioEventLoopGroup(NETTY_BOSSNUM); private final EventLoopGroup workerGroup = new NioEventLoopGroup(NETTY_WORKERNUM); @Override public void run() &#123; try &#123; ServerBootstrap b = new ServerBootstrap(); b.option(ChannelOption.SO_BACKLOG, NETTY_BACKLOG) .option(ChannelOption.ALLOCATOR, PooledByteBufAllocator.DEFAULT) .childOption(ChannelOption.ALLOCATOR, PooledByteBufAllocator.DEFAULT) .childOption(ChannelOption.SO_KEEPALIVE, true) .childOption(ChannelOption.TCP_NODELAY, true) .childOption(ChannelOption.SO_REUSEADDR, true) //重用地址 .childOption(ChannelOption.SO_RCVBUF, 65536) .childOption(ChannelOption.SO_SNDBUF, 65536); b.group(bossGroup, workerGroup) .channel(NioServerSocketChannel.class) .handler(new LoggingHandler(LogLevel.INFO)) .childHandler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;//每连上一个链接调用一次 @Override protected void initChannel(SocketChannel ch) &#123; log.info("Accept new connection: " + ch); // 设定读空闲时间，在这段时间内如果没有数据读到，就表示连接假死； ch.pipeline().addLast("idle-state-handler", new NettyIdleStateHandler()); ch.pipeline().addLast(new AcceptorIdleStateTrigger()); ch.pipeline().addLast("decoder", new NewLengthFieldBasedFrameDecoder(MAX_FRAME_LENGTH, LENGTH_FIELD_LENGTH, LENGTH_FIELD_OFFSET, LENGTH_ADJUSTMENT, INITIAL_BYTES_TO_STRIP, false)); ch.pipeline().addLast("new-encoder", new NewEncoder()); ch.pipeline().addLast("heartbeat", new HeartBeatReceiveHandler()); ch.pipeline().addLast("process", new NettyBusinessHandler()); &#125; &#125;); // 开始真正绑定端口进行监听 ChannelFuture future = b.bind(NETTY_HOST, NETTY_PORT).sync(); Channel channel = future.channel(); log.info("listening on [&#123;&#125;] at [&#123;&#125;] and ready for connection ...", NETTY_HOST, NETTY_PORT); if (future.isSuccess()) &#123; log.info("netty server start success"); &#125; channel.closeFuture().sync(); &#125; catch (Exception e) &#123; StringWriter stringWriter = new StringWriter(); e.printStackTrace(new PrintWriter(stringWriter)); log.error("start netty server has exception,caused by[&#123;&#125;]", stringWriter.toString()); &#125; &#125; /** * 销毁 */ @PreDestroy public void stop() &#123; bossGroup.shutdownGracefully().syncUninterruptibly(); bossGroup.shutdownGracefully().syncUninterruptibly(); log.info("stop netty server success"); &#125;&#125;package com.creambing.netty.server;import com.creambing.netty.server.thread.NettyThread;import lombok.extern.slf4j.Slf4j;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import javax.annotation.PostConstruct;import javax.annotation.Resource;@Slf4j@SpringBootApplicationpublic class ServerApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(ServerApplication.class, args); &#125; @Resource NettyThread nettyThread; @PostConstruct public void startCsServer() &#123; log.info("start netty server ..."); Thread t = new Thread(nettyThread); t.start(); &#125;&#125; 参考资料]]></content>
      <categories>
        <category>java</category>
        <category>springboot2</category>
        <category>netty4</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>springboot2</tag>
        <tag>netty4</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springboot2.x整合ehcache3.x]]></title>
    <url>%2Fblog%2F2019%2F09%2F16%2Fspringboot2-x%E6%95%B4%E5%90%88ehcache3-x%2F</url>
    <content type="text"><![CDATA[正文 添加依赖 maven 123456789101112131415161718192021222324&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.1.4.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;&lt;/parent&gt;&lt;dependencies&gt; &lt;!-- cache --&gt; &lt;dependency&gt; &lt;groupId&gt;org.ehcache&lt;/groupId&gt; &lt;artifactId&gt;ehcache&lt;/artifactId&gt; &lt;version&gt;3.7.1&lt;/version&gt; &lt;/dependency&gt; &lt;!-- JSR107 API --&gt; &lt;dependency&gt; &lt;groupId&gt;javax.cache&lt;/groupId&gt; &lt;artifactId&gt;cache-api&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-cache&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- cache --&gt;&lt;/dependencies&gt; 添加配置 application.properties中添加如下配置 12spring.cache.type=jcachespring.cache.jcache.config=classpath:ehcache.xml resources文件夹下面增加文件ehcache.xml,内容如下 1234567891011121314151617181920212223242526272829&lt;config xmlns:xsi=&apos;http://www.w3.org/2001/XMLSchema-instance&apos; xmlns=&apos;http://www.ehcache.org/v3&apos; xsi:schemaLocation=&quot;http://www.ehcache.org/v3 http://www.ehcache.org/schema/ehcache-core.xsd&quot;&gt; &lt;!-- 持久化路径 --&gt; &lt;persistence directory=&quot;/opt/wacos/server/data/antitamperserver&quot;/&gt; &lt;!-- 缓存模版,此处为了显示其用法,也可以不用模版直接在cache中配置与模版参数相同 --&gt; &lt;cache-template name=&quot;template&quot;&gt; &lt;key-type&gt;java.lang.String&lt;/key-type&gt; &lt;value-type&gt;java.lang.String&lt;/value-type&gt; &lt;resources&gt; &lt;!-- 单位默认为entries当用entries作单位时,可以不填--&gt; &lt;heap&gt;1&lt;/heap&gt; &lt;offheap unit=&quot;MB&quot;&gt;1&lt;/offheap&gt; &lt;!-- persistent 默认为false可以不填--&gt; &lt;disk unit=&quot;MB&quot;&gt;200&lt;/disk&gt; &lt;/resources&gt; &lt;/cache-template&gt; &lt;!-- 缓存对象,如果使用了模版会覆盖模版中的内容,使用uses-template=&quot;&quot;来引用模版 --&gt; &lt;cache alias=&quot;md5cache&quot; uses-template=&quot;template&quot;&gt; &lt;value-type&gt;com.utstar.filemonitoring.entity.Md5Cache&lt;/value-type&gt; &lt;resources&gt; &lt;disk unit=&quot;MB&quot; persistent=&quot;true&quot;&gt;5000&lt;/disk&gt; &lt;/resources&gt; &lt;/cache&gt;&lt;/config&gt; 注意:以上ehcache配置表示支持持久化,在写入内存得时候同样会写入文件,重启后数据再次写入内存 编写配置类和服务类 如下是根据上面ehcache.xml中配置得所编写配置类和服务类 配置类 1234567891011121314151617package com.utstar.ucloud.springcloud.ucloudmpc.conf;import org.springframework.cache.annotation.EnableCaching;import org.springframework.context.annotation.Configuration;/** * FileName: CacheConfiguration * Author: creambing * Description: 缓存 * History: * &lt;author&gt; &lt;time&gt; &lt;version&gt; &lt;desc&gt; * 作者姓名 修改时间 版本号 描述 */@Configuration@EnableCachingpublic class CacheConfiguration &#123;&#125; 服务类 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package com.utstar.filemonitoring.service;import com.utstar.filemonitoring.entity.Md5Cache;import lombok.extern.slf4j.Slf4j;import org.springframework.cache.annotation.CacheConfig;import org.springframework.cache.annotation.CacheEvict;import org.springframework.cache.annotation.CachePut;import org.springframework.stereotype.Service;import javax.cache.Cache;import javax.cache.CacheManager;import static com.utstar.filemonitoring.constants.Constants.CACHE_NAME_MD5;/** * FileName: Md5CacheService * Author: creambing * Description: * History: * &lt;author&gt; &lt;time&gt; &lt;version&gt; &lt;desc&gt; * 作者姓名 修改时间 版本号 描述 */@CacheConfig(cacheNames = "md5cache")@Slf4j@Servicepublic class Md5CacheService &#123; private final CacheManager cacheManager; public Md5CacheService(CacheManager cacheManager) &#123; this.cacheManager = cacheManager; &#125; @SuppressWarnings("UnusedReturnValue") @CachePut(key = "#id") public Md5Cache save(String id, Md5Cache value) &#123; return value; &#125; public boolean isKeyExists(String key) &#123; Cache&lt;String, Md5Cache&gt; cache = cacheManager.getCache(CACHE_NAME_MD5, String.class, Md5Cache.class); return cache.containsKey(key); &#125; public Md5Cache get(String key) &#123; Cache&lt;String, Md5Cache&gt; cache = cacheManager.getCache(CACHE_NAME_MD5, String.class, Md5Cache.class); return cache.get(key); &#125; @CacheEvict(key = "#id") public void remove(String id) &#123; &#125;&#125; 编写测试类测试上面服务类 12345678910111213141516171819202122232425package com.utstar.filemonitoring.test;import com.utstar.filemonitoring.init.AfterServiceStarted;import com.utstar.filemonitoring.init.FileMonitoringInit;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.boot.test.mock.mockito.MockBean;import org.springframework.test.context.junit4.SpringRunner;@RunWith(SpringRunner.class)@SpringBootTestpublic class AntitamperServerApplicationTests &#123; @MockBean FileMonitoringInit fileMonitoringInit; @MockBean AfterServiceStarted afterServiceStarted; @Test public void contextLoads() &#123; &#125;&#125; mockbean的这些类中的逻辑是springboot启动后需要执行的并且比较耗时,可以利用mockbean注入一个空类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package com.utstar.filemonitoring.test.service;import com.utstar.filemonitoring.entity.Md5Cache;import com.utstar.filemonitoring.test.AntitamperServerApplicationTests;import org.junit.Assert;import org.junit.Before;import org.junit.Test;import javax.annotation.Resource;/** * Created by [creambing.github.io] * Date: 2019/9/16 * Time: 11:22 */public class Md5CacheServiceTest extends AntitamperServerApplicationTests &#123; @Resource Md5CacheService md5CacheService; private Md5Cache md5Cache = new Md5Cache(); private String key = "/topic/4600000133/json/ setting.json"; private String md5 = "sdfsfsffsdf"; @Before public void before()&#123; md5Cache.setMd5(md5); md5Cache.setOptime("121313131"); &#125; @Test public void save() &#123; md5CacheService.save(key,md5Cache); &#125; @Test public void isKeyExists() &#123; Boolean f = md5CacheService.isKeyExists(key); Assert.assertEquals(true,f); &#125; @Test public void get() &#123; Md5Cache md5Cache = md5CacheService.get(key); Assert.assertEquals(md5,md5Cache.getMd5()); &#125; @Test public void remove() &#123; md5CacheService.remove(key); Boolean f = md5CacheService.isKeyExists(key); Assert.assertEquals(false,f); &#125;&#125; 参考资料]]></content>
      <categories>
        <category>java</category>
        <category>springboot2</category>
        <category>ehcache3</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>springboot2</tag>
        <tag>ehcache3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springboot2.x整合redis-reactive]]></title>
    <url>%2Fblog%2F2019%2F09%2F02%2Fspringboot2-x%E6%95%B4%E5%90%88redis-reactive%2F</url>
    <content type="text"><![CDATA[前言 目的 正文 参考资料]]></content>
      <categories>
        <category>java</category>
        <category>springboot2</category>
        <category>redis</category>
        <category>reactive</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>springboot2</tag>
        <tag>redis</tag>
        <tag>reactive</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo美化全过程记录]]></title>
    <url>%2Fblog%2F2019%2F08%2F14%2Fhexo%E7%BE%8E%E5%8C%96%E5%85%A8%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[前言 博客就像是自己的宠物一般,要是长得更好看一点就更好了 目的 美化首页 Hexo自定义页面做首页 利用图床加快图片资源的加载速度，目前比较好用的图床是微博免费图床,利用微博相册实现的 利用html5的新特性 利用vidage.js来优化video的加载 为 hexo next 主题中代码块添加复制按钮 1.下载 clipboard.js 地址: https://github.com/zenorocha/clipboard.js https://raw.githubusercontent.com/zenorocha/clipboard.js/master/dist/clipboard.min.js 保存文件到 theme/next/source/js/src 下 2.clipboardjs 的使用 也是在 theme/next/source/js/src 目录下，创建 clipboard-use.js，添加内容如下: 1234567891011121314151617181920212223242526272829! function(e, t, a) &#123; /*页面载入完成后，创建复制按钮*/ /* code */ var initCopyCode = function() &#123; var copyHtml = ''; copyHtml += '&lt;button class="btn-copy" data-clipboard-snippet=""&gt;'; copyHtml += '&lt;span&gt;复制&lt;/span&gt;'; copyHtml += '&lt;/button&gt;'; $(".highlight .code pre").before(copyHtml); var clipboard = new ClipboardJS('.btn-copy', &#123; target: function(trigger) &#123; return trigger.nextElementSibling; &#125; &#125;); clipboard.on('success', function(e) &#123; e.trigger.innerHTML = "&lt;span&gt;复制成功&lt;/span&gt;" e.clearSelection(); &#125;); clipboard.on('error', function(e) &#123; e.trigger.innerHTML = "&lt;span&gt;复制失败&lt;/span&gt;" &#125;); &#125; initCopyCode(); $(".highlight").hover(function() &#123; $(".btn-copy").css(&#123; opacity: 1 &#125;); &#125;, function() &#123; $(".btn-copy").css(&#123; opacity: 0.4 &#125;); $(this).find(".btn-copy")[0].innerHTML = "&lt;span&gt;复制&lt;/span&gt;"; &#125;);&#125;(window, document); 在 theme/next/source/css/_custom/custom.styl 样式中添加如下代码: 123456789101112131415161718192021222324252627282930313233//代码块复制按钮.highlight&#123; //方便copy代码按钮（btn-copy）的定位 position: relative;&#125;.btn-copy &#123; display: inline-block; cursor: pointer; background-color: #eee; background-image: linear-gradient(#fcfcfc,#eee); border: 1px solid #d5d5d5; border-radius: 3px; -webkit-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none; -webkit-appearance: none; font-size: 13px; font-weight: 700; line-height: 20px; color: #333; -webkit-transition: opacity .3s ease-in-out; -o-transition: opacity .3s ease-in-out; transition: opacity .3s ease-in-out; padding: 2px 6px; position: absolute; right: 5px; top: 5px; opacity: 0;&#125;.btn-copy span &#123; margin-left: 5px;&#125; 引用 在 themes/next/layout/_layout.swig 文件中引用（/body）之前添加： 123&lt;!-- 代码块复制功能 --&gt;&lt;script type="text/javascript" src="/js/src/clipboard.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="/js/src/clipboard-use.js"&gt;&lt;/script&gt; 注意如果你的博客在github上面有子路径,注意这里需要变化 正文 参考资料 https://www.jianshu.com/p/80e0e1058bda Hexo自定义页面做首页 https://chrome.google.com/webstore/detail/新浪微博图床/fdfdnfpdplfbbnemmmoklbfjbhecpnhf 新浪微博免费图床chrome插件 http://chenfengkg.cn/optimize-blog/ hexo美化 https://eonun.com/2019/07/14/Hexo主题美化/ hexo美化 https://11.tt/posts/2018/how-to-play-with-live2d-on-hexo/ 看板娘]]></content>
      <categories>
        <category>博客</category>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用docker安装vsftp和sftp]]></title>
    <url>%2Fblog%2F2019%2F04%2F09%2F%E5%88%A9%E7%94%A8docker%E5%AE%89%E8%A3%85vsftp%E5%92%8Csftp%2F</url>
    <content type="text"><![CDATA[Welcome to my blog, enter password to read. Incorrect Password! No content to display! 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]]></content>
      <categories>
        <category>docker</category>
        <category>docker-compose</category>
        <category>vsftp</category>
        <category>sftp</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>docker-compose</tag>
        <tag>vsftp</tag>
        <tag>sftp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用docker安装gitlab]]></title>
    <url>%2Fblog%2F2019%2F04%2F06%2F%E5%88%A9%E7%94%A8docker%E5%AE%89%E8%A3%85gitlab%2F</url>
    <content type="text"><![CDATA[Welcome to my blog, enter password to read. Incorrect Password! No content to display! U2FsdGVkX1+VmP2yP2mXD3bbXvnW2Lx382ykRH7TxMif3sb6+s28g/ePs4bTJPnA+/dIu6Eiz2rU1jzwdVcBEknGUGINHjwzP59jePR7nsmA2rLXm3GKJhwYicwla0t5wZMlKizF3mpSEzTkXkKlTN28iP5y60zB0oEmZz59UYriGBHI0nHlhFNDjBLNVpwxYjFB8Ft4h5vt5lLljCDHnWae2X4UrBjwuB6RCKrAGDLxrL3ehV3R/o5iD8Cq09iSvkouHu5+jCJYi+cka9UH/cPLfaun/e43m3W9U7E4ibmuZCA8/BVW04m6u5wZAjRMU9EKZJRyxH7AtenFYLOG7VVmRnR2ypUFGw6c8hnfvb9BqgXky0R2+uT9skkCIBipmaF6QGnvIHLggNTwj0WNvfpq8dujrOMpOkSAbQioRmJWAHj9BT5aFeBcDjx7kf/IqNyDr67ilP602Jlui29YovmLwRQZrZw02u6fghnnkAYJ41zeYuuhlA9ccyiVE/VDI3/A2un5ZXJQPwgmHS2BPqCDl60sUZJgg/C0KUoswCdbqqu6yO2uOKXhZrYHm19NBIrVt5WaIrjk5I2iucztN4mKgQ9OdaN34XgRDxhQq7x7RPYTHdvSFpWSIprcv5pfvZyLAQAK/DTq5MUL9noBpVB71XJrwcOQ13QfZ4F5T2+Yhyo09kbSRkDOKx3M09SBK0zOQC6m6ZBLfESxdheCCrm6xqXZniSsw9f0DlMTO3V58zJFd0IQttL1Tmwf75ovjRCK2a2vIrkCcmklZTG7NQoiwxR4x2QGwzjv5LW8UUVrXCmSVoKCQ5h5X7Vlv9lYKM3pXL0+wrf3Od+///JsR18bUXU9uF6znRoPn/UqDpbtuMOkI31XpWwV3hJAzwJfA6QbjYadAK0SxpaFmFFxZWWkZ7kzWSYHJsrFLur7v/LWdGQlp9qJSHDJ9B1QTGezGtj3Dcrd93bfcw95dfo5A5Fje1PS8u5D57M5LaqpcCqE+avDRuLexloa29T4a9e58NNgC63IAlMGnQ1vbufbq0fGMIhC4COumX5nCNGZAO2KRSlXrFZFe0pTjkK4tpARpQA1HDOlg4xTHMaYU73oFUv6fQ5DiVLeVNJ//IwO+iDktrLpiYCx18ZxYXYd1nFH0xYDXJiTAlNB1h83FLVAS4I6HQRVIO6ysBUol6xdheN2XitLJsnql9V/VMXvF+YOwN62VWudvJn5QPU1cWysBTW3jIg3T3MCFf9X5vm0XVqX5vnVh4t4v5IEAvB4+byX7KA8bhWbZpM80QTO3dQZzNsD+NYjwE27LsQUiyDZDYCrYl6NQEBDW8ChLxWDNMMkmN0fSxhriMI9sjXGmB/+8JrbhiTY53VM41/1d/z6lbqjFiy8BPriNF6AAyw/VBcM89wteiykYSAhAAEYC/aDcF98zIKQgngYIo8vyzAEsjfiQnKYMmLwXu4PfcOK0PixoptJu7MxnvA5D6e/Pht10vPHp/0bZdKCbnwWi0SgqlnFL3AOEwC6WiQw8prlZzPEzQgrMp2/kcZMPWT2gzH8uU6eG36idFq27MgcomDjIe+4WrwE1GTKrh5z8Slfebl1ATm2nBWL7pNNS9HvlUUsjj1VP2E7wpzqoKmFrWxCkO7iga6laXU0oOqwZvZuQoMvbKbpElHzm0UER0qOwDrcoFZX2oJJtPQNZt5Ts/NOdJ825Fo+APOI0l0GKFNJSq7aQrlYSF3rtERJBz7AjkYXsvoxuqczaBddcRZTdBeteB7pLVDOQpW9VEUpRuYYGSpsNfzaI5C2D2VtjXnhJOKJlvI0W8yxcVunhPG7nWKB9trQ9Z369FdOecHK+RGFNiiA9k41Brl9IGx9+S+SNd/m8jvZJIR1IYp6+nPlXXGR1E/GrtB3H7QzZ1ylmnMoJfOUNAoNkwQkXNgt8gZ7z+E4wn/zH063MOQwDmCCgD7eSeVhdonomqhyT4JwJEwYZ3tVcIa8YR1x9kPQ0e/G97rNOGegsfq8+jb8M9QrIqrQpka4F7rm6v3uQal65IWeCPY6LHuPlO8qE9Latq7Z2bWlJ7+vLlgOm73MCxzfsatGlz0V+fgmM0NJ94JuQ1THv172a3jTnVIAhvnwAa7rf0KET9DVQuK4KLbwt1u08Iu79LpOBxcRLW+KpaVW25l2wOw2buP+lPm6sFkqVlvlvDm3KbFIKDxL27AdSKvxB8/ECDkRH0v2rh5pY/xN6ngl/CJ4wLLEJ760kQ4fzBl1pS8Aj3Xq7kw64qjQLYhggOP292rlTjpUPgI1X+wqbmy6FSCK1zm0d8elYOgsV8XAV4dF+KBUl7F2MYg6nxeuWz3zcHxQx3SbeV+RoSY0GjL38lJ7fwB3uiTGOwjTWkWDYnr2kw5h9TL3pQ/oYLyZeKLFOTXukCL4Q157i4hDo9kFvRir7vgG75258pSe7ZkahtUNEzPH3VtXAfsrci/1FLvugRv4orAYjH9VGu4zxrfkMttXvAPilEajHsp9+m1l0LrldIHzx0AE7s+KFPF6xgnB2gk43Z5xErWq59U1rQkiD6jnHRT04N3vrlCk5/pJcw+d02oArbxg8FJwRYFXpoUSgBega/gM5PF/eYJfz416qMHtNN+58avimYQxUmpBE5UKl3/aL/lqHZSSVpY1gHjXOuiSXdEZZYl82dNxn5Hj/LROngTgFb6lt82sTAA0PNBPTJP4XTfy0Nwb9TrFrQWiHJVD8028K2K6Wyugd1wRsb1lvtpykhZXXfKv/yoxqXrr9IBvoWTplwmwGIgxk49V0nPVEdq78eLcEqoWY8XZMzo2/bMW39b0HMzUbXWly0szwBCUHOpED5j2MlRXW5bpfLv8ABn8+14VZa6xnfZMTfUJLuDB0i6XMpBxeIsL+QuCzgAYUXBRaf7uAv4/KP8524X7615iFg2sh2iTvzy9ydwFw5fvNwY+LPM3jP5mg+kXov+eiX3Y/AAp7pPf8dAtEC5LGUnf9W075ttbWR5maJ6UE85wNDZ1jSFM43LqOOSjo7q+eeYkx9l/DVb6SHe8xRsLCXSUwy3nKMEP7+KUox5aMCAgcrBgF3ad4x/BU8xzDi0N8/6f7djd+ocewitArsL09w7sy6+TEI+hq71DwdSo4vQZmZG+ok+LIu2E8eox9yK0roJwXAUiHpylZJ5ui+nlaZBa3IJd4RiLxY0fNa2jVrFcIHzNn0QfznTWS1VfVPdjEtEL7W5zsV6uy7zsjK3/3SqD/OmlGa8Ry2G450QagvuPvCheeb3Tzrao/7/bFQ3jMTnYxPknD5UWhghydbxX+9h3T8DO1oiA3W68NnsShq+OBkSpp20+WnplAgijjwA/evdSE9pPVHKGpW2gv6uOFYoiqdyj4FsJbUKiCh0jrJnONDQqBbCs9yMY/ILDoPOov+bPGUCzZ8QWsPrTekECGDCLgpTBqrI7hDnuoqnocOPUA8UoiADwcvDA7pvqOwaSM26EpkwZYfvn11nCtiOTxyhE7dWXYc4ZF9CfWGCSYlGCfQysIx32J3BqETXwyr/9s3M/hpbXzRvnklhIILidEW9Pao8fgxRQAWWXbRFDvIPGSs0au5IKAk3/LynfcqoQnyEMy008zF9IaIOm/RuYrQitj7Y5wwFazWLJD94wCkWWFQs/oh423B6C21uultq5NXJqZ4NfR/y8xme7hys6vwtbayXw0OlwiuZiq2UBNJQHHHg/EkbwPsmCvpFky+WIM6NDHCbLjaWkstb22eFPS3v7p3eWYIfr8iemFOXTfKnKHHpgEqEuwtlh+qNYDPN9QsJnQ4FJ1+BC63pRlqcM7DkBctdIowOxP3sRw3tFPJQ2Kg/mfzNXqAZlpIJF9SDiFW1+4mDi+lytfEbNUxOCJtmza56tf6G1Jw5ovrOvT67bsv5Huh5yD5nda4czN9K5/n0A9W/v0aLUm52oM8OFOJ6z9D44FzPK6pTyomYRYDkYVyiJT307a5VxBczBZ7vpflwyu2yyG4BRrLFHA4R7rKZCwuA9huzmEuTK/k359OUrFhOBCknWAa4vG/JVRg3nkEaNR5gBvHt/1ukCXKwi8KaTvdQSgsDYZkqcPsSnqMkBGy4Jof72OxfzWT7K0K4eHDJcKEv1MLyaWXwybd/vwzJMk4AkHsmsi8GcvV9tvITJu+YRz3IDuG5YefvitqS/WEQKC3EQ7p7tav9YI0ukDgP44A6lVEyMx2AuVpO6/phZtoBmiEnNeeGH4gg3feM89JyHV7AE7FXvO2Ov/9WgQ0j9JKuRtKl95ijllV6ASuUSJJ0t77k+/FLua0sqwSBZlHCXbHejkCSzjhVYiHdR2gM1tMBsM2XKYPLznjM9lxDYlm+fCVZkjye+Qsx8+3ta65zcKSKP2+jBqDhr3p4uS0ACq7pMxibVibfCWE6NiOGnj6ODdlCaJ3EXBZvRypkCdITqYjo4zJhn/neG5PWxLyD0itzOJ7yMpDpql2VHQ/Q5ITxQnPbtJqpeXXA1b3zJuTy+OW/9+WoaVO2Bcr94C6cz2QmP31mBrZSwLq6hp/tYy4Zgva2DDM39vpah7v/NqQ/aEU/JG7UeZZ/N/nt6RnZK0eEmVC3wPaNq75IQg7kYtkjY34MQaHbjjyFoBAlxe4CktzuJngVb5thDLwJ9IGfM1GJyH4N/w4IEkNelTP7IqaEtTkzvOLtV+rl5jb2nbtYZkw3EVqWwb81qzrQDS7Jsj/eB36Y7rEpbJxIHplpEmKBasuowlSh1UaiyvGGOQl2xY/Mer35eWvOKXh9beSuALQZuHhMeAPM0nxdb3iW/ABCCR4IlitcI8GbNCJvYzINWJDfaWz4Kafy0BbEZcI1pfJNF0csmxQvpkHyUHJ6Vnl9kdjnZxhfKBcDLI/YuFWpUhYZsnK7pvTCCHD/cqHZ5ISug03l9RpFFZmRTNhfWwdAxJnd0IuCu2gFS5W1Vp+pYcMTyTL1z4/MVqDf0ZOdD8X9Tp0uo+1NmI3BePoJOTJHHZFmN/waO6NGWqh8jbAXMYgpgFlv3fBB2lPxQharEt8Y0BYGxERVeZTRE3f0GmsX0LO/hqJMMDr+NNiLnYSS5gA1CAMwGOTgHbjl/Z4BAMxKM7OgMFk+kYl9LKa1mJ4ikjK1kMmJvghqa0eOkWPLuoArd23P13lQuODjPEQPcpD78Hi3KCPRGYPyj0jFe/MSh7wsY07O713RS7MQAZMoobkgPVHVBcP/WQmrXvpEGjsKBhrnua2kIJwhgpqYfcAfuPhu1F+UQfrPrgiI/Xnvv8lr0lDDaBOpgYrEKVDqohM6IbSMimB8C3q33JFCMOOx3Gp5YozFcJ7wrMZQJQCNThBVezLD6LJGx+kVgaD7pGTMKWfeinQd2VI9TjorBAM7BeQ379qihQz7Z5So9ynu8Jht0rZxPr3v0D3kNpBIv9G0mLPgBOtKYR+ma65GXx3zSZ+XBGyvc+d0pKfy4oCPBYW8m51bpf1i5BcdnJygK5thEhK96CSyyqz2IKYUNIGbo5jTzfw8Yrzb5pLj7EuvbTjQuJQQv0qCsD8fAijrcuyJXZmJAwzLx37ceCMQ71SpxEko4RuVkwoazJEcUVxYHLGSccRQ4xVZ/QVq3IeSBQiAyEj4eXx4hpcgQ6ITwZg23/KgA9eCe7oxf4LlB6BOraxT7BYZyM6zYHmo/Fzknftn2DUUOaPnq5Ut82nKUQUdqv6WEOtSTfMXuVCT9MHCrzNLx+7kwX2u2SM7zhw+F7ccOTsBEW2GgrFugp1ICzX5RtcU0oUK5Caj+BmnhRPHvawKREatFLoRh0dPphm0SrzA1aUgvH2dGpYfY+l+rNNhCnf9Gq1XoJwCiOcoBPP+EZWBuvDQCk62Zl3kxgKv7bCcSop2vpINx9hD9NZG36uzSZEaySdMEbYcaqD4Y4jWOquHQHCwGY2vEwMQfy89ohdhRZDv3HilnvWYMUv4Y1IXJEuP58ek5DyXHKrW01u+40VXcGai+ozQCtezkRkoOAFk0M96xz37Fmcrt5fGrfisMBhfFhmdTsVqYdvMB7OxrX4CWTWNf4pAgNym5Wr04Qu51CeYk8W5jidx2Zs9ez+XCbvTiz2YT0ctOPKgNjR9qh4XkSBFH3Oe9YZ6iFhanT9GEVIHxd99SB6oFqasJ/jL9OCp7bBe9fo94PRjUb0v5J74gtYef0S10rguYICvUUX0glO4H4w30xD7hiw94boMDDo3c1Fil2Xf8DWQkKDOypyQvn5XOzs+R3dbXutGEHF/Dsvm6z+EdPHS9FOCUA5yPYIL5OinB3JdFOr452RHL/fAKmQ/JkRnukiwB6WtRLKQ89QKc8lD4yOpaBJNsPAZrEvod99xDooiUvfhKJ5MlbBHBBn5L1Gs5+ZPqE9LU9A8T2LI+USrLtK88pKV8l3K2j2Uog+fxRoi63dwXgoEleZOY/W4BTWPF4FER1xfpZuh+Y1SlyCCakhhPF2CVFVzQEdi+SG2PZgQDoQq+rx1lFOeEE3oDJQvKOR1OUhfJAgSeBK55VhfWD+9wkZVrt28L3su/91yrIlSHBfYEmumJn3R+D60+8Nrnonmk3ch0u+a+a3x9nvgE8w9px86UyVgDfyX7NP2xJnQCJEDyD/TOBU31GrUJ8WndvDelIDlLHd1/+33Jc4PsjCQ9kSPcWKcmPSEaTUSUetrNfCzABn3Gp5jkPFO2FhV2sqW3ECbKepAjHfuo3MG+VjPl5C2BF9SemwLo4y+uuhyAEkTL+x5IfcqIGd6VDcSneYYedz38mWLJ5c8BYs6d9W7qodrugVcy7Ui8I9rjM8OYCN6P4b/WWxb1m51sOunBpXAWewsS3EL5nv2j/Qnw2xoQnf8JDO5wnrwc7AU4Loh/TDWmwaKXRJekCmpv6hoMncNZzbe0Xxcd+Cfz9zbz34BapKtNv9i0kDRdVM/b0ZyTCvAis2oPg6ntM81Z6wBkHbkwwP2bZhs0xjrlN5AGsv9nj79QDY3JKXQBISEb2VxTNkGoinUtQ4+H+VZOmSAQ3euZM5OKIl62CeZk8Qz2aDEhZfNwWnKudke5aSogiN+E5fpy181tMWAcqSPXoengnvNw53NQMEhz/5Qi7WGqWDcV/zzObtKBNebKlkxtAxyOAzY9cGKgCCTllnTOfyOOaJAqnSRjOI8NNlPw+aXP+VND05cQpz3aSOMKVE4cgn81IYCYQKwC06Aoa7nHC7e3j9dno1jUNo+35MaGUlqZYn8bIiC3SxH91ZHr/8b2qI8xEOJhnC1ZacU31xh/44jHC+880sdfoQ/XvGmfJbjnZDmpVqmUOhsXvrk+32t8fGnTH8qjZL09bg3AhruE6Bvi+JpL647vCJpKla/kIeDEPdyZwg2Uf4Ut2Fn4Lhubx/7S3budaS1aT9/ArQqqc9myACkhWzVOxD8JZZZJnKXiYbb+FMZGbB8+jVG/DBa39WE7vo8g1xpWSC81vC0VpBWWHdPKLHO3WqCMONZp5SwKKGibkNfKzjT0OM+4W1ERCnUb71QEuebrxeoXRfSPkViHDFnMtFs5hm8ltK7/YsBQF4z9DR8kpMuDQlvjcSOWdXwO8zU/d9OJ9PejxgqajnCoSLT9gU8ImZhZLbiloC4wxc2yPYaCxCGkZC4FMt5OsnFwAdRwKpyMcobqh5JO1w57QQVbD4xLpqg8vovTcSENehd4qOqb6psooOUJZ5JTFBL7AhNAi2IyjRftFFfpv3FfXwJu/PLK4DT4WUMY9bBJGEC/Nd4ZKutaUCBJ/Cgq8WCTh/CdQmcKmiTweJL6HoblkPRo+xgXjiFr2AQxXBw+VwZglMX6TDBUwQpBra0QK3X7yjvWggJWkfzcFBUi/FqUOa13miKlVG6d6OWL12zSe1wj/nqufHc1FWHRNtikj4XuJNvS0HIo3nNcTfHqvatISQp83gPx9oDLk+gmnmbQppir5/o6Gnk7I+nUu6be7QoWtOK7fK+kIRcyIJx8Oz2YA1MYNDS0H6LsHYYNW9hRT0WV22szjpGRNzfBgc+QE501Nk4Ci5APq88hpnhlX13zRbWovXGA+v1LvBZaWfZg6q08zbW2L2LykFzEFTSxZFHRs9iHTYjTRTugdgPlJO/f/4P9GnB6Q5+Z5OsRGg2Pkbu5FToibJ8rgHUurXOIp6AFCkRquAYtaIeF4BPrmhoy48kWap+RmIPdDnDAA7LcMOmm/DUNjEWuIK8KZ2Ch5DUqwovsM835rXbcKR1JfR6UedXkwOo1ge9ANKX9o6nHNaBt9nKAVKl7uHneHuUqPWB3jdlxIazXvyThKGlP84QPxgWohE0Ph3qMmYekOJiqcJEGN5KTJO09lKSL04mok2DLqXnz1MSjNGHzvmm0rOFc3EXorLf+OOl2EXhLorkm8pxpBwEQdLg0FV5uV4EW1OvV4e0EzvlWWXUt4V1DimXPxx2Bqu+qkvVv7oPrluqJQUbw+FCPUt6nHu7ylPM35N/w0X3mmTZU5xTDnjTFyVHVczKbyEBBXbOQ6O9RquMZZ63VShe8es1ZgV1KXed/XtGagSO8bo+ZqeQwHSK9hJGERawRGSoLGlTITcX1XLOX0TTVAR3h2xE3mo11pt6rTgkVJoRUxlqAhOp1Y0a0FVcB9myiXptlclweSufXhCo3Xy9unfWybdfc23N8FWlln4MA0IhCbylyAKKlxkfCDRYR2FQ91HqpIU6ApvyFvR3yElx7WalOvqdwVA0ToIVRAmb+T0dwywVwPaxaylaP/+CvaRGUfpfXVM8pAEOYkw4tQui8ERWPLejD7wZdTT8LJ50Y7EJv5iXEZ3APh9Jr/DFwYfwnz899ApXhcq69Eo5YygJjjqkCRExdVA/5DWI16yP9i0akufQNB7siKYVy4uwwHmwGycGZFA03NFU0hK47smICuieS/4KPhBBtQWot7CxDBLZ5SS3owhM4AhvFKPoPYz7gbwLzDq/AiUSw2lt/v4DsP2Bxdt9g09onCtwzmFqhmdq9+vg8a0+KwPFdUsjeENUccymjukdFrxZ05ydupXOIGjgABqgslcIfoeFoauysmZTRHajs9oaffhM2jU4r70T7nRgtb63KTfTqx8+as/9BDSKayINfDf31bfteL2so94Wd40kNuJf3wfMA4DEjfHXftF3KIWoBGjj4a9J9bdILgwkjCyT0Va0f/lAZYAu4/L3kOPXkrLpH+y+bwdTOgeOqh0Ws1UMwjQtSEQ58RL9BPoO+iBinRleqjLezAObmCeVSi94ywv3C/y6vNy2Y4c3lNLH32ESDSbRMNGFXWTYlmIqKmdgh19KkoNT4wVRSgKrMeEU2VYzlJjUN2V+JYqC48Y2yr51pybad17cllm3WGD9C14xHgEehYy6EJJam76OzTR0jpdzp/rdZkPh3peIkBJ8RBc8DcSdUMIx/iBbFY9/rGNWuW9/fwO5Q2qi++eScEikGff1+4jQ2/HXt+OajgL5K/uy9/X2gy2g6cFkHBAS7Gwn/+Yz5sHmb0V9FPnw2zkWSiTl9OgStO6SmnLqlxmbVjyHidDj4VNrjl/DzwwbNums62x81JBaCS+XISdlCLSRSpX67q7jZddV7RP/JGHMcGq3+7RGsC2MMhRW/n0JqnxbPvQYuAtPYiXXhQauTNQt6uqzQMBnyVoHNoC8/zH967bNrlbb7GqrS2YfxjHe16wjoIC5gNKvfXnc00hkC6EuoGiY8bmSbj2d/pfAQstzx85eZcc47teUgb7AG74VUJNYNDHy/8CqHLXGOCCX2mZDR4k1Ya9Xm5dsp/6z/HxrPofE8HfpRHr0SwUqqxC1eSMPHi++0VlPcss4pYaXbhfMZ1+zd9tZs/Qr4EQB46sYceiXjEOQ5jRH2c/hiY2kQIas2+IJXR6nuWxEYgbUXiiRzI+o+pnFKvlnyNPKn0gqIOeLHS7RMw+BOxnhxMapj+Oqt3SNBto17HNQi9YSAZsr2pbXIbvzfZdHlgsU1gK9f8QrhrrPpQ7FgAl1Zw5dBNIqRI0TW0eOpWDlQbPdhjviFt5T34oHM871pNEtFWAOhjR9HR+GAIURkzhuwfREdN4OjBOA0tZ5AE+EbltBXqxcwzq3OJNPDh3NOK2XosYm529eSTD+XK2dtuKKHBO0uuuw7xH86jBnKU5LPX8XtdEiZ3LWEmw2LUOa1vYgOckQzxcY5H5YI7RVCr9sgKM0bNct+1SxoDbb3maH4r1cMQ/70rME7NJDodzLxoUYDp1Q80udqbuV9IqFXMLJmin8d0AEzU+XL5puLyWZ/cCQL6nX12wEtc5G4IODsymQcwvNfkLZA0XeNNc6wTVaqfcN169GOxrqYY3WlbgdhJuLst4B5ZKlSmEP85lias3lTK1RM5TOcSWEGbtV339gz5hqlEs99NobStRhP+9LTKAPVNkS7RwUWX438dFo7kTzi4Imk4MZGe2hi7UuUUpmCU8TINPa5rM0yFZfw5S3g1OmChxyga2QapJHwxhRURVocmqeX/+B0dodVXiAp3DmUhh+K4HJSCK486r8qs3fUm+Xd+CUoU1hfYRoppRqLh7qR+WA5oHlTodn0inTsjrOCikJLpPHQb2B6T7JZwHkI+OWLZPeKTScwytgVcOIMK60YCZETOgYAN+nwZEkyKoFyAU/G4XLZvFBvt16e27mAVsnJRuABV+/g9bRtUDovEXNKTTtInxMvxUPRG0TVa7fzPLEQ9WxaYdBu97ahdkYDXY7F84Ni1SQDSO+H/c4GIJ3eKS4T9INKCECItGFBtpZz6HZaEibvbnLnAlTUYs2VSc2BH93GKB+NDpe7lLYZ/dHwFEWxg+lv4F1faqjhMtrwXYMaXXq9Eu1YrRyRKMR1AVl8Oh7nmc6i/6ecaCy5yftsAvcNwtr1qqtpC6PNB9DHPCkfcm0AS2uG+xOL+FRK4i0yRNfXzUVsHINg66mmW5gvoGycvUg4jjy/ZTBoSe8SLspnG/s/6SjZyAkJiKJbdStrQw0msEOsHItUZiUl/Bsr1fRCH+95iIP87a26JX7EenAHjCM2zLBdAJyF81aYfNKDungjED3pr22rMKjl72ptyXfNPbhm7hiq0nyYJTTm1/xkUyOB4ixiJ6aiJWWdRFyr4fUqsaK5Jac2TbQQCxLW0yCsMO5i7+hQGPC+2cDGp+DqmegWYT0UvOlW52l/lBBYntwkHN9b7VGNZXPRE00YWVKed2HW8pc1x+ZErW0scmPpVcqmOIc/iz6qtGXOuilrx7yMQIBRIIpMx3V2QljPYsTTqweNIiuE6aXsPqEN7R2xcWjD5P+r8Csm6n2M6oifwyh6WMynidDcvOMUk1+W4Y6LLahH/HsNogiMQWBofwP9uNb+LVml5EGu6i9x2ZV5KIEMK+E58Geh4jk4ZRA8wpvNbm7+elDDjryLZcWL8cS7iDrZbJbgusygKdvjsMMdmmOFAWSodPNiSL8f6aTM5gj+UdcUem9YiXUOwSSdp26HlpPf7eq22q1zE6RZFCoDaWxtVggw6EoENmw3KSOXeK0nuv/ZIHkgI+UDeBSPlpXr96TgGxLJqc6EV45KPuM5PZQ/rhiVPvwSFpJPdMFewinoeEqnjosOxNeNv8BKTn9+oBnnaMxmaxmqLqJuPA6T9e/Zl6HnyUOnD2urxaAK4fHKbVdgaDRkk+QRzw4GRcRTk4ojDAk7zN2chTU8FvMaoODnlUPCqFlWZpg++Ej3Qzr78UFxSsylsz75+recg+JgaWIoovs11HnUFvyFzTOtAM0UJt8g6375lOsG1JHopU3VEJEaLp0VxUQ7npwBgsZFQB0uQRIAK/p4ys8WTIK20XI3jqPbfrvsTq9+Rpl1YIOnUYaKMkKFNPanL0aKIQ0scqdHmfKQ5Yzj4c9PpL3wpz0ga0mes454/iqJ8Jh6Zb2mg646ju0R2Lqbrlh10f5cT++1QTdgiwPC93haIks8YB7GduS/SUoxS7/geZ0bbT6qY9+VEUdSirqzM+tY0tVaJ8yCerTGyaUVLVfS3d6W7Q8Qjb2lDtM+arvJhBrr5679TgdT4Es6FI0Bd4OYQH8FVAh6e1jsGjHrzp6/rbSZ85jwjGI/NWwDTUbynSuyPrYDaJaeJZxvWX00aQGW]]></content>
      <categories>
        <category>docker</category>
        <category>docker-compose</category>
        <category>gitlab</category>
        <category>版本控制</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>docker-compose</tag>
        <tag>gitlab</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[现场web项目不定时卡顿问题排查]]></title>
    <url>%2Fblog%2F2019%2F04%2F04%2F%E7%8E%B0%E5%9C%BAweb%E9%A1%B9%E7%9B%AE%E4%B8%8D%E5%AE%9A%E6%97%B6%E5%8D%A1%E9%A1%BF%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5%2F</url>
    <content type="text"><![CDATA[前言 某次web系统升级之后，前方反馈当登录人数增加，用户点击某页面出现卡顿问题，一段时间后才正常 目的 解决现场 正文 参考资料]]></content>
      <categories>
        <category>tomcat7</category>
        <category>strus1</category>
        <category>现场</category>
      </categories>
      <tags>
        <tag>tomcat7</tag>
        <tag>strus1</tag>
        <tag>现场</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用docker安装jenkins]]></title>
    <url>%2Fblog%2F2019%2F03%2F25%2F%E5%88%A9%E7%94%A8docker%E5%AE%89%E8%A3%85jenkins%2F</url>
    <content type="text"><![CDATA[Welcome to my blog, enter password to read. Incorrect Password! No content to display! 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]]></content>
      <categories>
        <category>运维(OP)</category>
        <category>docker</category>
        <category>jenkins</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>docker-compose</tag>
        <tag>jenkins</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IDEA新建Gradle项目]]></title>
    <url>%2Fblog%2F2019%2F03%2F21%2FIDEA%E6%96%B0%E5%BB%BAGradle%E9%A1%B9%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[前言 利用 IDEA 快速新建一个 springboot2 的基于 gradle 依赖管理的项目 目的 利用 IDEA 快速新建一个 springboot2 的基于 gradle 依赖管理的项目 正文 1.下载 gradle 网上也有教程说直接用 idea 自带的，但是为了性能，我选择下载当下最新版本-v5.3 下面是下载链接:https://gradle.org/releases/ ,我一般下载 complete 版本 2.设置环境变量或者在IDEA中导入 如果只是在 IDEA 中新建，只需导入即可，但为了之后方便使用命令，遂添加环境变量 📷截图 ⛔️ gradle5.3 需要在java8 环境下才能正确显示 gradle -v 3.IDEA 新建 gradle 项目 📷截图 4.IDEA 导入 gradle 的 springboot2 项目 在sprign官网生成项目骨架，然后利用idea导入 📷截图 参考资料 1.spring 官网]]></content>
      <categories>
        <category>IDEA</category>
        <category>管理依赖</category>
      </categories>
      <tags>
        <tag>IDEA</tag>
        <tag>Gradle</tag>
        <tag>springboot2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[docker-compose搭建kafka集群]]></title>
    <url>%2Fblog%2F2019%2F03%2F20%2Fdocker-compose%E6%90%AD%E5%BB%BAkafka%E9%9B%86%E7%BE%A4%2F</url>
    <content type="text"><![CDATA[Welcome to my blog, enter password to read. Incorrect Password! No content to display! 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]]></content>
      <categories>
        <category>运维(OP)</category>
        <category>docker</category>
        <category>kafka</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>docker-compose</tag>
        <tag>kafka</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[docker-compose搭建zookeeper集群]]></title>
    <url>%2Fblog%2F2019%2F03%2F20%2Fdocker-compose%E6%90%AD%E5%BB%BAzookeeper%E9%9B%86%E7%BE%A4%2F</url>
    <content type="text"><![CDATA[Welcome to my blog, enter password to read. Incorrect Password! No content to display! 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]]></content>
      <categories>
        <category>运维(OP)</category>
        <category>docker</category>
        <category>zookeeper</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>docker-compose</tag>
        <tag>zookeeper</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[centos7最小化安装设置固定ip]]></title>
    <url>%2Fblog%2F2019%2F03%2F20%2Fcentos7%E6%9C%80%E5%B0%8F%E5%8C%96%E5%AE%89%E8%A3%85%E8%AE%BE%E7%BD%AE%E5%9B%BA%E5%AE%9Aip%2F</url>
    <content type="text"><![CDATA[前言 虚拟机装了个CentOS7，使用的NAT的网络模式，为了防止再次启动系统的时候网络IP发生变化，因此设置静态IP和DNS 目的 使虚拟机中的centos7在重启后ip不变 正文 1.查看原有ip分配情况 由于CentOS是最小化安装，没有ifconfig命令，因此可以采用ip命令查看。 1ip addr 📷截图 我们发现 lo 是回环地址,另一个 ens33 就是就是我们要修改的文件 2.vi修改文件 1vi /etc/sysconfig/network-scripts/ifcfg-* 📷截图 123456BOOTPROTO=static #dhcp改为static（修改）ONBOOT=yes #开机启用本配置，一般在最后一行（修改）IPADDR=192.168.1.204 #静态IP（增加）GATEWAY=192.168.1.2 #默认网关，虚拟机安装的话，通常是2，也就是VMnet8的网关设置,（增加）NETMASK=255.255.255.0 #子网掩码（增加）DNS1=192.168.1.2 #DNS 配置，虚拟机安装的话，DNS就网关就行，多个DNS网址的话再增加（增加） 📷截图 3.重启网络服务 1service network restart 4.检查网络 1ip addr 参考资料]]></content>
      <categories>
        <category>centos7</category>
        <category>运维(OP)</category>
      </categories>
      <tags>
        <tag>centos7</tag>
        <tag>最小化安装</tag>
        <tag>固定ip</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[EffectiveJava第三版第五条读书笔记]]></title>
    <url>%2Fblog%2F2019%2F02%2F01%2FEffectiveJava%E7%AC%AC%E4%B8%89%E7%89%88%E7%AC%AC%E4%BA%94%E6%9D%A1%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[前言 自己java编程已有两年，自己也写过一些轮子，也在工作中针对自己以前写的代码重构过，但是距离那些优秀的类库总有一些差距，最近在看 Effective Java 第三版，书中总结甚为精辟，遂在阅读过程中逐条写下笔记，以指导自己更加有效的使用 java 编程语言及基本类库,涵盖部分jdk 7,8,9 的新特性 目的 Prefer dependency injection to hardwiring resources 优先考虑依赖注入来引用资源,代替硬编码 正文 硬编码 硬编码是将数据直接嵌入到程序或其他可执行对象的源代码中的软件开发实践，与从外部获取数据或在运行时生成数据不同。 硬编码数据通常只能通过编辑源代码和重新编译可执行文件来修改，尽管可以使用调试器或十六进制编辑器在内存或磁盘上进行更改。 硬编码的数据通常表示不变的信息，例如物理常量，版本号和静态文本元素。 另一方面，软编码数据对用户输入，HTTP服务器响应或配置文件等任意信息进行编码，并在运行时确定。 使用场景 许多类依赖于一个或多个底层资源。例如，拼写检查器依赖于字典。将此类类实现为静态实用工具类并不少见 123456789// Inappropriate use of static utility - inflexible &amp; untestable!public class SpellChecker &#123; private static final Lexicon dictionary = ...; private SpellChecker() &#123;&#125; // Noninstantiable public static boolean isValid(String word) &#123; ... &#125; public static List&lt;String&gt; suggestions(String typo) &#123; ... &#125;&#125; 参考资料]]></content>
      <categories>
        <category>书籍</category>
        <category>java</category>
        <category>EffectiveJava第三版</category>
      </categories>
      <tags>
        <tag>书籍</tag>
        <tag>java</tag>
        <tag>EffectiveJava第三版</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[EffectiveJava第三版第四条读书笔记]]></title>
    <url>%2Fblog%2F2019%2F01%2F31%2FEffectiveJava%E7%AC%AC%E4%B8%89%E7%89%88%E7%AC%AC%E5%9B%9B%E6%9D%A1%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[前言 自己java编程已有两年，自己也写过一些轮子，也在工作中针对自己以前写的代码重构过，但是距离那些优秀的类库总有一些差距，最近在看 Effective Java 第三版，书中总结甚为精辟，遂在阅读过程中逐条写下笔记，以指导自己更加有效的使用 java 编程语言及基本类库,涵盖部分jdk 7,8,9 的新特性 目的 Enforce noninstantiability with a private constructor 通过私有构造器强化不可实例化的能力 正文 这个正是利用私有构造器的原因，例如 JDK 中 java.lang.Math 或者 java.util.Arrays 将基本类型的值或者数组类型上的相关方法利用静态方法组织起来 或者通过 java.util.Collections 的方式，把特定接口的对象上的静态方法，包括工厂方法组织起来 这样的工具类不希望被实例化，因为实例化对它没有任何意义 副作用: 这个类不能被子类化，无法被继承 1234567891011121314151617181920212223242526272829303132333435363738394041/** * https://creambing.github.io Inc. * Copyright(c)2018-2025 All Rights Reserved. */package com.creambing.technicalbook.effectivejava3.creatinganddestroyingobjects.item4;import java.util.HashMap;import java.util.Map;/** * Class Name: MapUtils * Description: * 通过私有构造器强化不可实例化的能力 * Enforce noninstantiability with a private constructor * 使用范围： * 当需要编写只包含静态方法或者静态域的类时，例如 java.lang.Math java.uril.Arrays * 单例模式 * 缺点： * 这个类不能被子类化，无法被继承 * &lt;p&gt; * author: CreamBing * time: 2019-01-30 13:58 * version: v1.0.0 */public class MapUtils &#123; //私有构造，表示这个类初始化没有意义 private MapUtils() &#123; //可以防止反射实例化 throw new AssertionError(); &#125; //在google guava类库中就有该工具方法，在方法类型推断还没有出来之前 public static &lt;K, V&gt; HashMap&lt;K, V&gt; newHashMap() &#123; return new HashMap&lt;&gt;(); &#125; public static void main(String[] args) &#123; Map&lt;String, String&gt; map = MapUtils.newHashMap(); &#125;&#125; 参考资料]]></content>
      <categories>
        <category>书籍</category>
        <category>java</category>
        <category>EffectiveJava第三版</category>
      </categories>
      <tags>
        <tag>书籍</tag>
        <tag>java</tag>
        <tag>EffectiveJava第三版</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[EffectiveJava第三版第三条读书笔记]]></title>
    <url>%2Fblog%2F2019%2F01%2F30%2FEffectiveJava%E7%AC%AC%E4%B8%89%E7%89%88%E7%AC%AC%E4%B8%89%E6%9D%A1%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[前言 自己java编程已有两年，自己也写过一些轮子，也在工作中针对自己以前写的代码重构过，但是距离那些优秀的类库总有一些差距，最近在看 Effective Java 第三版，书中总结甚为精辟，遂在阅读过程中逐条写下笔记，以指导自己更加有效的使用 java 编程语言及基本类库,涵盖部分jdk 7,8,9 的新特性 目的 Enforce the singleton property with a private constructor or an enum type 用私有构造器或者枚举类型强化Singleton属性 正文 利用枚举类型实现单例-天然的防止反射和反序列化调用 123456789public enum SingletonWithEnum &#123; //枚举元素本身就是单例 INSTANCE; //添加自己需要的操作 public void singletonOperation()&#123; System.out.println("complete singleton"); &#125;&#125; 这里貌似没有提供私有构造，其实在enum内部实现中隐藏了私有构造 12枚举类实现其实省略了private类型的构造函数枚举类的域(field)其实是相应的enum类型的一个实例对象 推荐的写法时面向接口 1234public interface MySingleton &#123; void doSomething();&#125; 123456789101112public enum MySingletonImpl implements MySingleton &#123; INSTANCE; @Override public void doSomething() &#123; System.out.println("complete singleton"); &#125; public static MySingleton getInstance() &#123; return MySingletonImpl.INSTANCE; &#125;&#125; 静态内部类实现单例 123456789101112public class Singleton &#123; private static class SingletonHolder &#123; private static final Singleton INSTANCE = new Singleton(); &#125; private Singleton() &#123; &#125; public static Singleton getInstance() &#123; return SingletonHolder.INSTANCE; &#125;&#125; 解决序列化和反射漏洞需如下修改 12345678910111213141516171819public class Singleton2 implements Serializable &#123; private static class SingletonHolder &#123; private static final Singleton2 INSTANCE = new Singleton2(); &#125; private Singleton2() &#123; // 防止反射获取多个对象的漏洞 if (null != SingletonHolder.INSTANCE) &#123; throw new RuntimeException("it is a Singleton"); &#125; &#125; public static Singleton2 getInstance() &#123; return SingletonHolder.INSTANCE; &#125; // 防止反序列化获取多个对象的漏洞 private Object readResolve() throws ObjectStreamException &#123; return SingletonHolder.INSTANCE; &#125;&#125; 如何选用： -单例对象 占用资源少，不需要延时加载，枚举 好于 饿汉 -单例对象 占用资源多，需要延时加载，静态内部类 好于 懒汉式 参考资料 https://blog.csdn.net/qq_27093465/article/details/52180865 Java 枚举(enum) 详解7种常见的用法 https://www.jianshu.com/p/4e8ca4e2af6c Java 单例模式的两种高效写法]]></content>
      <categories>
        <category>书籍</category>
        <category>java</category>
        <category>EffectiveJava第三版</category>
      </categories>
      <tags>
        <tag>书籍</tag>
        <tag>java</tag>
        <tag>EffectiveJava第三版</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java编程思想第四版第十四章读书笔记]]></title>
    <url>%2Fblog%2F2019%2F01%2F20%2Fjava%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E7%AC%AC%E5%9B%9B%E7%89%88%E7%AC%AC%E5%8D%81%E5%9B%9B%E7%AB%A0%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[前言 最近一段时间重读了java编程思想，把一些东西重新理解记录一遍 目的 整理知识点，方便以后回顾，这一章主要讲解了java的类型信息 正文 1.类型信息 关键词：RTTI，加载，泛型class引用，instanceof，isInatance，工厂设计模式，反射机制，代理设计模式，动态代理，空对象，反射获取private对象 运行时类型信息可以使得在程序运行时发现和使用类型信息。 Java在运行时识别对象和类信息的两种方式： 12RTTI，假定我们在编译时就知道了所有类型“反射”机制，允许在运行时发现和使用类信息 2.为什么需要RTTI 参考资料]]></content>
      <categories>
        <category>书籍</category>
        <category>java</category>
        <category>java编程思想第四版</category>
      </categories>
      <tags>
        <tag>书籍</tag>
        <tag>java</tag>
        <tag>java编程思想第四版</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java编程思想第四版第十三章读书笔记]]></title>
    <url>%2Fblog%2F2019%2F01%2F20%2Fjava%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E7%AC%AC%E5%9B%9B%E7%89%88%E7%AC%AC%E5%8D%81%E4%B8%89%E7%AB%A0%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[前言 最近一段时间重读了java编程思想，把一些东西重新理解记录一遍 目的 整理知识点，方便以后回顾，这一章主要讲解了java的字符串 正文 1.字符串 字符串的操作是计算机程序设计中最常见的行为。 关键词： StringBuilder ，StringBuffer，toString()，format转换，正则表达式 2.不可变String String对象时不可变的。每当把String对象作为方法的参数时，都会复制一份引用。（其实就是对函数中参数列表中参数的操作不会影响外面的原参数） 3.重载“+”与StringBuilder 用于String的“+”与“+=”是Java中仅有的两个重载过的操作符，而Java并不允许程序员重载任何操作符。 在使用&quot;+&quot;操作符时，编译器自动引入了java.lang.StringBuilder类，避免了连加情况下产生大量需要回收的垃圾（每+一次就会产生一个新的字符串）。 因此，当为一个类编写toString()方法时，如果字符串操作简单，可以信赖编译器，它会为你合理的构造最终字符串结果。但是如果要在toString()中使用循环，那么最好自己创建一个StringBuilder对象，结合append()用它来构造最终结果。 StringBuilder提供了丰富而全面的方法，包括insert()、replace()、subString()甚至reverse()，但最常用的还是append()和toString()，delete()方法。 StringBuilder是Java SE5引入的，在这之前还有Java的StringBuffer。StringBuffer是线程安全的，因此开销会大一些。StringBuilder字符串操作会更快一些。 4.无意识的递归 如果希望toString()方法打印出对象的内存地址，不可以使用this关键字。如果这样写 123public String toString() &#123;return &quot; InfiniteRecursion address: &quot; + this + &quot;\n&quot;;&#125; 编译器会试图将&quot;+&quot;后面的this转换为String，此时调用toString()函数，导致无穷递归。因此如果想要打印出内存地址，应该调用Object.toString()方法，所以调用super.toString()就可以了 123public String toString() &#123;return &quot; InfiniteRecursion address: &quot; + super.toString() + &quot;\n&quot;;&#125; 结果是： 1234567891011[ E02_RepairInfinite address: E02_RepairInfinite@3e25a5, E02_RepairInfinite address: E02_RepairInfinite@19821f, E02_RepairInfinite address: E02_RepairInfinite@addbf1, E02_RepairInfinite address: E02_RepairInfinite@42e816, E02_RepairInfinite address: E02_RepairInfinite@9304b1, E02_RepairInfinite address: E02_RepairInfinite@190d11, E02_RepairInfinite address: E02_RepairInfinite@a90653, E02_RepairInfinite address: E02_RepairInfinite@de6ced, E02_RepairInfinite address: E02_RepairInfinite@c17164, E02_RepairInfinite address: E02_RepairInfinite@1fb8ee3] 5.String上的操作 String的一些基本方法: 一、构造函数 1234String(byte[ ] bytes)：通过byte数组构造字符串对象。String(char[ ] value)：通过char数组构造字符串对象。String(Sting original)：构造一个original的副本。即：拷贝一个original。String(StringBuffer buffer)：通过StringBuffer数组构造字符串对象。 二、方法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151. char charAt(int index) ：取字符串中的某一个字符，其中的参数index指的是字符串中序数。字符串的序数从0开始到length()-1 。 例如： String s = new String(&quot;abcdefghijklmnopqrstuvwxyz&quot;); System.out.println(&quot;s.charAt(5): &quot; + s.charAt(5) ); 结果为： s.charAt(5): f2. int compareTo(String anotherString) ：当前String对象与anotherString比较。相等关系返回０；不相等时，从两个字符串第0个字符开始比较，返回第一个不相等的字符差，另一种情况，较长字符串的前面部分恰巧是较短的字符串，返回它们的长度差。3. int compareTo(Object o) ：如果o是String对象，和2的功能一样；否则抛出ClassCastException异常。 例如: String s1 = new String(&quot;abcdefghijklmn&quot;); String s2 = new String(&quot;abcdefghij&quot;); String s3 = new String(&quot;abcdefghijalmn&quot;); System.out.println(&quot;s1.compareTo(s2): &quot; + s1.compareTo(s2) ); //返回长度差 System.out.println(&quot;s1.compareTo(s3): &quot; + s1.compareTo(s3) ); //返回&apos;k&apos;-&apos;a&apos;的差 结果为：s1.compareTo(s2): 4 s1.compareTo(s3): 104. String concat(String str) ：将该String对象与str连接在一起。5. boolean contentEquals(StringBuffer sb) ：将该String对象与StringBuffer对象sb进行比较。6. static String copyValueOf(char[] data) ：7. static String copyValueOf(char[] data, int offset, int count) ：这两个方法将char数组转换成String，与其中一个构造函数类似。8. boolean endsWith(String suffix) ：该String对象是否以suffix结尾。 例如： String s1 = new String(&quot;abcdefghij&quot;); String s2 = new String(&quot;ghij&quot;); System.out.println(&quot;s1.endsWith(s2): &quot; + s1.endsWith(s2) ); 结果为：s1.endsWith(s2): true9. boolean equals(Object anObject) ：当anObject不为空并且与当前String对象一样，返回true；否则，返回false。10. byte[] getBytes() ：将该String对象转换成byte数组。11. void getChars(int srcBegin, int srcEnd, char[] dst, int dstBegin) ：该方法将字符串拷贝到字符数组中。其中，srcBegin为拷贝的起始位置、srcEnd为拷贝的结束位置、字符串数值dst为目标字符数组、dstBegin为目标字符数组的拷贝起始位置。 例如： char[] s1 = &#123;&apos;I&apos;,&apos; &apos;,&apos;l&apos;,&apos;o&apos;,&apos;v&apos;,&apos;e&apos;,&apos; &apos;,&apos;h&apos;,&apos;e&apos;,&apos;r&apos;,&apos;!&apos;&#125;;//s1=I love her! String s2 = new String(&quot;you!&quot;); s2.getChars(0,3,s1,7); //s1=I love you! System.out.println( s1 ); 结果为：I love you!12. int hashCode() ：返回当前字符的哈希表码。13. int indexOf(int ch) ：只找第一个匹配字符位置。14. int indexOf(int ch, int fromIndex) ：从fromIndex开始找第一个匹配字符位置。15. int indexOf(String str) ：只找第一个匹配字符串位置。16. int indexOf(String str, int fromIndex) ：从fromIndex开始找第一个匹配字符串位置。 例如： String s = new String(&quot;write once, run anywhere!&quot;); String ss = new String(&quot;run&quot;); System.out.println(&quot;s.indexOf(&apos;r&apos;): &quot; + s.indexOf(&apos;r&apos;) ); System.out.println(&quot;s.indexOf(&apos;r&apos;,2): &quot; + s.indexOf(&apos;r&apos;,2) ); System.out.println(&quot;s.indexOf(ss): &quot; + s.indexOf(ss) ); 结果为：s.indexOf(&apos;r&apos;): 1 s.indexOf(&apos;r&apos;,2): 12 s.indexOf(ss): 1217. int lastIndexOf(int ch)18. int lastIndexOf(int ch, int fromIndex)19. int lastIndexOf(String str)20. int lastIndexOf(String str, int fromIndex) 以上四个方法与13、14、15、16类似，不同的是：找最后一个匹配的内容。 public class CompareToDemo &#123; public static void main (String[] args) &#123; String s1 = new String(&quot;acbdebfg&quot;); System.out.println(s1.lastIndexOf((int)&apos;b&apos;,7)); &#125; &#125; 运行结果：5（其中fromIndex的参数为 7，是从字符串acbdebfg的最后一个字符g开始往前数的位数。既是从字符c开始匹配，寻找最后一个匹配b的位置。所以结果为 5）21. int length() ：返回当前字符串长度。22. String replace(char oldChar, char newChar) ：将字符号串中第一个oldChar替换成newChar。23. boolean startsWith(String prefix) ：该String对象是否以prefix开始。24. boolean startsWith(String prefix, int toffset) ：该String对象从toffset位置算起，是否以prefix开始。 例如：String s = new String(&quot;write once, run anywhere!&quot;); String ss = new String(&quot;write&quot;); String sss = new String(&quot;once&quot;); System.out.println(&quot;s.startsWith(ss): &quot; + s.startsWith(ss) ); System.out.println(&quot;s.startsWith(sss,6): &quot; + s.startsWith(sss,6) ); 结果为：s.startsWith(ss): true s.startsWith(sss,6): true25. String substring(int beginIndex) ：取从beginIndex位置开始到结束的子字符串。26.String substring(int beginIndex, int endIndex) ：取从beginIndex位置开始到endIndex位置的子字符串。27. char[ ] toCharArray() ：将该String对象转换成char数组。28. String toLowerCase() ：将字符串转换成小写。29. String toUpperCase() ：将字符串转换成大写。 例如：String s = new String(&quot;java.lang.Class String&quot;); System.out.println(&quot;s.toUpperCase(): &quot; + s.toUpperCase() ); System.out.println(&quot;s.toLowerCase(): &quot; + s.toLowerCase() ); 结果为：s.toUpperCase(): JAVA.LANG.CLASS STRING s.toLowerCase(): java.lang.class string30. static String valueOf(boolean b)31. static String valueOf(char c)32. static String valueOf(char[] data)33. static String valueOf(char[] data, int offset, int count)34. static String valueOf(double d)35. static String valueOf(float f)36. static String valueOf(int i)37. static String valueOf(long l)38. static String valueOf(Object obj)以上方法用于将各种不同类型转换成Java字符型。这些都是类方法。下面挑选一些上面常用的方法：Java中String类的常用方法:public char charAt(int index)返回字符串中第index个字符；public int length()返回字符串的长度；public int indexOf(String str)返回字符串中第一次出现str的位置；public int indexOf(String str,int fromIndex)返回字符串从fromIndex开始第一次出现str的位置；public boolean equalsIgnoreCase(String another)比较字符串与another是否一样（忽略大小写）；public String replace(char oldchar,char newChar)在字符串中用newChar字符替换oldChar字符public boolean startsWith(String prefix)判断字符串是否以prefix字符串开头；public boolean endsWith(String suffix)判断一个字符串是否以suffix字符串结尾；public String toUpperCase()返回一个字符串为该字符串的大写形式；public String toLowerCase()返回一个字符串为该字符串的小写形式public String substring(int beginIndex)返回该字符串从beginIndex开始到结尾的子字符串；public String substring(int beginIndex,int endIndex)返回该字符串从beginIndex开始到endsIndex结尾的子字符串public String trim()返回该字符串去掉开头和结尾空格后的字符串public String[] split(String regex)将一个字符串按照指定的分隔符分隔，返回分隔后的字符串数组 6.格式化的输出 Java SE5推出了格式化输出这一功能。如下： printf() printf()并不是用重载的“+”操作符来连接引号内的字符串，而是使用特殊的占位符来表示数据将来的位置。而且它还将插入格式化字符串的参数，以逗号分隔，排成一行。 1printf(&quot;Row 1: [%d %f]\n&quot;, x, y); 这些占位符称作格式修饰符，它不但说明了插入位置，还说明了插入说明类型的变量，%d表示整数，%f表示浮点数，%s表示字符串。 System.out.format() Java SE5引入的format方法可用于PrintStream或者PrintWriter对象。其中也包括System.out对象。 format()方法模仿自C的printf()，两者是等价的，以下展示三种方法输出坐标点： 123456789101112131415public class SimpleFormat &#123;public static void main(String[] args) &#123;int x = 5;double y = 5.332542;// The old way:System.out.println("Row 1: [" + x + " " + y + "]");// The new way:System.out.format("Row 1: [%d %f]\n", x, y);// orSystem.out.printf("Row 1: [%d %f]\n", x, y);&#125;&#125; /* Output:Row 1: [5 5.332542]Row 1: [5 5.332542]Row 1: [5 5.332542] Formatter类 在Java中，所有新的格式化功能都有java.util.Formatter处理。Formatter构造器经过重载可以接受多种输出目的地，最常用的还是PrintStream()\OutputStream和File。 12345678910111213141516171819202122232425262728293031import java.io.*;import java.util.*;public class Turtle &#123;private String name;private Formatter f;public Turtle(String name, Formatter f) &#123;this.name = name;this.f = f;&#125;public void move(int x, int y) &#123;f.format("%s The Turtle is at (%d,%d)\n", name, x, y);&#125;public static void main(String[] args) &#123;PrintStream outAlias = System.out;Turtle tommy = new Turtle("Tommy",new Formatter(System.out));Turtle terry = new Turtle("Terry",new Formatter(outAlias));tommy.move(0,0);terry.move(4,8);tommy.move(3,4);terry.move(2,5);tommy.move(3,3);terry.move(3,3);&#125;&#125; /* Output:Tommy The Turtle is at (0,0)Terry The Turtle is at (4,8)Tommy The Turtle is at (3,4)Terry The Turtle is at (2,5)Tommy The Turtle is at (3,3) tommy输出到System.out中，terry输出到System.out的一个别名中 格式化说明符 为了在插入数据是控制空格和对齐，需要更加精细的格式修饰符。格式如下： 1[argument_index$][flags][width][.precision]conversion flags表示左右对齐，默认是右对齐，如果想左对齐就使用“-”标志 with控制最小尺寸（宽度）至少该这么长，不够用空格替代。 在with后面加上&quot;.&quot;后面表示精度precision。 用于String（%s）时，表示最多可写的字符数 用于浮点数（%f）表示小数点后面的位数，多了舍入，少了补0，默认是6位 用于整数（%d）时,不可用于整数，会触发异常 123456789101112131415161718192021222324252627282930313233343536import java.util.*;public class Receipt &#123;private double total = 0;private Formatter f = new Formatter(System.out);public void printTitle() &#123;f.format("%-15s %5s %10s\n", "Item", "Qty", "Price"); //Item项都有“-”，表示左对齐，其余项都是右对齐f.format("%-15s %5s %10s\n", "----", "---", "-----");&#125;public void print(String name, int qty, double price) &#123;f.format("%-15.15s %5d %10.2f\n", name, qty, price); //name是左对齐并且最多15个字符，包括空格。price最多小数点后两位。total += price;&#125;public void printTotal() &#123;f.format("%-15s %5s %10.2f\n", "Tax", "", total*0.06);f.format("%-15s %5s %10s\n", "", "", "-----");f.format("%-15s %5s %10.2f\n", "Total", "",total * 1.06);&#125;public static void main(String[] args) &#123;Receipt receipt = new Receipt();receipt.printTitle();receipt.print("Jack’s Magic Beans", 4, 4.25);receipt.print("Princess Peas", 3, 5.1);receipt.print("Three Bears Porridge", 1, 14.29);receipt.printTotal();&#125;&#125; /* Output:Item Qty Price---- --- -----Jack’s Magic Be 4 4.25Princess Peas 3 5.10Three Bears Por 1 14.29Tax 1.42-----Total 25.06 Formatter转换 常用的类型转换： d 整型 (十进制) c Unicode字符 b Boolean sString f 浮点型 (十进制) e 浮点型(科学计数) x 整数 (十六进制) h 散列码(十六进制) % 字符&quot;%&quot; 实例： 1234Formatter f = new Formatter(System.out);char u = ‘a’;f.format(&quot;c: %c\n&quot;, u);f.format(&quot;b: %b\n&quot;, u); 所有类型变量都可以执行b转换，除了Boolean类型对应相应的true/false，其它的只要参数不为Null，结果永远是true。（参数为数字0，仍然是true，这点与C不同） String.format() String.format()是一个static方法，它接受与Formatter.format()方法一样的参数，但返回一个String对象。 如下所示： 1String.format(&quot;(t%d, q%d) %s&quot;, transactionID,queryID, message) 7.正则表达式 正则表达式是一个强大而灵活的文本处理工具。它提供可一种完全通用的方式，能够解决各种字符串处理相关的问题：匹配、选择、编辑和验证。 正则可以切分，替换，判断字符串，通过设定的regex规则。 在Java中，\的意思是“我要插入一个正则表达式的反斜线，所以其后字符含有特殊意义” 12345678910\\d 表示一位数字\\W 表示非单词字符\\w 表示单词字符\\\\ 表示普通反斜线\n 换行符\t 制表符+ 一个或多个前一位的表达式| 或者? 可能有\\+ 正号（加号在正则表达式中有特殊的意义，必须用\\将其转译为一个普通字符） 123456789101112public class IntegerMatch &#123;public static void main(String[] args) &#123;System.out.println("-1234".matches("-?\\d+")); //可能以负号开头且后面跟着数字们System.out.println("5678".matches("-?\\d+")); System.out.println("+911".matches("-?\\d+"));System.out.println("+911".matches("(-|\\+)?\\d+")); //可能以正负号开头且后面跟着数字们&#125;&#125; /* Output:truetruefalsetrue split()方法目标是“将字符串从正则表达式匹配的地方切开” 1234567891011121314151617181920212223//: strings/Splitting.javaimport java.util.*;public class Splitting &#123;public static String knights ="Then, when you have found the shrubbery, you must " +"cut down the mightiest tree in the forest... " +"with... a herring!";public static void split(String regex) &#123;System.out.println(Arrays.toString(knights.split(regex)));&#125;public static void main(String[] args) &#123;split(" "); // 从有空格处分开 split("\\W+"); // 从有非单词字符处分开split("n\\W+"); // 从“字符n后面跟了非单词字符”处分开&#125;&#125; /* Output:[Then,, when, you, have, found, the, shrubbery,, you, must, cut, down,the, mightiest, tree, in, the, forest..., with..., a, herring!][Then, when, you, have, found, the, shrubbery, you, must, cut, down,the, mightiest, tree, in, the, forest, with, a, herring][The, whe, you have found the shrubbery, you must cut dow, the mightiesttree i, the forest... with... a herring!] String.split()还有个重载版本，允许限制字符串分隔次数。 String类自带“替换”正则表达式 123456789101112import static net.mindview.util.Print.*;public class Replacing &#123;static String s = Splitting.knights;public static void main(String[] args) &#123;print(s.replaceFirst("f\\w+", "located")); //以f开头的单词换成Locatedprint(s.replaceAll("shrubbery|tree|herring","banana")); //这几个单词的位置换成banana&#125;&#125; /* Output:Then, when you have located the shrubbery, you must cut down themightiest tree in the forest... with... a herring!Then, when you have found the banana, you must cut down the mightiestbanana in the forest... with... a banana! 创建正则表达式 B字符B 1234567\xhh十六进制值为oxhh的字符\uhhhh十六进制表示为0xhhhh的Unicode字符\t制表符\n换行符\r回车符\f转页符\e转义符 字符类： 123456789101112. 任意字符[abc] 包含a、b、c的任何字符[^abc] 除了a、b、c的任何字符[a-zA-Z] 从a-z或者A-Z的所有字符[abc[hij]] 包含a、b、c、h、i、j的所有字符[a-z&amp;&amp;[hij]] 包含h、i、j（交集）\s 空白符（空格、tab、换行、换页、回车）\S 非空白符\d 数字[0-9]\D 非数字[^o-9]\w 词字符[a-zA-Z_0-9]\W 非词字符[^\w] 逻辑操作符： 123XY X后面有YX|Y X或Y(X) 捕获组。可以在表达式中用\i引用第i个捕获组 边界匹配符： 12345^一行的开始$ 一行的结束\b 单词的边界\B 非单词的边界\G 前一个匹配的结束 量词 量词描述一个模式吸收输入文本的方式： 贪婪型： 贪婪表达式会为所有可能的模式发现尽可能多的匹配。 勉强型： 用问号来指定，这个词量匹配满足模式所需的最少字符数。 占有型： Java特有。当正则表达式被用于字符串时，它会产生相当多的状态，以便在匹配失败时可以回溯。而“占有的”词量并不保存这些中间状态，因此它们可以防止回溯。 贪婪型 勉强型 占有型 如何匹配 X? X?? X?+ 一个或0个X X* X*? x*+ 0个或者多个X x+ x+? X++ 一个或者多个X X{n} X{n}? X{n}+ 恰好n次X X{n,} X{n,}? X{n,}+ 至少n次X X{n,m} X{n,m}? X{n,m}+ X至少n次，且不超过m次 接口CharSequence从CharBuffer、String、StringBuffer、StringBuilder类中抽象出字符序列的一般化定义 123456interface CharSequence &#123;charAt(int i);length();subSequence(int start,int end);toString();&#125; 这些类都实现了该接口 Parttern和Matcher Parttern对象表示编译后的正则表达式。 1、导入java.util.regex包 2、用static Parttern.compile()方法来编译正则表达式。 3、使用已编译的Parttern对象上的matcher()方法，加上一个输入字符串，从而共同构造一个Matcher对象。它有很多功能可用。 1234567891011121314151617181920212223242526272829303132333435//&#123;Args: abcabcabcdefabc "abc+" "(abc)+" "(abc)&#123;2,&#125;" &#125;import java.util.regex.*;import static net.mindview.util.Print.*;public class TestRegularExpression &#123;public static void main(String[] args) &#123;if(args.length &lt; 2) &#123;print("Usage:\njava TestRegularExpression " +"characterSequence regularExpression+");System.exit(0);&#125;print("Input: \"" + args[0] + "\"");for(String arg : args) &#123;print("Regular expression: \"" + arg + "\"");Pattern p = Pattern.compile(arg);Matcher m = p.matcher(args[0]);while(m.find()) &#123;print("Match \"" + m.group() + "\" at positions " +m.start() + "-" + (m.end() - 1));&#125;&#125;&#125;&#125; /* Output:Input: "abcabcabcdefabc"Regular expression: "abcabcabcdefabc"Match "abcabcabcdefabc" at positions 0-14Regular expression: "abc+"Match "abc" at positions 0-2Match "abc" at positions 3-5Match "abc" at positions 6-8Match "abc" at positions 12-14Regular expression: "(abc)+"Match "abcabcabc" at positions 0-8Match "abc" at positions 12-14Regular expression: "(abc)&#123;2,&#125;"Match "abcabcabc" at positions 0-8 使用Matcher上的方法，我们能够判断各种不同类型的匹配是否成功： 1234boolean matches()判断整个输入字符串是否匹配正则表达式，只有整个输入都匹配正则表达式时才会trueboolean lookingAt() 判断字符串的开始部分是否能匹配模式，只有输入的第一部分匹配才会trueboolean find() 在CharSequence中按照正则表达式查找多个匹配boolean find(int start) 在指定位置查找多个匹配 1234567891011121314151617181920import java.util.regex.*;import static net.mindview.util.Print.*;public class Finding &#123;public static void main(String[] args) &#123;Matcher m = Pattern.compile("\\w+") //模式\\w+将字符串划分为单词.matcher("Evening is full of the linnet’s wings");while(m.find())printnb(m.group() + " ");print();int i = 0;while(m.find(i)) &#123;printnb(m.group() + " ");i++;&#125;&#125;&#125; /* Output:Evening is full of the linnet s wingsEvening vening ening ning ing ng g is is s full full ull ll l of of fthe the he e linnet linnet innet nnet net et t s s wings wings ings ngsgs s 组 组是用括号划分的正则表达式，组号为0表示整个正则表达式，组号为1表示第一队括号()括起的组，依次类推。 Matcher对象提供了一系列方法 12345public int groupCount() 返回该匹配器的模式中的分组数目,不包括第0组public String group() 返回前一次匹配操作的第0组public String group(int i) 返回前一次匹配操作指定的组号，如果匹配成功，但是指定的组没有匹配输入字符串的任何部分，则将返回null。public int start(int group) 返回前一次匹配操作中寻找到的组的起始索引public int end(int group) 返回前一次匹配操作中寻找到的组的最后一个字符索引+1的值 Pattern标记 Pattern类的compile()方法还有另一个版本，它接受一个标记参数，以调整匹配的行为。 Pattern Pattern.compile(String regex, int flag) flag来自Pattern类中的常量，常用的有Pattern.CASE_INSENSITIVE,Pattern.MULTILINE, 以及 Pattern.COMMENTS split() spilit()方法将输入字符断开成字符串对象数组，断开边界由正则表达式确定。默认情况下是遇到空格切分的 12String[] split(CharSequence input) //通过正则表达式分隔inputString[] split(CharSequence input, int limit) //通过正则表达式分隔input，分隔成limit个 12345678910111213141516import java.util.regex.*;import java.util.*;import static net.mindview.util.Print.*;public class SplitDemo &#123;public static void main(String[] args) &#123;String input ="This!!unusual use!!of exclamation!!points";print(Arrays.toString(Pattern.compile("!!").split(input)));// Only do the first three:print(Arrays.toString(Pattern.compile("!!").split(input, 3)));&#125;&#125; /* Output:[This, unusual use, of exclamation, points][This, unusual use, of exclamation!!points] 替换操作 1234replaceFirst(String replacement) 用于替换第一个匹配成功的部分为字符串replacementreplaceAll(String replacement) 将匹配成功的所有部分替换为字符串replacementappendReplacement(StringBuffer sbuf,String replacement)执行渐进式替换appendTail(StringBuffer sbuf,String replacement)输入字符串余下部分复制到sbuf中 reset() public Matcher reset()； //这个方法将Matcher重置为最初的状态 正则表达式与Java I/O 可以讲正则表达式用于动态字符串，应有两个参数： 文件名和要匹配的正则表达式。 输出：匹配的部分和该部分所在行。 12345678910111213141516171819202122232425262728293031323334353637383940//: strings/JGrep.java// A very simple version of the "grep" program.// &#123;Args: JGrep.java "\\b[Ssct]\\w+"&#125;import java.util.regex.*;import net.mindview.util.*;public class JGrep &#123;public static void main(String[] args) throws Exception &#123;if(args.length &lt; 2) &#123;System.out.println("Usage: java JGrep file regex");System.exit(0);&#125;Pattern p = Pattern.compile(args[1]);// Iterate through the lines of the input file:int index = 0;Matcher m = p.matcher("");for(String line : new TextFile(args[0])) &#123;m.reset(line); //没有在循环里创建Matcher，性能提升while(m.find())System.out.println(index++ + ": " +m.group() + ": " + m.start());&#125;&#125;&#125; /* Output: (Sample)0: strings: 41: simple: 102: the: 283: Ssct: 264: class: 75: static: 96: String: 267: throws: 418: System: 69: System: 610: compile: 2411: through: 1512: the: 2313: the: 3614: String: 815: System: 816: start: 31 8.扫描输入 input元素使用类来自java.io。 ReadLine()方法将一行输入转为String对象。 Java SE5新增了Scanner类（java.util.*），可以接受任何类型的输入对象，包括File对象，InputStream、String或者Readable对象。Readable时Java SE5新增的一个接口，具有read()方法。 使用Scanner，所有输入，粉刺，翻译的操作都隐藏在不同类型的next()中，比如nextInt()、nextDouble()，普通的next()方法方法返回下一个String。 所有基本类型都有next()方法，除了char类型，包括BigDecimal和BigInteger。 Scanner还有相应的hasNext方法，用以判断下一个输入分词是否是所需的类型。 Scanner可以自动吞IOException异常。 Scanner定界符 默认情况下，Scanner根据空白字符对输入进行分词，也可以用正则表达式指定定界符，利用函数scanner.useDelimiter(正则表达式) 1234567891011121314import java.util.*;public class ScannerDelimiter &#123;public static void main(String[] args) &#123;Scanner scanner = new Scanner("12, 42, 78, 99, 42");scanner.useDelimiter("\\s*,\\s*"); //,作为定界符，包括逗号前后的空格符while(scanner.hasNextInt())System.out.println(scanner.nextInt());&#125;&#125; /* Output:1242789942 用正则表达式扫描 除了能够扫描基本类型外，可能还想要扫描自定义的正则表达式。 1234567891011121314151617181920212223242526272829//: strings/ThreatAnalyzer.javaimport java.util.regex.*;import java.util.*;public class ThreatAnalyzer &#123;static String threatData ="58.27.82.161@02/10/2005\n" +"204.45.234.40@02/11/2005\n" +"58.27.82.161@02/11/2005\n" +"58.27.82.161@02/12/2005\n" +"58.27.82.161@02/12/2005\n" +"[Next log section with different data format]";public static void main(String[] args) &#123;Scanner scanner = new Scanner(threatData);String pattern = "(\\d+[.]\\d+[.]\\d+[.]\\d+)@" +"(\\d&#123;2&#125;/\\d&#123;2&#125;/\\d&#123;4&#125;)";while(scanner.hasNext(pattern)) &#123;scanner.next(pattern);MatchResult match = scanner.match();String ip = match.group(1);String date = match.group(2);System.out.format("Threat on %s from %s\n", date,ip);&#125;&#125;&#125; /* Output:Threat on 02/10/2005 from 58.27.82.161Threat on 02/11/2005 from 204.45.234.40Threat on 02/11/2005 from 58.27.82.161Threat on 02/12/2005 from 58.27.82.161Threat on 02/12/2005 from 58.27.82.161 配合正则表达式扫描时，只针对下一个输入分词，如果正则表达式中含有定界符，则永远不可能匹配成功 9.StringTokenizer 以前用StringTokenizer来分词，现在基本上已经废弃不用了。 参考资料 https://blog.csdn.net/severusyue/article/details/51784228 severusyue]]></content>
      <categories>
        <category>书籍</category>
        <category>java</category>
        <category>java编程思想第四版</category>
      </categories>
      <tags>
        <tag>书籍</tag>
        <tag>java</tag>
        <tag>java编程思想第四版</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java编程思想第四版第十二章读书笔记]]></title>
    <url>%2Fblog%2F2019%2F01%2F20%2Fjava%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E7%AC%AC%E5%9B%9B%E7%89%88%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AB%A0%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[前言 最近一段时间重读了java编程思想，把一些东西重新理解记录一遍 目的 整理知识点，方便以后回顾，这一章主要讲解了java的通过异常处理错误 正文 1.通过异常处理错误 Java的基本理念是“结构不佳的代码不能运行”。 Java中异常处理的目的在于通过使用少于目前数量的代码来简化大型、可靠的程序的生成，并且通过这种方式可以使程序员增加自信 2.概念 因为异常机制将保证能够捕获这个错误，所以不用小心翼翼的各种去检查。而处理错误只需要在一个地方完成，那就是 异常处理程序。 只需要在异常处理程序中处理错误。 3.基本异常 异常情形是指阻止当前方法或作用域继续执行的问题。 异常处理程序将程序从错误状态中恢复，以使程序要么换一种方式运行，要么继续运行下去。 在没有其它办法的情况下，异常允许我们强制程序停止运行，并告诉我们出现了什么问题。理想状态下，还可以强制程序处理问题，并返回到稳定状态的。 异常参数： 用new在堆上创建异常对象，所有标准异常类都有两个构造器，一个默认的，一个带参的。 能够抛出任意类型的Throwable对象，它是异常类型的根类。 4.捕获异常 监控区域是一个可能产生异常的代码，并且后面跟着处理这些异常的代码。 如果在方法内部抛出了异常，那么这个方法就此结束。如果不希望这个方法结束，那么可以在方法内设置一个特殊的块来捕获异常，即try块。为什么叫try呢，因为在这个块里“尝试”各种可能产生异常的方法进行调用，所以是try。 123456789try &#123;// Code that might generate exceptions&#125; catch(Type1 id1)|&#123;// Handle exceptions of Type1&#125; catch(Type2 id2) &#123;// Handle exceptions of Type2&#125; catch(Type3 id3) &#123;// Handle exceptions of Type3&#125; 异常抛出后，异常处理机制将搜索参数与异常类型相匹配的第一个处理程序，进入catch语句处理，此时认为异常的到了处理。catch子句结束，则处理程序不再往下找匹配了。 终止与恢复： 异常处理理论上有两种基本模型，java支持终止模型。该模型假设错误非常关键，一旦异常被抛出，那么错误已经无可挽回，程序不能继续执行。 另一种模型是恢复模型，就是先修正错误，然后重新进入该方法。这个模型假定了修正完之后再进入执行一定会成功。 相比较终止模型还是比较占优的，因为恢复模型需要了解异常抛出的地点，麻烦。 5.创建自定义异常 可以异常类不写构造函数，使用默认无参构造函数，也可以写构造函数。酱紫可以实现在抛出的异常后面打印出异常所在函数等功能。比如： 1234class MyException extends Exception &#123; public MyException() &#123;&#125; public MyException(String msg) &#123; super(msg); &#125; &#125; 在抛出异常时 1234public static void g() throws MyException &#123; System.out.println(&quot;Throwing MyException from g()&quot;); throw new MyException(&quot;Originated in g()&quot;); &#125; 那么，在打印的时候，就可以打印出 1MyException: Originated in g() 在异常处理程序中，调用Throwable类的printStackTrace()方法，那么“从异常方法调用处直到异常抛出处”的方法调用序列将被打印出来 123MyException at FullConstructors.f(FullConstructors.java:11) at FullConstructors.main(FullConstructors.java:19) printStackTrace()方法可以带参数，比如printStackTrace(System.out)，这样打印出来的信息将被发送到System.out，如果该方法不带参，那么信息将被输出到标准错误流 异常与记录日志 使用java.util.logging工具将输出记录到日志中 当然，不能指望每个程序员把记录日志的程序的基础设施都构建在异常里，所以更常见的情形是需要捕获和记录他人编写的异常，因此需要在异常处理程序中生成日志消息 我们甚至可以进一步定义异常，比如加入额外的构造器和成员，然而一般来说并不会用上这些功能 TODO: 现在都用的slf4j集成log4j来记录日志的，这里分享一下好用的日志框架集成方法 6.异常说明 异常说明使用了关键字 throws，后面接一个潜在的异常类型列表。 void f() throws TooBig, TooSmall, DivZero { //… 这种在编译时被强制检查的异常称为被检查的异常。 也可以声明方法将抛出异常，但是实际上却不抛出。这样做可以先为异常占个位置，以后可以抛出这类异常而不用修改已有方法，这种“作弊”方法通常用在你定义抽象基类和接口时，这样派生类或者接口实现就能抛出这些预先声明的异常。 7.捕获所有异常 捕获异常类型的基类Exception（还有其它基类），这可以保证异常一定会被捕获，最好把它放到异常处理程序列表的末尾 123456catch(Exception e) &#123;System.out.println(&quot;Caught an exception&quot;);&#125;Exception可以调用其从基类继承的方法：String getMessage( )String getLocalizedMessage( ) 获取详细信息（抛出异常对象所带的参数），或者用本地语言表示的详细信息。 栈轨迹： printStackTrace()方法所提供的信息可以通过getStackTrace()方法来直接访问，该方法返回一个由栈轨迹元素所构成的数组，每个元素表示栈中的一帧，元素0也是栈顶元素，是最后调用的方法（Throwable被创建和抛出之处），最后一个元素是栈底，是调用序列的第一个方法调用。 重新抛出异常 挡在异常处理模块里继续抛出异常，那么printStackTrace()方法显示的将是原来异常抛出点的调用栈信息，而非重新抛出点的的信息。 此时可以使用fillinStackTrace()方法 1234catch(Exception e) &#123;System.out.println(&quot;An exception was thrown&quot;);throw (Exception)e.fillInStackTrace();&#125; 调用fillInStackTrace()的这一行就成为异常的新发生地了。 在异常捕获之后抛出另一种异常，其效果类似于fillInStackTrace() 异常链 在捕获一个异常后抛出另一个异常，并希望把原始异常的信息保存下来，这被称为异常链。 Throwable的子类可以在构造器中接受一个case对象作为参数。这个case参数表示原始异常，这样通过把原始异常传递给新的异常。 Throwable子类，只有三种基本异常提供了带case参数的构造器，它们是Error(用于Java虚拟机报告系统错误)、Exception以及RuntimeException。 8.Java标准异常 Throwable对象可分为两种类型（指从Throwable继承而得到的类型）：Error用来表示编译时和系统错误，Exception是可以被抛出的基本类型，包括Java类库，用户方法以及运行时故障都可以抛出此异常。 Error一般不用自己关心，来讲Exception: 特例RuntimeException 比如nullPointerException，空指针异常。 运行时产生的异常，不需要在异常说明中声明方法将抛出RuntimeException类型的异常。它们被称为“不受检查的异常”。这种异常属于错误，会被自动捕获，而不用程序员自己写代码捕获。 如果RuntimeException没有被捕获而直达main()，那么在程序退出前将调用异常的printStackTrace()方法。 9.使用finally进行清理 在异常处理程序后面加上finamlly子句，可保证无论try块里的异常是否抛出，都能执行。（通常适用于内存回收之外的情况） finally执行未必要放在最后，正常的顺序执行到它就是它了 12345678910111213141516171819202122232425import static net.mindview.util.Print.*;class FourException extends Exception &#123;&#125;public class AlwaysFinally &#123;public static void main(String[] args) &#123;print("Entering first try block");try &#123;print("Entering second try block");try &#123;throw new FourException();&#125; finally &#123;print("finally in 2nd try block");&#125;&#125; catch(FourException e) &#123;System.out.println("Caught FourException in 1st try block");&#125; finally &#123;System.out.println("finally in 1st try block");&#125;&#125;&#125; /* Output:Entering first try blockEntering second try blockfinally in 2nd try blockCaught FourException in 1st try blockfinally in 1st try block 当涉及break和continue时，finally子句也会得到执行。 如果把finally子句和带标签的break以及continue配合使用，在java里没必要使用goto语句了。 有return语句时，finally依旧会执行。 异常丢失： 在一个异常还没得到处理的情况下，应该尽量避免抛出另一个异常。 1、使用finally可能导致一个异常还没处理，在接下来的finally字句中又抛出了一个异常，那么前一个异常就会丢失，外面的catch块捕捉到的就是finally抛出的异常而未察觉到最开始抛出的异常。 2、一种更简单的丢失异常的方式是在finally语句中直接return，这就更别说到catch块匹配异常了。 应该避免以上两种编程错误。 10.异常的限制 当覆盖 方法时，只能抛出在基类方法的异常说明里列出的那些异常或者不抛出，但是不能新增异常说明。这个限制意味着，当基类代码运用到派生类时，依旧有用 当处理派生类对象时，编译器只会强制要求捕获派生类该方法产生的异常。如果向上转型为基类，编译器会要求捕获基类方法产生的异常。很智能的。 异常说明本身并不属于方法类型的范畴中，因此不参与重载的判断。 基于特定方法的“异常说明的接口”不是变大了而是变小了，小于等于基类异常说明表——这恰好和类接口在继承时的情形相反 11.构造器 如果异常发生了，所有东西能正常清理吗？ 例如io操作的时候，文件没有正常的构造，在finally中却要file.close，所以一般在close中又加一层try catch 基本规则是:在创建需要清理的对象之后，立即进入一个try-finally块，不过新版jdk有新的语法了 12.异常的匹配 异常匹配并不要求与抛出的异常完全匹配，也可以匹配该异常的基类。 如果故意把基类异常放在前面，导致子类异常的catch子句永远得不到执行，编译器会报错。 13.其它可选方式 1、将异常传递给控制台，使用FileInputStream进行打开关闭操作，记录在一个文件中。 2、用RuntimeException来包装“被检查的异常”。 参考资料 https://blog.csdn.net/severusyue/article/details/51780879 Java编程思想第四版读书笔记——第十二章 通过异常处理错误 severusyue]]></content>
      <categories>
        <category>书籍</category>
        <category>java</category>
        <category>java编程思想第四版</category>
      </categories>
      <tags>
        <tag>书籍</tag>
        <tag>java</tag>
        <tag>java编程思想第四版</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java编程思想第四版第十一章读书笔记]]></title>
    <url>%2Fblog%2F2019%2F01%2F18%2Fjava%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E7%AC%AC%E5%9B%9B%E7%89%88%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[前言 最近一段时间重读了java编程思想，把一些东西重新理解记录一遍 目的 整理知识点，方便以后回顾，这一章主要讲解了java的持有对象 正文 1.持有对象 容器类的基本类型是List，Set，Queue，Map。这些对象类型也成为集合类 2.泛型和类型安全的容器 使用ArrayList相当简单：创建一个实例，用add()插入对象，get()访问对象， size()获取ArrayList中元素的个数 3.基本概念 Java容器类类库的用途是“保存对象”，并将其划分为两个不同的概念: Collection:一个独立元素的序列，这些元素都服从一条或多条规则。List必须按照插入的顺序保存元素，而Set不能有重复元素。Queue按照队列规则来确定对象产生的顺序 Map:一组成对的&quot;键值对&quot;对象，允许使用键值来查找值。映射表允许我们使用另一个对象查找某个对象，它也被称为“关联数组” 4.添加一组元素 下面介绍Collection类添加元素的实用方法： Arrays.asList()接受一个数组或者一个逗号分隔的元素列表（使用可变参数），将其转换为一个List对象。 12List&lt;Integer&gt; list = Arrays.asList(16, 17, 18, 19, 20); list.set(1, 99); Collection.addAll()方法运行起来很快，而且构建一个不包含元素的Collection，然后调用Collection.addAll()这种方式很方便，因此它是首选方式 123Collection&lt;Integer&gt; collection = new ArrayList&lt;Integer&gt;(Arrays.asList(1, 2, 3, 4, 5));Integer[] moreInts = &#123; 6, 7, 8, 9, 10 &#125;; collection.addAll(Arrays.asList(moreInts)); 而Collection.addAll()只能接受另一个Collection对象作为参数，不如Arrays.asList()和Collections.addAll()灵活，这两个方法采样的都是可变参数列表 1Collections.addAll(collection, 11, 12, 13, 14, 15); 可以直接使用Arrays.asList()的输出，将其当做List，但是这种情况下，其底层表示的是数组，不能调整其尺寸，所以不能add()或delete() 123456789101112131415161718192021222324252627 class Snow &#123;&#125; class Powder extends Snow &#123;&#125; class Light extends Powder &#123;&#125; class Heavy extends Powder &#123;&#125; class Crusty extends Snow &#123;&#125; class Slush extends Snow &#123;&#125; public class AsListInference &#123; public static void main(String[] args) &#123; List&lt;Snow&gt; snow1 = Arrays.asList( new Crusty(), new Slush(), new Powder()); // Won’t compile: // List&lt;Snow&gt; snow2 = Arrays.asList( // new Light(), new Heavy()); // Compiler says: // found : java.util.List&lt;Powder&gt; // required: java.util.List&lt;Snow&gt; // Collections.addAll() doesn’t get confused: List&lt;Snow&gt; snow3 = new ArrayList&lt;Snow&gt;(); Collections.addAll(snow3, new Light(), new Heavy()); &#125;&#125; 对于这种多重向上转型，必须显示类型参数说明。 5.容器的打印 可直接打印容器，它自带了打印函数 12345678910111213141516171819202122232425262728293031323334353637383940import java.util.*; import static net.mindview.util.Print.*; public class PrintingContainers &#123; static Collection fill(Collection&lt;String&gt; collection) &#123; collection.add("rat"); collection.add("cat"); collection.add("dog"); collection.add("dog"); return collection; &#125; static Map fill(Map&lt;String,String&gt; map) &#123; map.put("rat", "Fuzzy"); map.put("cat", "Rags"); map.put("dog", "Bosco"); map.put("dog", "Spot"); return map; &#125; public static void main(String[] args) &#123; print(fill(new ArrayList&lt;String&gt;())); print(fill(new LinkedList&lt;String&gt;())); print(fill(new HashSet&lt;String&gt;())); print(fill(new TreeSet&lt;String&gt;())); print(fill(new LinkedHashSet&lt;String&gt;())); print(fill(new HashMap&lt;String,String&gt;())); print(fill(new TreeMap&lt;String,String&gt;())); print(fill(new LinkedHashMap&lt;String,String&gt;())); &#125; &#125; /* Output: [rat, cat, dog, dog] [rat, cat, dog, dog] [dog, cat, rat] [cat, dog, rat] [rat, cat, dog] &#123;dog=Spot, cat=Rags, rat=Fuzzy&#125; &#123;cat=Rags, dog=Spot, rat=Fuzzy&#125; &#123;rat=Fuzzy, cat=Rags, dog=Spot&#125; 这两种主要类型的区别在于容器的每个“槽”保存的元素个数 Collection在每个槽中只能保存一个元素。此类容器包括：List，它以特定的顺序保存一组元素；Set，元素不能重复；Queue，一端插入对象，另一端移除对象。 Map在每个槽内保存两个对象，即键和与之相关联的值 Collection打印出来的内容用[ ]括住，Map打印出来的内容用{ }括住 HashMap提供了最快的查找技术，TreeMap按照比较结果升序保存键，LinkedHashMap则按照插入顺序保存键，同时还保留了HashMap的查询速度 6.List 两种类型的List: 基本的ArrayList，它长于随机访问元素，但是在List的中间插入和移除元素时较慢。 LinkedList，它提供了代价较低的在List中间进行的插入和删除操作，提供了优化的顺序访问。LinkedList在随机访问方面相对比较慢 List重要价值在于，它提供了一种可修改的序列。 indexOf()来发现对象在List中所处位置的索引编号。 从List中移除一个元素，都会涌到equals()方法，List的行为根据equals()的行为而有所变化。 优化是一个棘手的问题，最好的策略就是弃之不顾，知道你发现需要担心它。 subList()方法允许很容易的从较大的列表中创建一个片段，顺序并不影响containsAll()的判断结果。 retainAll()保留两List的交集。 removeAll()也是基于equals()方法的。 addAll()方法使得我们可以在初始List中插入新的列表，而不是仅仅只能用Collection的addAll()方法追加到表尾。 7.迭代器 对于List，add()是插入元素的方法之一，而get()是取出元素的方法之一。 迭代器（Iterator，一种设计模式）是一个对象，它的工作是遍历并选择序列中的对象，迭代器通常被称为轻量级对象，创建它们的代价小。 Java的Iterator只能单向移动，用来： 1234使用方法Iterator()要求容器返回一个Iterator。Iterator准备好返回序列的第一个元素。使用next()获得序列中的下一个元素。使用hasNext()检查序列中是否还有元素。使用remove()将迭代器新近返回的元素删除。 在remove()之前必须先调用next()。 Iterator 能够将遍历序列的操作与序列底层的结构分离。迭代器统一了对容器的访问方式。如下： 123456789101112131415161718192021222324252627import typeinfo.pets.*; import java.util.*; public class CrossContainerIteration &#123; public static void display(Iterator&lt;Pet&gt; it) &#123; while(it.hasNext()) &#123; Pet p = it.next(); System.out.print(p.id() + ":" + p + " "); &#125; System.out.println(); &#125; public static void main(String[] args) &#123; ArrayList&lt;Pet&gt; pets = Pets.arrayList(8); LinkedList&lt;Pet&gt; petsLL = new LinkedList&lt;Pet&gt;(pets); HashSet&lt;Pet&gt; petsHS = new HashSet&lt;Pet&gt;(pets); TreeSet&lt;Pet&gt; petsTS = new TreeSet&lt;Pet&gt;(pets); display(pets.iterator()); display(petsLL.iterator()); display(petsHS.iterator()); display(petsTS.iterator()); &#125; &#125; /* Output: 0:Rat 1:Manx 2:Cymric 3:Mutt 4:Pug 5:Cymric 6:Pug 7:Manx 0:Rat 1:Manx 2:Cymric 3:Mutt 4:Pug 5:Cymric 6:Pug 7:Manx 4:Pug 6:Pug 3:Mutt 1:Manx 5:Cymric 7:Manx 2:Cymric 0:Rat 5:Cymric 2:Cymric 7:Manx 1:Manx 3:Mutt 6:Pug 4:Pug 0:Rat ListIterator可以双向移动，并且可以使用set()方法替换它访问过的最后一个元素。 8.LinkedList LinkedList在执行某些操作时比ArrayList更高效，但是在随机访问操作方面却要逊色一些。 LinkedList还添加了可以作为栈，队列，双端队列的方法。可以使用它们的方法 9.stack “栈”通常是指“后进先出”（LIFO）的容器。 可以直接将LinkedList当做栈使用。如: 123456789101112package net.mindview.util; import java.util.LinkedList; public class Stack&lt;T&gt; &#123; private LinkedList&lt;T&gt; storage = new LinkedList&lt;T&gt;(); public void push(T v) &#123; storage.addFirst(v); &#125; public T peek() &#123; return storage.getFirst(); &#125; public T pop() &#123; return storage.removeFirst(); &#125; public boolean empty() &#123; return storage.isEmpty(); &#125; public String toString() &#123; return storage.toString(); &#125; &#125; 如果想在自己的代码里使用Stack类，在创建实例时，需要完整的指定包名，否则可能会和java.util包中的Stack发生冲突 10.set Set最常使用的是测试归属性，可以轻易的查询某个对象是否在某个Set中。查找成为Set中最重要的操作，因此通常会选择一个HashSet的实现，它专门对快速查找进行了优化。 Set具有与Collection完全一样的接口，实际上Set就是Collection，只是行为不同。Set是基于对象的值来确定归属性的，使用contains() HashSet使用了散列，HashSet所维护的顺序与TreeSet和LinkedHashSet都不一样，因为他们的实现具有不同的元素存储方式。TreeSet将元素存储在红-黑树数据结构中，而HashSet使用的是散列函数。LinkedHashList因为查询速度的原因也使用了散列，但是看起来是使用了链表来维护元素的插入顺序。 1234567891011121314151617import java.util.*; import net.mindview.util.*; public class UniqueWords &#123; public static void main(String[] args) &#123; Set&lt;String&gt; words = new TreeSet&lt;String&gt;( new TextFile("SetOperations.java", "\\W+")); System.out.println(words); &#125; &#125; /* Output: [A, B, C, Collections, D, E, F, G, H, HashSet, I, J, K, L, M, N, Output, Print, Set, SetOperations, String, X, Y, Z, add, addAll, added, args, class, contains, containsAll, false, from, holding, import, in, java, main, mindview, net, new, print, public, remove, removeAll, removed, set1, set2, split, static, to, true, util, void] 如上所示代码，打开一个文件，并将其读入一个Set中。TextFile继承自List，构造器打开文件，并根据正则表达式“\W+”将其断开为单词，这个正则表达式表示“一个或多个字母”，TreeSet将其按字典顺序排列，大小写分开。 如果想按字母顺序排列，可以向TreeSwt构造器传入String.CASE_INSENTIVE_ORDER比较器 12345678910111213141516public class UniqueWordsAlphabetic &#123; public static void main(String[] args) &#123; Set&lt;String&gt; words = new TreeSet&lt;String&gt;(String.CASE_INSENSITIVE_ORDER); words.addAll( new TextFile("SetOperations.java", "\\W+")); System.out.println(words); &#125; &#125; /* Output: [A, add, addAll, added, args, B, C, class, Collections, contains, containsAll, D, E, F, false, from, G, H, HashSet, holding, I, import, in, J, java, K, L, M, main, mindview, N, net, new, Output, Print, public, remove, removeAll, removed, Set, set1, set2, SetOperations, split, static, String, to, true, util, void, X, Y, Z] 11.Map Map的get方法返回该键对应的值。如果没有则返回null。 Map的put方法放入键值对。 Map的contansKey()返回是否含有这个键，containsValue()返回是否含有这个值。 Map可以返回它的键的Set，它的值的Collection，或者它的键值对的Set。value()返回所有值组成的Collection，KeySet()方法产生所有健组成的Set，可用于遍历。 12.Queue 队列是一个典型的先进先出（FIFO）的容器。队列常被当做一种可靠的将对象从程序的某个区域传输到另一个区域的途径。队列在并发编程中特别重要。因为它们可以安全的将对象从一个任务传输给另一个任务。 123offer()是与Queue相关的方法之一，他在允许的情况下，将一个元素插入到队尾，或者返回false。peek()和element()都将在布衣橱的情况下返回队头，但是peek()方法在队列为空时返回null，而element()会抛出NoSuchElementException异常。poll()和remove()方法将一出并返回队头，但是poll()在队列为空时返回null，而remove()会抛出NoSuchElementException异常。 Queue可以由LinkedList来实现。而Queue接口窄化了对LinkedList的方法的访问权限。 PriorityQueue: 先进先出描述了最典型的队列规则。队列规则是指在给定一组队列中的元素的情况下，确定下一个弹出队列的元素的规则。先进先出声明的是下一个元素应该是等待时间最长的元素。 12优先级队列声明下一个弹出元素是最需要的元素（拥有最高优先级）。 PriorityQueue可以确保当你调用peek()、poll()和remove()方法时，获取的元素将是队列中优先级最高的元素。重复是允许的，最小的值拥有最高的优先级（如果是String，空格也可以算作值，并且比字母优先级高），可以使用Collection.reverseOrder()来改变顺序。如 stringPQ = new PriorityQueue(strings.size(), Collections.reverseOrder()); 可以用HashSet来消除重复的Charactor.比如： String fact = “EDUCATION SHOULD ESCHEW OBFUSCATION”; Set charSet = new HashSet(); for(char c : fact.toCharArray()) charSet.add©; // Autoboxing PriorityQueue characterPQ = new PriorityQueue(charSet); QueueDemo.printQ(characterPQ); Output: A B C D E F H I L N O S T U W 13.Collection和Iterator Collection是描述所有序列容器的共性的接口。在Java中，Collection和迭代器绑定到了一起，所有实现Collection就意味着需要实现Iterator()方法 然而如果一个不是Collection类型的外部类，就不能实现Collection接口了，此时使用Iterator就是个不错的选择。继承AbstractCollection可以很容易的实现，它强制实现iterator()和size()方法。 1234567891011121314151617181920212223242526272829import typeinfo.pets.*; import java.util.*; public class CollectionSequence extends AbstractCollection&lt;Pet&gt; &#123; private Pet[] pets = Pets.createArray(8); public int size() &#123; return pets.length; &#125; public Iterator&lt;Pet&gt; iterator() &#123; return new Iterator&lt;Pet&gt;() &#123; private int index = 0; public boolean hasNext() &#123; return index &lt; pets.length; &#125; public Pet next() &#123; return pets[index++]; &#125; public void remove() &#123; // Not implemented throw new UnsupportedOperationException(); &#125; &#125;; &#125; public static void main(String[] args) &#123; CollectionSequence c = new CollectionSequence(); InterfaceVsIterator.display(c); InterfaceVsIterator.display(c.iterator()); &#125; &#125; /* Output: 0:Rat 1:Manx 2:Cymric 3:Mutt 4:Pug 5:Cymric 6:Pug 7:Manx 0:Rat 1:Manx 2:Cymric 3:Mutt 4:Pug 5:Cymric 6:Pug 7:Manx 上例可见，如果实现Collection()，就必须实现Iterator()，更糟糕的是，如果这个外部类已经有需要继承的类而不能继承自AbstractCollection，要实现Collection就必须实现该接口中的所有方法。 123456789101112131415161718192021222324 class PetSequence &#123; protected Pet[] pets = Pets.createArray(8); &#125; public class NonCollectionSequence extends PetSequence &#123; public Iterator&lt;Pet&gt; iterator() &#123; return new Iterator&lt;Pet&gt;() &#123; private int index = 0; public boolean hasNext() &#123; return index &lt; pets.length; &#125; public Pet next() &#123; return pets[index++]; &#125; public void remove() &#123; // Not implemented throw new UnsupportedOperationException(); &#125; &#125;; &#125; public static void main(String[] args) &#123; NonCollectionSequence nc = new NonCollectionSequence(); InterfaceVsIterator.display(nc.iterator()); &#125; &#125; /* Output: 0:Rat 1:Manx 2:Cymric 3:Mutt 4:Pug 5:Cymric 6:Pug 7:Manx 生成Iterator是将队列与消费队列的方法连接在一起耦合度最小的方式，并且与实现Collection相比，它在序列类上所施加的约束也少得多。 14.Foreach与迭代器 Iterable接口包含一个能够产生Iterator的iterator()方法，并且Iterator接口被foreach用来在序列中移动。 大量的类都是Iterable类型，主要包括所有的Collection类（但是不包含各种Map）。 foreach语句可以用于数组或其它任何Iterable，但并不意味着数组肯定是一个Iterable，而任何自动包装也不会自动发生，不存在任何从数组到Iterable的自动转换，必须手动执行这种转换。 12345678910111213141516import java.util.*; public class ArrayIsNotIterable &#123; static &lt;T&gt; void test(Iterable&lt;T&gt; ib) &#123; for(T t : ib) System.out.print(t + " "); &#125; public static void main(String[] args) &#123; test(Arrays.asList(1, 2, 3)); String[] strings = &#123; "A", "B", "C" &#125;; // An array works in foreach, but it’s not Iterable: //! test(strings); // You must explicitly convert it to an Iterable: test(Arrays.asList(strings)); &#125; &#125; /* Output: 1 2 3 A B C 如上，String数组不可以直接作为Iterator类传递，而是被手动转换成了Collection类，也即Iterable类型 适配器方法惯用法: 当有一个接口并需要另一个接口，编写适配器就可以解决问题。至于为什么有一个接口还要写另一个接口么，比如像有乱序倒序的Iterator方法，如果直接继承就会覆盖原有的顺序方法，所以要写别的能产生Iterable对象的方法接口（适配器）以满足foreach语句实现功能。 通过使用方法中的内部类，下例实现了在foreach方法中将Iterable对象倒序和乱序遍历的方法 1234567891011121314151617181920212223242526272829303132333435363738394041 import java.util.*; public class MultiIterableClass extends IterableClass &#123; public Iterable&lt;String&gt; reversed() &#123; return new Iterable&lt;String&gt;() &#123; public Iterator&lt;String&gt; iterator() &#123; return new Iterator&lt;String&gt;() &#123; int current = words.length - 1; public boolean hasNext() &#123; return current &gt; -1; &#125; public String next() &#123; return words[current--]; &#125; public void remove() &#123; // Not implemented throw new UnsupportedOperationException(); &#125; &#125;; &#125; &#125;; &#125; public Iterable&lt;String&gt; randomized() &#123; return new Iterable&lt;String&gt;() &#123; public Iterator&lt;String&gt; iterator() &#123; List&lt;String&gt; shuffled = new ArrayList&lt;String&gt;(Arrays.asList(words)); Collections.shuffle(shuffled, new Random(47)); return shuffled.iterator(); &#125; &#125;; &#125; public static void main(String[] args) &#123; MultiIterableClass mic = new MultiIterableClass(); for(String s : mic.reversed()) System.out.print(s + " "); System.out.println(); for(String s : mic.randomized()) System.out.print(s + " "); System.out.println(); for(String s : mic) System.out.print(s + " "); &#125; &#125; /* Output: banana-shaped. be to Earth the know we how is that And is banana-shaped. Earth that how the be And we know to And that is how we know the Earth to be banana-shaped. 注意乱序方法并没有创建自己的Iterator,而是直接返回被打乱的List（作为Collection类的一种）中的Iterator。 需要注意的是，Arrrays.asList()产生的List对象会使用底层数组作为其物理实现，也就是会修改原来的数组。如果不想这种情况发生，就应该在另一个容器中创建一个副本。即使用 List list = new ArrayList(Arrays.asList(数组)) 的方法，这样修改的只是list引用而不是原数组 15.总结 Java提供了大量持有对象的方式： 1、数组。一旦生成，容量就不能改变。 2、Collection保存单一的元素，Map保存相关联的键值对。它们可以自动的调整其尺寸。容器不能持有基本类型，但是自动包装机制会自动地执行基本类型到容器中所持有的包装器类型之间的双向转换。 数组和List都是排好序的容器，List可以自动扩容。 如果需要大量随机访问，使用ArrayList，如果要经常在其中插入删除，则使用LinkedList。 各种Queue以及栈的行为，由LinkedList提供支持。 Map将对象与对象相关联，HashMap用来快速访问，而TreeMap保持“键”始终处于排序状态，所以没有HashMap快。LinkedHashMap保持原始插入的顺序，但也通过散列提供了快速访问能力。 Set不接受重复元素。HashSet提供最快的查询速度，TreeSet保持元素处于排序状态，LinkedHashSet以插入顺序保存元素。 新程序不该使用过时的Vector、Hashtable和Stack。 除了TreeSet之外的所有Set都拥有与Collection完全一样的接口。 List和Collection存在着明显的不同，尽管List所要求的方法都在Collection中。 另一方面，在Queue接口中的方法都是独立的，在创建具有Queue功能的实现时，不需要使用Collection方法。 最后，Map和Collection之间唯一的重叠就是Map可以使用entrySet()和values()方法来产生Collection。 参考资料 https://blog.csdn.net/severusyue/article/details/49491441 Java编程思想第四版读书笔记——第十一章 持有对象 severusyue]]></content>
      <categories>
        <category>书籍</category>
        <category>java</category>
        <category>java编程思想第四版</category>
      </categories>
      <tags>
        <tag>书籍</tag>
        <tag>java</tag>
        <tag>java编程思想第四版</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java编程思想第四版第十章读书笔记]]></title>
    <url>%2Fblog%2F2019%2F01%2F18%2Fjava%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E7%AC%AC%E5%9B%9B%E7%89%88%E7%AC%AC%E5%8D%81%E7%AB%A0%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[前言 最近一段时间重读了java编程思想，把一些东西重新理解记录一遍 目的 整理知识点，方便以后回顾，这一章主要讲解了java的内部类 正文 1.内部类 可以将一个类的定义放在另一个类的定义内部，这就是内部类 内部类和组合是完全不同的概念 2.创建内部类 内部类是嵌在外部类内部的类。 如果想从外部类的非静态方法创建一个内部类对象，一定要用“. ”,Outer Class . InnerClass 比如： Parcel2.Contents c = q.contents(); 3.链接到外部类 内部类可以访问外围对象的所有成员。对外围类的所有元素都有访问权。 内部类的对象只有在于外部类的对象相关联时才能被创建。当某个外围类对象创建一个内部类对象，此内部类的对象必定会秘密的捕获一个指向那个外围类对象的引用。依赖于外部对象，也就是，必须是外部类对象 . 某方法（） 的方式创建 下面是&quot;迭代器&quot;设计模式的一个梨子 123456789101112131415161718192021222324public class Sequence&#123; private Object[] items; private int next=0; public Sequence(int size)&#123; items=new Object[size]; &#125; private class SequenceSelector&#123; private int i=0; public boolean end()&#123; return i=items.length;// &#125; public void next()&#123; i++; &#125; &#125; public SequenceSelector selector()&#123; return new SequenceSelector(); &#125; public static void main(String[] args)&#123; Sequence seq=new Sequence(); Sequence.SequenceSelector=seq.selector(); &#125; &#125; 4.使用.this和.new 内部类创建外部类对象，return OuterClass.this; 在其它地方创建内部类，要用外围类对象创建，而不是用类名。 OuterClass.InnerClass inner = outer.new Inner(); 在拥有外部类对象之前是不可能创建内部类对象的，这是因为内部类对象会暗暗的连接到创建他的外部类对象上，但是如果你创建的是嵌套类(静态内部类),就不需要对外部类对象的引用了 1234567891011121314public class DotThis&#123; void f()&#123;&#125; public class Inner&#123; public DotThis outer()&#123; return DotThis.this; &#125; &#125; public Inner inner()&#123;return new Inner();&#125; public static void main(String[] args)&#123; DotThis dt=new DotThis(); DotThis.Inner dti=dt.new Inner(); dti.outer().f(); &#125; &#125; 5.内部类与向上转型 接口的所有成员自动被设置为public private内部类给类的设计者提供了一种途径，通过这种方式可以完全阻止任何依赖于类型的编码，并且完全隐藏了细节。因为是private，所以除了外围类不能访问它，只能通过outer.contents() 方法return的new出来。 因为上转型为接口，所以隐藏了原本的类型。 由于不能访问任何新增加的，原本不属于公共接口的方法，所以扩展接口是没有价值的。这也给Java编译器提供了生成更高效代码的机会。因为转型只能转型成接口类型，收窄了 1234567891011121314151617181920212223242526272829303132public interface Destination&#123; String readLabel();&#125;public interface Contents&#123; int value();&#125;class Parcel&#123; private class PContents implements Contents&#123; public int value()&#123;return 10;&#125; &#125; protected class PDestination implements Destination&#123; public String readLabel()&#123; return "Hello word"; &#125; &#125; public PContent contents()&#123; return new PContents(); &#125; public PDestination destination()&#123; return new PDestination(); &#125;&#125;public class TestParcel&#123; public static void main(String[] args)&#123; Parcel p=new Parcel(); Contents c=p.contents(); Destination d=p.destination(); &#125;&#125; 6.在方法和作用域内的内部类 可以在一个方法或者任意的作用域内定义内部类，这样做有两个理由： 1、实现了某类型的接口，于是可以创建并返回对其的引用。 2、要解决一个复杂的问题，想创建一个类来辅助解决方案，但是不希望这个类是公用的。 可以看到内部类可以在以下定义 123456一个定义在方法中的类一个定义在作用域的类，此作用域在方法的内部一个实现了接口的匿名类一个匿名类，它扩展了有非默认构造器的类一个匿名类，他执行字段初始化一个匿名类，它通过实例初始化实现构造 下面两个梨子实现了前两个 123456789101112131415161718192021222324252627282930313233343536373839//方法内部类(又称局部内部类)public class Parcel&#123; //方法 public Destination destination()&#123; //方法内部类 class PInner implements Destination&#123; public String say()&#123; return "Hello word!"; &#125; &#125; return new PInner(); &#125; public static void main(String[] args)&#123; Parcel p=new Parcel(); Destination d=p.destination(); &#125;&#125;//作用域内部类public class Parcel&#123; public void fun(boolean b)&#123; if(b)&#123; //作用域内部类 class Inner&#123; private String id; Inner(String id)&#123; this.id=id; &#125; public String say()&#123;&#125; &#125; new Inner().say(); &#125; &#125; public static void main(String[] args)&#123; Parcel p=new Parcel(); p.fun(true); &#125;&#125; 7.匿名内部类 123456789101112public class Parcel7 &#123; public Contents contents() &#123; return new Contents() &#123; // Insert a class definition private int i = 11; public int value() &#123; return i; &#125; &#125;; // Semicolon required in this case &#125; public static void main(String[] args) &#123; Parcel7 p = new Parcel7(); Contents c = p.contents(); &#125;&#125; 由此可以创建一个继承自Contents的匿名内部类。 不能给内部类用构造器初始化，因为匿名内部类没有名字。 如果定义一个匿名内部类，它需要使用外部定义的参数，那么次参数引用需要是final的,实例初始化的效果就是构造器 1234567891011121314151617181920212223242526272829303132abstract class Base&#123; public Base(int i)&#123; print("Base constructor "); &#125; public abstract void f(); &#125; public class Anonymous&#123; public static Base getBase(int i)&#123;//这里的i参数传递给了匿名类的基类构造函数, //并没有在匿名类内部使用 return new Base(i)&#123; public void f()&#123; print("Anonymout f()"); &#125; &#125;; &#125; public Destination destination(final String dest,final float price)&#123; return new Destination()&#123; private int cost; &#123; cost=Math.round(price);//当直接在匿名类直接使用参数时必须加final &#125; private String str=dest; &#125;; &#125; public static void main(String[] args)&#123; Base base=getBase(4); base.f(); &#125; &#125; 因为匿名内部类既可以扩展类，也可以实现接口，但是不能两者兼备，而且如果是实现接口，也只能实现要给接口 在访工厂方法 利用匿名内部类可以更加优雅的实现工厂方法 1234567891011121314151617181920212223242526interface Game&#123;boolean move();&#125;interface GameFactory&#123;Game getGame();&#125;class Checker implements Game&#123; public boolean move()&#123;return true;&#125; public static GameFactory factory=new GameFactory()&#123; public Game getGame()&#123;return new Checker();&#125; &#125;;&#125;class Chess implements Game&#123; public boolean move()&#123;return true;&#125; public static GameFactory factory=new GameFactory()&#123; public Game getGame()&#123;return new Chess();&#125; &#125;;&#125;public class TestGames&#123; public static void playGame(GameFactory g)&#123; Game game=g.getGame(); g.move(); &#125; public static void main(String[] args)&#123; playGame(Checker.factory); playGame(Chess.factory); &#125; &#125; 8.嵌套类 将内部类声明为static，这通常称为嵌套类。 嵌套类意味着： 1、要创建嵌套类的对象，不需要其外围类的对象。 2、不能从嵌套类的对象中访问非静态的外围对象。 普通内部类不能有static数据和static字段，也不能包含嵌套类，而嵌套类可以包含。它不需要依赖外围类引用 12345678910111213141516171819202122232425262728293031public class Parcel11 &#123; private static class ParcelContents implements Contents &#123; private int i = 11; public int value() &#123; return i; &#125; &#125; protected static class ParcelDestination implements Destination&#123; private String label; private ParcelDestination(String whereTo) &#123; label = whereTo; &#125; public String readLabel() &#123; return label; &#125; // Nested classes can contain other static elements: public static void f() &#123;&#125; static int x = 10; static class AnotherLevel &#123; public static void f() &#123;&#125; static int x = 10; &#125; &#125; public static Destination destination(String s) &#123; return new ParcelDestination(s); &#125; public static Contents contents() &#123; return new ParcelContents(); &#125; public static void main(String[] args) &#123; Contents c = contents(); Destination d = destination("Tasmania"); &#125; &#125; 接口内部的类 接口中的任何类自动是public和static的 如果想创建某些公共代码，使得它们可以被某个接口的所有不同实现所公用，那么使用接口内部的嵌套类会显得很方便 1234567891011public interface ClassInInterface &#123; void howdy(); class Test implements ClassInInterface &#123; public void howdy() &#123; System.out.println("Howdy!"); &#125; public static void main(String[] args) &#123; new Test().howdy(); &#125; &#125; &#125; 扩展 java8接口增强 12a. 在接口中可以添加使用 default 关键字修饰的非抽象方法。即：默认方法（或扩展方法）b. 接口里可以声明静态方法，并且可以实现。 a:在接口中可以添加使用 default 关键字修饰的非抽象方法。即：默认方法（或扩展方法）: Java 8 允许给接口添加一个非抽象的方法实现，只需要使用 default 关键字即可，这个特征又叫做扩展方法（也称为默认方法或虚拟扩展方法或防护方法）。在实现该接口时，该默认扩展方法在子类上可以直接使用，它的使用方式类似于抽象类中非抽象成员方法。 Note：扩展方法不能够重写（也称复写或覆盖） Object 中的方法，却可以重载Object 中的方法。 eg：toString、equals、 hashCode 不能在接口中被覆盖，却可以被重载。 默认方法允许我们在接口里添加新的方法，而不会破坏实现这个接口的已有类的兼容性，也就是说不会强迫实现接口的类实现默认方法。 默认方法和抽象方法的区别是抽象方法必须要被实现，默认方法不是。作为替代方式，接口可以提供一个默认的方法实现，所有这个接口的实现类都会通过继承得到这个方法（如果有需要也可以重写这个方法） 1234567891011121314151617interface Defaulable &#123; //使用default关键字声明了一个默认方法 @SuppressLint("NewApi") default String myDefalutMethod() &#123; return "Default implementation"; &#125;&#125;class DefaultableImpl implements Defaulable &#123; //DefaultableImpl实现了Defaulable接口，没有对默认方法做任何修改&#125;class OverridableImpl implements Defaulable &#123; //OverridableImpl实现了Defaulable接口重写接口的默认实现，提供了自己的实现方法。 @Override public String myDefalutMethod() &#123; return "Overridden implementation"; &#125;&#125; b:接口里可以声明静态方法，并且可以实现 注意:Supplier 的使用,可看参考资料，在接口部分(java编程思想第四版第九章读书笔记 第十点)我们分别建一个工厂和一个产品接口类，然后实现，不同的工厂建立不同的产品，但是我们通过接口静态方法，将工厂的实现利用多态都写在一个接口内。 123456private interface DefaulableFactory &#123; // Interfaces now allow static methods static Defaulable create(Supplier&lt; Defaulable &gt; supplier ) &#123; return supplier.get(); &#125;&#125; a,b的调用 1234567public static void main( String[] args ) &#123; Defaulable defaulable = DefaulableFactory.create( DefaultableImpl::new ); System.out.println( defaulable.myDefalutMethod() ); defaulable = DefaulableFactory.create( OverridableImpl::new ); System.out.println( defaulable.myDefalutMethod() );&#125; 9.为什么需要内部类 内部类继承自某个类或实现某个接口，内部类的代码操作创建它的外围类的对象。可以认为内部类提供了某种进入其外围类的窗口。 内部类最吸引人的原因是： 12内部类使得多重继承的解决方案变得完整。接口解决了部分问题，而内部类有效的实现了“多重继承”。也就是说，内部类允许继承多个非接口类型（类或抽样类）。（个人感觉一个外围类可以包含多个内部类，然后每个内部类通过多个方法分别return new baseClass1&#123;.......&#125;; return new baseClass2&#123;.......&#125;; return new baseClass3&#123;.......&#125;; 在调用时使用 outer.方法() 可以返回多重类型，作为函数的参数，达到“多重继承”的效果。）如果拥有的是抽象类或者具体的类，而非接口，那就只有内部类才能实现多重继承。 如果使用内部类，可以获得一些特别的特性： 1234内部类可以有多个实例，每个实例都有自己的状态信息，并且与其外围类对象的信息相互独立。在单个外围类中，可以让多个内部类以不同的方式实现同一个接口，或继承同一个类。创建内部类对象的时刻并不依赖于外围类对象的创建。内部类没有令人迷惑的“is-a”关系，它就是一个独立的实体。 闭包与回调： 闭包是一个可调用的对象，它记录了一些信息，这些信息来自于创建它的作用域。内部类是面向对象的闭包。在此作用域内，内部类有权操作所有的成员，包括private成员。 继承两个类，含有同名方法，使用内部类可以避免覆盖。当创建一个内部类，没有在外围类接口中添加东西，也没有修改外围类接口。 通过回调，对象能够携带一些信息，这些信息允许它在稍后的某个时刻调用初始的对象。 回调的价值在于它的灵活性——可以在运行时动态的决定要调用什么方法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374package com.test.demo;interface Incrementable &#123; void increment();&#125;class Callee1 implements Incrementable &#123; private int i = 0; public void increment() &#123; i++; System.out.println(i); &#125;&#125;class MyIncrement &#123; public void increment() &#123;// 注意这里已经有了一个increment方法 System.out.println("\nOther operation"); &#125; static void f(MyIncrement mi) &#123; mi.increment(); &#125;&#125;//因为Callee2继承MyIncrement中已经又increment方法了//如果Callee2想要implements(实现) Incrementable//那么就需要使用内部类class Callee2 extends MyIncrement &#123; private int i = 0; public void increment() &#123; super.increment(); i++; System.err.println(i); &#125; private class ClosureDe implements Incrementable &#123; @Override public void increment() &#123; Callee2.this.increment();//这里调用外部类的increment方法 &#125; &#125; Incrementable getCallbackReference() &#123; return new ClosureDe(); &#125;&#125;class Caller &#123; private Incrementable callbackreference; public Caller(Incrementable inc) &#123; this.callbackreference = inc; &#125; void go() &#123; callbackreference.increment(); &#125;&#125;public class Closure &#123; public static void main(String[] args) &#123; Callee1 c1 = new Callee1(); Caller caller1 = new Caller(c1); caller1.go(); caller1.go(); Callee2 c2 = new Callee2(); MyIncrement.f(c2); Caller caller2 = new Caller(c2.getCallbackReference()); caller2.go(); caller2.go(); &#125;&#125; 内部类与控制框架: 应用程序框架就是被设计用以解决某类特定问题的一个类或者一组类。 模板方法是保持不变的事物，而可覆盖的方法就是变化的事物。 控制框架是一类特殊的应用程序框架，它用来解决响应事件的需求。主要用来响应事件的系统被称作事件驱动系统。 “变化向量”是各种不同的Event对象所具有的不同行为，通过创建不同的Event子类来表现不同的行为。 内部类允许： 12控制框架的完整实现是由单个类创建的，从而使得实现的细节被封装起来。内部类用来表示解决问题所必需的各种不同的action()。内部类可以很容易的访问外围类的任意成员，所以可以避免这种实现变得笨拙。 10.内部类的继承 1234567891011121314151617package com.test.demo;class WithInner &#123;class Inner &#123;&#125;&#125;public class InheritInner extends WithInner.Inner &#123; public InheritInner(WithInner wi) &#123; wi.super(); &#125;public InheritInner() &#123;new WithInner().super();&#125;public static void main(String[] args) &#123; WithInner wi = new WithInner(); InheritInner ii = new InheritInner(wi); &#125;&#125; 在继承内部类时如果继续使用默认构造器会报错,而且不能只传递一个指向外部类对象的引用。此时必须在构造器内使用如下语法： 1外部类对象.super(); 这样才提供了必要的引用，才可以编译通过 内部类可以被覆盖吗》当继承某个外部类时,内部类并没有发生什么变化。内部类是完全独立的两个实体，各自在自己的命名空间内 局部内部类》局部内部类不能有访问说明符,因为它不是外部类的一部分;但是它可以访问当前代码代码块中的常量，以及此外部类的所有成员 内部类标识符》内部类也会生成一个.class文件。这些文件的命名规则是:外部类的名字+“$”+内部类的名字；如果是匿名内部类编译器也会产生一个数字作为你其标识 参考资料 https://blog.csdn.net/severusyue/article/details/49444629 severusyue https://blog.csdn.net/sun_promise/article/details/51220518 莫若吻 https://my.oschina.net/0sbVMw/blog/535010 Solid]]></content>
      <categories>
        <category>书籍</category>
        <category>java</category>
        <category>java编程思想第四版</category>
      </categories>
      <tags>
        <tag>书籍</tag>
        <tag>java</tag>
        <tag>java编程思想第四版</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java编程思想第四版第九章读书笔记]]></title>
    <url>%2Fblog%2F2019%2F01%2F16%2Fjava%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E7%AC%AC%E5%9B%9B%E7%89%88%E7%AC%AC%E4%B9%9D%E7%AB%A0%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[前言 最近一段时间重读了java编程思想，把一些东西重新理解记录一遍 目的 整理知识点，方便以后回顾，这一章主要讲解了java的接口 正文 1.接口 接口和内部类为我们提供了一种将接口与实现分离的更加结构化的方法 2.抽象类和抽象方法 1public abstract void f(); 创建抽象类是希望通过这个通用接口操纵一系列类。如果一个类包含大于等于一个抽象方法，那么这个类就是抽象类，必须用abstract关键字来限定这个抽象类。 如果试图直接创建该抽象类的对象，编译器会报错。 如果抽象类的子类没有为基类的抽象方法提供定义，那么这个导出类依旧是抽象类。 抽象类也可以不包含任何抽象方法，单纯的用abstract限定类。（该类不能产生对象） 抽象类是很有用的重构工具，它可以使我们可以很容易的将公共方法沿着继承层次结构向上移动 3.接口 interface这个关键字替代class关键字，产生了一个完全抽象的类。接口只提供形式，未提供任何具体实现。 接口被用了建立类与类之间的协议。接口也可以包含域，但是这些域隐式的是static和final的。因此，其中定义的成员变量，是static&amp;final的。 implenments关键字可以跟一组接口，extends关键字只能跟一个基类。 接口中的方法必须是public的，隐式的被声明public的，如果要显示声明，它们也必须被声明为public的。否则在继承的过程中，可访问权限被降低，这是java编译器所不允许的。 4.完全解耦 策略设计模式：创建一个能够根据传递参数对象不同而具有不同行为的方法 1234567891011121314151617181920212223242526272829303132333435363738394041424344package interfaces.classprocessor;import java.util.*;import static net.mindview.util.Print.*;class Processor &#123;public String name() &#123;return getClass().getSimpleName();&#125;Object process(Object input) &#123; return input; &#125;&#125;class Upcase extends Processor &#123;String process(Object input) &#123; // Covariant returnreturn ((String)input).toUpperCase();&#125;&#125;class Downcase extends Processor &#123;String process(Object input) &#123;return ((String)input).toLowerCase();&#125;&#125;class Splitter extends Processor &#123;String process(Object input) &#123;// The split() argument divides a String into pieces:return Arrays.toString(((String)input).split(" "));&#125;&#125;public class Apply &#123;public static void process(Processor p, Object s) &#123;print("Using Processor " + p.name());print(p.process(s));&#125;public static String s ="Disagreement with beliefs is by definition incorrect";public static void main(String[] args) &#123;process(new Upcase(), s);process(new Downcase(), s);process(new Splitter(), s);&#125;&#125; /* Output:Using Processor UpcaseDISAGREEMENT WITH BELIEFS IS BY DEFINITION INCORRECTUsing Processor Downcasedisagreement with beliefs is by definition incorrectUsing Processor Splitter[Disagreement, with, beliefs, is, by, definition, incorrect] 适配器设计模式:当一个类是第三方jar中，你无法修改，但是你想用这个类实现某些接口，可以利用适配器模式，新建一个类实现接口，并将不可修改的类作为它的属性，利用这个属性的方法来实现接口，调用的时候在外面包一层 1234567891011121314151617181920212223242526272829303132333435363738394041424344/* Solution includes, in same package:* package interfaces.interfaceprocessor;* public class StringMixer &#123;* static String process(String s) &#123;* char[] ca = new char[s.length()];* if((s.length())%2 == 0) &#123;* for(int i = 0; i &lt; s.length(); i += 2) &#123;* ca[i] = s.charAt(i + 1);* ca[i + 1] = s.charAt(i); * &#125; * return new String(ca);* &#125;* else &#123;* for(int i = 0; i &lt; s.length() - 1; i += 2) &#123;* ca[i] = s.charAt(i + 1);* ca[i + 1] = s.charAt(i); * &#125;* ca[s.length() - 1] = s.charAt(s.length() - 1); * return new String(ca);* &#125;* &#125; * &#125;*/// program takes command line String argument:package interfaces.interfaceprocessor;class StringMixerAdapter implements Processor &#123; public String name() &#123; return "StringMixerAdapter"; &#125; StringMixer stringMixer; public StringMixerAdapter(StringMixer stringMixer) &#123; this.stringMixer = stringMixer; &#125; public String process(Object input) &#123; return stringMixer.process((String)input); &#125; &#125;public class StringMixerProcessor &#123; public static void main(String[] args) &#123; String s = new String(args[0]); Apply.process(new StringMixerAdapter(new StringMixer()), s); &#125;&#125; 5.java中的多重继承 java没有任何与接口相关的存储，因此可以实现继承多个接口 使用接口的核心原因：1.为了能够向上转型为多个基本类型 2.顺带可以防止客户端程序员创建该类的对象，确保这是一个接口 java通过接口和内部类来达到多重继承的效果 6.通过继承扩展接口 extends只能用于单一类，但是接口继承时却可以引用多个接口，用逗号分开。 1interface Interface1 extends Interface2，Interface3&#123;&#125; 接口无法用implements来实现别的接口，必须用extends。 应该尽量避免组合的多个接口中包含相同方法名，这样会造成代码可读性的混乱。 7.适配接口 类的构造器接受一个接口，将希望使用该类的类都实现该接口，这样可以类就可以作用于更多的类型。比如Scanner类，想使用该类的类型 和策略模式的不同： 方法可以作用于不同的类型。 而适配器模式是，将接口作为类的构造器参数，子类传入这个类，就能调用这个类的方法 8、接口中的域 接口中的域是static&amp;final的，所以常量初始化值会用大写字母的风格。 package interfaces; public interface Months { int JANUARY = 1, FEBRUARY = 2, MARCH = 3, APRIL = 4, MAY = 5, JUNE = 6, JULY = 7, AUGUST = 8, SEPTEMBER = 9, OCTOBER = 10, NOVEMBER = 11, DECEMBER = 12; } 但是一般不这么做，在接口中定义常量，而是用enum关键字实现。 接口中定义的常量一定要初始化，不能出现空final，但是可以被非常量表达式初始化。 9.嵌套接口 嵌套在另一个接口中的接口自动是 public 的，而不能声明为 private 的. 嵌套在另一个类中的接口可以是 private 的，可以在内部实现成为一个 public 类，但是这个类不允许向上转型 当实现某个接口是，并不需要实现嵌套在其内部的任何借口，而且，private接口不能在定义它的类之外被实现。 10.接口与工厂 工厂设计模式： 在工厂对象上调用创建方法，该工厂对象将生成接口的某个实现对象。这样将代码与接口实现分离，这样使得我们可以透明的将某个实现替换成另一个实现。 1234567891011121314151617181920212223242526272829303132333435363738394041424344import static net.mindview.util.Print.*;interface Service &#123;void method1();void method2();&#125;interface ServiceFactory &#123;Service getService();&#125;class Implementation1 implements Service &#123;Implementation1() &#123;&#125; // Package accesspublic void method1() &#123;print("Implementation1 method1");&#125;public void method2() &#123;print("Implementation1 method2");&#125;&#125;class Implementation1Factory implements ServiceFactory &#123;public Service getService() &#123;return new Implementation1();&#125;&#125;class Implementation2 implements Service &#123;Implementation2() &#123;&#125; // Package accesspublic void method1() &#123;print("Implementation2 method1");&#125;public void method2() &#123;print("Implementation2 method2");&#125;&#125;class Implementation2Factory implements ServiceFactory &#123;public Service getService() &#123;return new Implementation2();&#125;&#125;public class Factories &#123;public static void serviceConsumer(ServiceFactory fact) &#123;Service s = fact.getService();s.method1();s.method2();&#125;public static void main(String[] args) &#123;serviceConsumer(new Implementation1Factory());// Implementations are completely interchangeable:serviceConsumer(new Implementation2Factory());&#125;&#125; /* Output:Implementation1 method1Implementation1 method2Implementation2 method1Implementation2 method2 对消费者传递一个工厂1对象，产生工厂1的产品，调用产品1的方法。 对消费者传递一个工厂2对象，产生工厂2的产品，调用产品2的方法。 总结： 确定接口是理想选择，因而应该总是选择接口而不是具体的类,对于创建类，几乎在任何时刻，都可以替代为创建一个工厂和一个接口 这其实是一种陷阱，变成了一种草率的设计优化，任何抽象性应该是真正的需求而产生的 参考资料 https://blog.csdn.net/severusyue/article/details/51766573 severusyue]]></content>
      <categories>
        <category>书籍</category>
        <category>java</category>
        <category>java编程思想第四版</category>
      </categories>
      <tags>
        <tag>书籍</tag>
        <tag>java</tag>
        <tag>java编程思想第四版</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java编程思想第四版第八章读书笔记]]></title>
    <url>%2Fblog%2F2019%2F01%2F16%2Fjava%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E7%AC%AC%E5%9B%9B%E7%89%88%E7%AC%AC%E5%85%AB%E7%AB%A0%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[前言 最近一段时间重读了java编程思想，把一些东西重新理解记录一遍 目的 整理知识点，方便以后回顾，这一章主要讲解了java的多态 正文 1.多态 在面向对象的程序设计语言中，多态是继数据抽象和继承之后的第三种基本特征 “封装”通过合并特征和行为来创建新的数据类型。（合并成员函数和方法创建类） “多态”消除类型之间的耦合关系 多态也称做动态绑定，后期绑定或运行时绑定 2.在论向上转型 子类对象的引用向上转型为基类，传递到相应方法中 3.转机 将一个方法调用同一个方法主体关联起来被称作绑定。 程序执行前的绑定（由编译器和连接程序实现），称为前期绑定。 运行时根据对象的类型进行绑定，称为后期绑定，也称为动态绑定或运行时绑定。 Java中除了static方法和final方法（private属于final方法）外，其它所有方法都是动态绑定。 多态让程序员将“改变的事物与未改变的事物分离开来 注意:只有非private方法才能被覆盖，当然覆盖private类时，编译器不会报错。但是导出类和基类中的该同名方法，是两个不同的方法，向上转型为基类调用时，会调用基类的那个private的方法 静态方法是与类，而非单个对象关联的，因此不是多态的 任何域访问操作都有编译器解析，因此不是多态的 当Sub对象转型为Super使用时，任何域访问操作都将由编译器解析，因此不是多态的。（在包含相同成员变量时，子类包含两个域，基类和自己的，当要调用基类中该重名成员变量时，系统不会多态的自动的调用基类的该变量，需要显式的指明super.成员变量。） 4.构造器和多态 当有多重继承关系时，调用构造器顺序： 基类构造器 -&gt; 成员的初始化方法 -&gt; 子类构造器 完整:基类staitic–&gt;子类static–&gt;基类基本类型设为默认值0，对象引用被设为Null–&gt;基类构造器–&gt;子类基本类型设为默认值0，对象引用被设为Null–&gt;子类构造器 在销毁时，需要显式的调用基类的dispose()方法，销毁的顺序和初始化相反，包括字段的销毁顺序和申明的顺序相反。共享数据最后dispose()。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170/** * https://creambing.github.io Inc. * Copyright(c)2018-2025 All Rights Reserved. */package com.creambing.thinkinginjava.polymorphism;/** * Class Name: Share * Description: 清理，用来记录引用计数 * * author: CreamBing * time: 2019-01-11 14:32 * version: v1.0.0 */public class Share &#123; private int refcount = 0; private static long counter = 0; private final long id = ++counter; public Share() &#123; System.out.println("create"+this); &#125; public void addRef()&#123; refcount++; &#125; public int getRefcount() &#123; return refcount; &#125; protected void dispose()&#123; if(--refcount==0)&#123; System.out.println("dispose"+this); &#125; &#125; @Override public String toString() &#123; return "Share&#123;" + "refcount=" + refcount + ", id=" + id + '&#125;'; &#125; public static void main(String[] args) &#123; Share s1 = new Share(); Share s2 = new Share(); System.out.println("**********"); System.out.println(s1); System.out.println("************"); System.out.println(s2); &#125;&#125;/** * https://creambing.github.io Inc. * Copyright(c)2018-2025 All Rights Reserved. *///package com.creambing.thinkinginjava.polymorphism;/** * Class Name: Composing * Description: 共享类 * * author: CreamBing * time: 2019-01-11 14:42 * version: v1.0.0 */public class Composing &#123; private Share share; private static long count = 0; private final long id = ++count; public Composing(Share share) &#123; this.share = share; this.share.addRef(); System.out.println("create "+this); &#125; protected void dispose()&#123; System.out.println("dispose "+this); share.dispose(); &#125; @Override public String toString() &#123; return "Composing&#123;" + "share=" + share + ", id=" + id + '&#125;'; &#125;&#125;/** * https://creambing.github.io Inc. * Copyright(c)2018-2025 All Rights Reserved. *///package com.creambing.thinkinginjava.polymorphism;/** * Class Name: ReferenceCounting * Description: 对象引用计数 * &lt;p&gt; * author: CreamBing * time: 2019-01-11 14:48 * version: v1.0.0 */public class ReferenceCounting &#123; Share s1 = new Share(); Composing[] ca; public ReferenceCounting() &#123; this.ca = new Composing[]&#123;new Composing(s1), new Composing(s1), new Composing(s1)&#125;; &#125; @Override protected void finalize() throws Throwable &#123; if (s1.getRefcount() != 0) &#123; System.out.println("Composing没有清理干净，还有实例引用Share"); &#125; else &#123; System.out.println("Composing清理干净，开始垃圾回收"); super.finalize(); &#125; &#125; /** * createShare&#123;refcount=0, id=1&#125; * create Composing&#123;share=Share&#123;refcount=1, id=1&#125;, id=1&#125; * create Composing&#123;share=Share&#123;refcount=2, id=1&#125;, id=2&#125; * create Composing&#123;share=Share&#123;refcount=3, id=1&#125;, id=3&#125; * dispose Composing&#123;share=Share&#123;refcount=3, id=1&#125;, id=1&#125; * c[0] dispose * 开始强制垃圾回收 * ************************************* * dispose Composing&#123;share=Share&#123;refcount=2, id=1&#125;, id=2&#125; * dispose Composing&#123;share=Share&#123;refcount=1, id=1&#125;, id=3&#125; * disposeShare&#123;refcount=0, id=1&#125; * ca[1],ca[2]清理，所有Composing对象清理完毕 * 开始强制垃圾回收 * Composing清理干净，开始垃圾回收 * 注释掉********************************后面的东西 * createShare&#123;refcount=0, id=1&#125; * create Composing&#123;share=Share&#123;refcount=1, id=1&#125;, id=1&#125; * create Composing&#123;share=Share&#123;refcount=2, id=1&#125;, id=2&#125; * create Composing&#123;share=Share&#123;refcount=3, id=1&#125;, id=3&#125; * dispose Composing&#123;share=Share&#123;refcount=3, id=1&#125;, id=1&#125; * c[0] dispose * 开始强制垃圾回收 * ************************************* * Composing没有清理干净，还有实例引用Share * @param args */ public static void main(String[] args) &#123; ReferenceCounting r = new ReferenceCounting(); r.ca[0].dispose(); System.out.println("c[0] dispose"); System.out.println("开始强制垃圾回收"); System.runFinalizersOnExit(true); System.out.println("*************************************"); r.ca[1].dispose(); r.ca[2].dispose(); System.out.println("ca[1],ca[2]清理，所有Composing对象清理完毕"); System.out.println("开始强制垃圾回收"); System.runFinalizersOnExit(true); &#125;&#125; 上面Share类中的下列代码实现了引用计数,refcount记录其他类中对这个类对象的引用数，id记录这是这个类的第几个实例，counter记录了这个类工实例的几次 不过下面的实现虽然巧妙但是并不完美，因为counter的值还是可以通过反射进行修改，详情可见**EffectiveJava第三版第一条读书笔记** 123private int refcount = 0;private static long counter = 0;private final long id = ++counter; 构造器内部的多态方法的行为： 在初始化时，基类构造器中调用子类中覆盖的方法，此时子类的成员变量未赋值，如果此时对其操作可能会产生意想之外的结果。所以应该避免这样做。在构造器内唯一能够安全调用的事基类中的final方法。 编写构造器时一条有效的准则:用尽可能简单的方法使对象进入正常状态，如果可以的话，避免调用其它方法 5.协变返回类型 子类中被覆盖的方法可以返回基类方法所返回类型的子类，这样虽然返回值类型不同，但是也算覆盖。 6.用继承进行设计 组合更加灵活，首选组合 用继承表达行为间的差异，用字段表达状态上的变化 状态设计模式 创建一个基类的引用，通过方法改变其所指向的对象类型（子类们），调用相同的方法，行为产生变化。（调用了相应子类的方法）。 这样可以实现动态灵活性。 如下所示： 12345678910111213141516171819202122232425import static net.mindview.util.Print.*;class Actor &#123;public void act() &#123;&#125;&#125;class HappyActor extends Actor &#123;public void act() &#123; print("HappyActor"); &#125;&#125;class SadActor extends Actor &#123;public void act() &#123; print("SadActor"); &#125;&#125;class Stage &#123;private Actor actor = new HappyActor();public void change() &#123; actor = new SadActor(); &#125;public void performPlay() &#123; actor.act(); &#125;&#125;public class Transmogrify &#123;public static void main(String[] args) &#123;Stage stage = new Stage();stage.performPlay();stage.change();stage.performPlay();&#125;&#125; /* Output:HappyActorSadActor 对于子类扩展基类接口的情况，向上转型后不能调用子类的不同于基类的新方法。 这样需要用到向下转型，在Java中，所有的转型都会对其进行检查。称为“运行时类型识别”（RTTT）如果转型正确，则转型成功；如果所转类型不是正确的类型，则转型失败，返回ClassCastException异常。 父类引用可以指向子类对象，子类引用不可以指向父类对象 12345678910111213141516171819202122232425class Useful &#123;public void f() &#123;&#125;public void g() &#123;&#125;&#125;class MoreUseful extends Useful &#123;public void f() &#123;&#125;public void g() &#123;&#125;public void u() &#123;&#125;public void v() &#123;&#125;public void w() &#123;&#125;&#125;public class RTTI &#123;public static void main(String[] args) &#123;Useful[] x = &#123;new Useful(),new MoreUseful()&#125;;x[0].f();x[1].g();// Compile time: method not found in Useful://! x[1].u();((MoreUseful)x[1]).u(); // Downcast/RTTI((MoreUseful)x[0]).u(); // Exception thrown&#125;&#125; 参考资料 https://blog.csdn.net/severusyue/article/details/51721940 Java编程思想第四版读书笔记——第八章 多态 severusyue]]></content>
      <categories>
        <category>书籍</category>
        <category>java</category>
        <category>java编程思想第四版</category>
      </categories>
      <tags>
        <tag>书籍</tag>
        <tag>java</tag>
        <tag>java编程思想第四版</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[EffectiveJava第三版第二条读书笔记]]></title>
    <url>%2Fblog%2F2019%2F01%2F14%2FEffectiveJava%E7%AC%AC%E4%B8%89%E7%89%88%E7%AC%AC%E4%BA%8C%E6%9D%A1%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[前言 自己java编程已有两年，自己也写过一些轮子，也在工作中针对自己以前写的代码重构过，但是距离那些优秀的类库总有一些差距，最近在看 Effective Java 第三版，书中总结甚为精辟，遂在阅读过程中逐条写下笔记，以指导自己更加有效的使用 java 编程语言及基本类库,涵盖部分jdk 7,8,9 的新特性 目的 Consider a builder when faced with many constructor parameters 遇到多个构造器参数时要考虑使用构建器 正文 例:用一个类表示包装食品外面显示的营养成分标签，其中有几个域是必须的 当有一个类需要多个参数的构造器，我们一般最开始考虑到的是重叠构造器 1234567891011121314151617181920212223242526272829303132333435363738394041424344// Telescoping constructor pattern - does not scale well! (Pages 10-11)不能很好的扩展public class NutritionFacts &#123; private final int servingSize; // (mL) required private final int servings; // (per container) required private final int calories; // (per serving) optional private final int fat; // (g/serving) optional private final int sodium; // (mg/serving) optional private final int carbohydrate; // (g/serving) optional public NutritionFacts(int servingSize, int servings) &#123; this(servingSize, servings, 0); &#125; public NutritionFacts(int servingSize, int servings, int calories) &#123; this(servingSize, servings, calories, 0); &#125; public NutritionFacts(int servingSize, int servings, int calories, int fat) &#123; this(servingSize, servings, calories, fat, 0); &#125; public NutritionFacts(int servingSize, int servings, int calories, int fat, int sodium) &#123; this(servingSize, servings, calories, fat, sodium, 0); &#125; public NutritionFacts(int servingSize, int servings, int calories, int fat, int sodium, int carbohydrate) &#123; this.servingSize = servingSize; this.servings = servings; this.calories = calories; this.fat = fat; this.sodium = sodium; this.carbohydrate = carbohydrate; &#125; public static void main(String[] args) &#123; //servingSize，servings,calories,fat,sodium,carbohydrate NutritionFacts cocaCola = new NutritionFacts(240, 8, 100, 0, 35, 27); &#125; &#125; 如上面 main 方法中的调用方法所示：假设我们需要设置 sodium 和 carbohydrate 的值，但是我们不想要设置 fat 的值，如上所见，所调用的构造器需要我们设置我们不想设置的参数，除非我们在编写一个构造器，内部用 set 方法初始化. 重叠构造器在有很多参数的时候，客户端代码会很难编写并且难以阅读，另外其本身也不能很好的扩展 那我们现在考虑更为普遍的一种方式: JavaBeans 12345678910111213141516171819202122232425262728// JavaBeans Pattern - allows inconsistency, mandates mutability (pages 11-12)允许不一致，强制要求可变性public class NutritionFacts &#123; // Parameters initialized to default values (if any) private int servingSize = -1; // Required; no default value private int servings = -1; // Required; no default value private int calories = 0; private int fat = 0; private int sodium = 0; private int carbohydrate = 0; public NutritionFacts() &#123; &#125; // Setters public void setServingSize(int val) &#123; servingSize = val; &#125; public void setServings(int val) &#123; servings = val; &#125; public void setCalories(int val) &#123; calories = val; &#125; public void setFat(int val) &#123; fat = val; &#125; public void setSodium(int val) &#123; sodium = val; &#125; public void setCarbohydrate(int val) &#123; carbohydrate = val; &#125; public static void main(String[] args) &#123; NutritionFacts cocaCola = new NutritionFacts(); cocaCola.setServingSize(240); cocaCola.setServings(8); cocaCola.setCalories(100); cocaCola.setSodium(35); cocaCola.setCarbohydrate(27); &#125;&#125; JavaBeans 方法的缺点： 12由于 JavaBeans 方式将构造过程分隔到了几个调用过程中，在构造过程中 JavaBeans 可能处于不一致的状态，无法仅仅通过检查构造器参数的有效性在保证一致性JavaBeans 模式使得把类做成不可变的可能性不复存在，也就是说可能存在线程安全问题 那么这里我们扩展一下 SpringMVC 中的单例模式，我们知道 controller -&gt; service -&gt; dao 这个流程，他们的对象都是单例的，想想一下这些单例的对象在处理我们传给后台的实体 bean 时会不会有问题了？如果一个张三带着正确密码在登陆的同时，一个李四在登陆，如果是单例并且状态可变，那么最后校验是张三和李四的密码导致他登陆失败？ 答：是不会有问题的，因为我们的实体bean是前台的json串反序列化，或者我们自己 new,然后拼装起来的，所以他并不是单例模式。另外这也说明单例模式中存在可变域可能导致线程不安全，因此 1.在 controller 类中不要定义非单例成员变量 2.万一必须要定义一个非静态成员变量时候，则通过注解@Scope(“prototype”)，将其设置为多例模式 另外上网查了下(未验证)了 JavaBeans 的反序列化的三种工具：fastJson JackJson 以及 Gson 123Gson是通过反射遍历该类中的所有属性，并把其值序列化成json三个工具类的序列化结果跟类的set方法没有关系。JackJson和FastJson序列化结果跟get方法有关系 第三种方法就是建造者模式 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859public class NutritionFacts &#123; //必须域 private final int servingSize; //必须域 private final int servings; //卡路里 private final int calories; //脂肪 private final int fat; //钠 private final int sodium; //糖类 private final int carbohydrate; public static class Builder &#123; // Required parameters private final int servingSize; private final int servings; // Optional parameters - initialized to default values private int calories = 0; private int fat = 0; private int sodium = 0; private int carbohydrate = 0; //必须参数通过唯一构造器初始化 public Builder(int servingSize, int servings) &#123; this.servingSize = servingSize; this.servings = servings; &#125; public Builder calories(int val) &#123; calories = val; return this; &#125; public Builder fat(int val) &#123; fat = val; return this; &#125; public Builder sodium(int val) &#123; sodium = val; return this; &#125; public Builder carbohydrate(int val) &#123; carbohydrate = val; return this; &#125; public NutritionFacts build() &#123; return new NutritionFacts(this); &#125; &#125; private NutritionFacts(Builder builder) &#123; servingSize = builder.servingSize; servings = builder.servings; calories = builder.calories; fat = builder.fat; sodium = builder.sodium; carbohydrate = builder.carbohydrate; &#125; public static void main(String[] args) &#123; NutritionFacts cocaCola = new NutritionFacts.Builder(240, 8) .calories(100).sodium(35).carbohydrate(27).build(); &#125;&#125; 从上面的链式调用可以发现，这样做确实比较优雅，但是他开销比较大。由于上面的这个建造器的属性都设置的final,所以在建造后就无法在修改了？这里有几个疑问？ 1.建造器模式是否只是应用于不可变类？ 2.假设我们要对建造器模式类中的一个属性值在建造后重新赋值，我们怎么做？将 final 去掉，提供 setter 方法吗？如果这样，它和静态内部类中的对应属性是否就不一致了，而且 api 混乱，导致初始化域的方法有两个？ 3.建造器模式的序列化和反序列化？还是上一个问题，静态内部类的属性和建造器内的属性是否需要保持一致，如果是利用 fastjson 的话，内部和外部都得提供 getter 方法，如此种种，感觉建造器模式还是适合工具类，不太适合 web 中的 javabeans,比如表单。尽管可能提供多个参数的构造方法 4.由建造器模式的链式调用想到 JavaBeans 的 setter 方法为什么不return this了，这样就可以链式调用了？ 比如 guava 中 Ordering 的链式调用 123456789101112131415161718192021222324252627282930313233343536373839/** * creambing.com Inc. * Copyright (c) 2016-2017 All Rights Reserved. */package com.creambing;import com.google.common.collect.Ordering;import org.junit.Assert;import org.junit.Test;import java.util.Arrays;import java.util.Collections;import java.util.List;import static org.hamcrest.core.IsEqual.equalTo;/** * Class Name:BuilderModeTest * Description:建造者模式测试 * * @author Bing * @create 2019-01-14 16:05 * @version v1.0 */public class BuilderModeTest &#123; /** * 将空值放置在最前面的情况 */ @Test public void testOrderNaturalByNullFirst() &#123; List&lt;Integer&gt; list = Arrays.asList(1, 5, null, 3, 8, 2); Collections.sort(list, Ordering.natural().nullsFirst()); System.out.println("空在最前面-排序后" + list.toString()); Assert.assertThat(list.toString(),equalTo("[null, 1, 2, 3, 5, 8]")); &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536类的定义public abstract class Ordering&lt;T&gt; implements Comparator&lt;T&gt; &#123;&#125;@GwtCompatible( serializable = true)final class NaturalOrdering extends Ordering&lt;Comparable&gt; implements Serializable &#123;&#125;@GwtCompatible( serializable = true)final class NullsFirstOrdering&lt;T&gt; extends Ordering&lt;T&gt; implements Serializable &#123;&#125;Ordering抽象类中的静态方法，返回他的子类NaturalOrdering的一个实例，这是个饿汉式不可变单例@GwtCompatible( serializable = true ) public static &lt;C extends Comparable&gt; Ordering&lt;C&gt; natural() &#123; return NaturalOrdering.INSTANCE; &#125;NaturalOrdering中的成员变量static final NaturalOrdering INSTANCE = new NaturalOrdering();Ordering抽象类中的一个公共方法@GwtCompatible( serializable = true ) public &lt;S extends T&gt; Ordering&lt;S&gt; nullsFirst() &#123; return new NullsFirstOrdering(this); &#125;NaturalOrdering中的重写了public &lt;S extends Comparable&gt; Ordering&lt;S&gt; nullsFirst() &#123; Ordering&lt;Comparable&gt; result = this.nullsFirst; if (result == null) &#123; result = this.nullsFirst = super.nullsFirst(); &#125; return result; &#125; 从上可以看到跟构造器关系不大，更符合第一点，用静态工厂方法代替构造器，基于接口编程，初始化返回其子类对象,接着在调基类接口方法 参考资料]]></content>
      <categories>
        <category>书籍</category>
        <category>java</category>
        <category>EffectiveJava第三版</category>
      </categories>
      <tags>
        <tag>书籍</tag>
        <tag>java</tag>
        <tag>EffectiveJava第三版</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[EffectiveJava第三版第一条读书笔记]]></title>
    <url>%2Fblog%2F2019%2F01%2F14%2FEffectiveJava%E7%AC%AC%E4%B8%89%E7%89%88%E7%AC%AC%E4%B8%80%E6%9D%A1%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[前言 自己java编程已有两年，自己也写过一些轮子，也在工作中针对自己以前写的代码重构过，但是距离那些优秀的类库总有一些差距，最近在看 Effective Java 第三版，书中总结甚为精辟，遂在阅读过程中逐条写下笔记，以指导自己更加有效的使用 java 编程语言及基本类库,涵盖部分jdk 7,8,9 的新特性 目的 Consider static factory methods instead of constructors 用静态工厂方法代替构造器 正文 思考 对于类而言，为了让客户端获取它自身的一个实例，最传统的方法就是提供一个公有的构造器，但同时，你是否应该考虑提供一个公有的静态工厂方法，来返回此类的实例的静态方法? 提供静态工厂方法的优势 12345* 它们有名字,比起构造方法的不同参数列表，静态工厂方法能提供有含义且带有参数的初始化方法* 不用每次被调用时都创建新对象，例如单例模式* 可以返回原返回类型的子类，设计模式中的基本的原则之一—— 『里氏替换』 原则，就是说子类应该能替换父类。这项技术用于基于接口的框架，例如Collections Framework API* 返回的对象的类可以随着每次调用而发生变化，这取决于静态工厂方法的参数值。例如EnumSet* 方法返回的对象所属的类，在编写包含该静态工厂方法的类时，可以不存在，构成了服务提供者框架(Service Provider Framework)例如 JDBC API 我们现在对每条优点来实践一下 1.它们有名字 假设我们有一个苹果类 (Appale.java) 它有三个属性:颜色(color)，重量(weight)和是否好吃(delicious) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119/** * creambing.com Inc. * Copyright (c) 2016-2017 All Rights Reserved. */package com.creambing.effectivejava;/** * Class Name:Apple * Description:静态工厂代替构造器 * * @author Bing * @create 2019-01-14 11:32 * @version v1.0 */public class Apple &#123; //设为final表示一旦建造成功不许修改 //这里不能设为final,因为final定义的要不在定义时候初始化，要不在构造器初始化 private Color color; private int weight;//单位为g private boolean delicious;//是否好吃 true:好吃，false:不好吃 private Apple() &#123; &#125; //作为例子讲解，本应注释掉 public Apple(Color color, int weight) &#123; this.color = color; this.weight = weight; &#125; //作为例子讲解，本应注释掉 public Apple(Color color, int weight, boolean delicious) &#123; this.color = color; this.weight = weight; this.delicious = delicious; &#125; public Color getColor() &#123; return color; &#125; public void setColor(Color color) &#123; this.color = color; &#125; public int getWeight() &#123; return weight; &#125; public void setWeight(int weight) &#123; this.weight = weight; &#125; public boolean isDelicious() &#123; return delicious; &#125; public void setDelicious(boolean delicious) &#123; this.delicious = delicious; &#125; //**********上面的是一个标准的 javabeans 除了将无参构造器设置为私有的********************************************* public static Apple newInstance()&#123; return new Apple(); &#125; public static Apple createRedDelicious()&#123; return Apple.newInstance().withColor(Color.RED).withDelicious(Boolean.TRUE); &#125; public static Apple createRedNoDelicious()&#123; return Apple.newInstance().withColor(Color.RED).withDelicious(Boolean.FALSE); &#125; //********************上面提供了三个静态工厂方法，很明显意义更加明确而且用户不会调用出错，封装性更好****************** //那这个跟set方法没什么区别了 public Apple withColor(Color c)&#123; this.color = c; return this; &#125; public Apple withWeight(int w)&#123; this.weight = w; return this; &#125; public Apple withDelicious(Boolean b)&#123; this.delicious = b; return this; &#125; //*******************为了不破坏 javabeans 规范，又达到链式调用的目的，新增的一系列 withxxx() 方法****************** @Override public String toString() &#123; return "Apple&#123;" + "color=" + color + ", weight=" + weight + '&#125;'; &#125; public enum Color&#123; RED,GREEN &#125; public static void main(String[] args) &#123; //设置一个5克的绿色苹果 Apple a = Apple.newInstance().withColor(Color.GREEN).withWeight(5); System.out.println(a); //设置一个好吃的红苹果,直接将好吃和不好吃封装到了api里面，通过函数名字表示，用户就很难调用错误的方法 Apple a1 = Apple.createRedDelicious(); //我不得不传一个重量的参数，虽然 0g 的红苹果现实没意义，但是如果是其它可选参数了，另外第三个参数我们也有可能写错，到底是ture好吃，还是false好吃，我们不得不去看api Apple a2 = new Apple(Color.RED,0,Boolean.TRUE); &#125;&#125; 类中的注释很好的说明了问题，另外调用时候的意义也更加明确 1234//设置一个好吃的红苹果,直接将好吃和不好吃封装到了api里面，通过函数名字表示，用户就很难调用错误的方法Apple a1 = Apple.createRedDelicious();//我不得不传一个重量的参数，虽然 0g 的红苹果现实没意义，但是如果是其它可选参数了，另外第三个参数我们也有可能写错，到底是ture好吃，还是false好吃，我们不得不去看apiApple a2 = new Apple(Color.RED,0,Boolean.TRUE); 2.单例模式 这里可以看一下之前在读java编程思想-类的访问权限的时候所做的笔记:java编程思想第四版第六章读书笔记 3.基于接口的框架 例如 jdk 中 java.util.Collections.java 类其中的很多方法就是返回类型是一个接口，其真正返回的是它的子类对象 123public static &lt;T&gt; Collection&lt;T&gt; unmodifiableCollection(Collection&lt;? extends T&gt; c) &#123; return new UnmodifiableCollection&lt;&gt;(c); &#125; 扩展:https://blog.csdn.net/cilen/article/details/7744969 Collections.unmodifiableList方法的使用与场景 4.返回的对象的类可以随着每次调用而发生变化，这取决于静态工厂方法的参数值 例如 jdk 中 EnumSet 的noneOf方法 123456789public static &lt;E extends Enum&lt;E&gt;&gt; EnumSet&lt;E&gt; noneOf(Class&lt;E&gt; elementType) &#123; Enum&lt;?&gt;[] universe = getUniverse(elementType); if (universe == null) throw new ClassCastException(elementType + &quot; not an enum&quot;); if (universe.length &lt;= 64) return new RegularEnumSet&lt;&gt;(elementType, universe); else return new JumboEnumSet&lt;&gt;(elementType, universe);&#125; 5.方法返回的对象所属的类，在编写包含该静态工厂方法的类时，可以不存在，构成了服务提供者框架(Service Provider Framework)例如 JDBC API TODO:等我看了相关api再来记录 提供静态工厂方法的缺点 12* .类如果不含有公有的或者受保护的构造器，就不能被子类化* .程序员很难发现它们 常用静态工厂方法的取名 1234567891011* from: 类型转化方法 * of: 聚合方法，带有多个参数，返回该类型的一个实例，把它们合并起来 * valueOf：该方法返回的实例与它的参数具有相同的 “值” 。 * getType：返回的类型是根据方法的参数来描述的，但是不能够说与参数具有相同的值。就像是针对类型的getInstance，但是在工厂方法处于不同的类中的时候使用 * newType：像newInstance一样，但是在工厂方法处于不同的类中的时候使用 * type: getType和newType的简版 * instance 或者 getInstance: 返回的实例是根据方法的参数来描述的，但是不能够说与参数具有相同的值。一般用来表示获取相同的实例，如单例模式，或根根参数获取不同的单例等。 * create 或者 newInstance：类似于getInstance。不同的是，一般用来表示获取新的实例，如Class#newInstance()方法等 * Class#newInstance()破坏了编译时的检查： * newInstance方法总是企图调用类的无参构造器。这个构造器甚至可能根本不存在，或者用户无访问权限，但编译期间你不会收到任何错误 * newInstance方法还会传播由无参构造器抛出的任何异常，即使newInstance缺乏相应的throws子句 梨子: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384/** * https://creambing.github.io Inc. * Copyright(c)2018-2025 All Rights Reserved. */package com.creambing.effectivejava3;import com.google.common.collect.Maps;import java.util.EnumSet;import java.util.HashMap;import java.util.Map;/** * Class Name: StaticFactory * Description: 考虑用静态工厂方法代替构造器 * 优势: * 它们有名字,比起构造方法的不同参数列表，静态工厂方法能提供有含义且带有参数的初始化方法 * 不用每次被调用时都创建新对象，例如单例模式 * 可以返回原返回类型的子类，设计模式中的基本的原则之一—— 『里氏替换』 原则，就是说子类应该能替换父类。这项技术用于基于接口的框架，例如Collections Framework API * 返回的对象的类可以随着每次调用而发生变化，这取决于静态工厂方法的参数值。例如EnumSet * 方法返回的对象所属的类，在编写包含该静态工厂方法的类时，可以不存在，构成了服务提供者框架(Service Provider Framework)例如 JDBC API * *缺点 * 1.类如果不含有公有的或者受保护的构造器，就不能被子类化 * 2.程序员很难发现它们 * * 静态工厂方法惯用名称： * from: 类型转化方法 * of: 聚合方法，带有多个参数，返回该类型的一个实例，把它们合并起来 * valueOf：该方法返回的实例与它的参数具有相同的 “值” 。 * getType：返回的类型是根据方法的参数来描述的，但是不能够说与参数具有相同的值。就像是针对类型的getInstance，但是在工厂方法处于不同的类中的时候使用 * newType：像newInstance一样，但是在工厂方法处于不同的类中的时候使用 * type: getType和newType的简版 * instance 或者 getInstance: 返回的实例是根据方法的参数来描述的，但是不能够说与参数具有相同的值。一般用来表示获取相同的实例，如单例模式，或根根参数获取不同的单例等。 * create 或者 newInstance：类似于getInstance。不同的是，一般用来表示获取新的实例，如Class#newInstance()方法等 * Class#newInstance()破坏了编译时的检查： * newInstance方法总是企图调用类的无参构造器。这个构造器甚至可能根本不存在，或者用户无访问权限，但编译期间你不会收到任何错误 * newInstance方法还会传播由无参构造器抛出的任何异常，即使newInstance缺乏相应的throws子句 * * author: CreamBing * time: 2019-01-13 14:53 * version: v1.0.0 */public class StaticFactory &#123; /** * 需要引入依赖 * &lt;dependency&gt; * &lt;groupId&gt;com.google.guava&lt;/groupId&gt; * &lt;artifactId&gt;guava&lt;/artifactId&gt; * &lt;version&gt;27.0.1-jre&lt;/version&gt; * &lt;/dependency&gt; * @param args */ public static void main(String[] args) &#123; //不过自从 java7 开始,由于泛型参数是可以被推导出，所以可以在创建实例时省略掉泛型参数。 Map&lt;String,String&gt; map = new HashMap&lt;&gt;(); //google guava类库 我们来看看别人类库是怎么封装的 /* public static &lt;K, V&gt; HashMap&lt;K, V&gt; newHashMap() &#123; return new HashMap(); &#125; */ Map&lt;String,String&gt; map1 = Maps.newHashMap(); /* * public static &lt;E extends Enum&lt;E&gt;&gt; EnumSet&lt;E&gt; noneOf(Class&lt;E&gt; elementType) &#123; Enum&lt;?&gt;[] universe = getUniverse(elementType); if (universe == null) throw new ClassCastException(elementType + " not an enum"); if (universe.length &lt;= 64) return new RegularEnumSet&lt;&gt;(elementType, universe); else return new JumboEnumSet&lt;&gt;(elementType, universe); &#125; * */ //jdk8内部实现,它返回两种子类之一的一个实例，取决于传入枚举类型的大小 EnumSet&lt;Season&gt; enumSet = EnumSet.of(Season.SUMMER, Season.WINTER); &#125; enum Season &#123; SPRING, SUMMER, FALL, WINTER &#125;&#125; 参考资料 https://blog.csdn.net/cilen/article/details/7744969 Collections.unmodifiableList方法的使用与场景 cilen]]></content>
      <categories>
        <category>书籍</category>
        <category>java</category>
        <category>EffectiveJava第三版</category>
      </categories>
      <tags>
        <tag>书籍</tag>
        <tag>java</tag>
        <tag>EffectiveJava第三版</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java编程思想第四版第七章读书笔记]]></title>
    <url>%2Fblog%2F2019%2F01%2F13%2Fjava%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E7%AC%AC%E5%9B%9B%E7%89%88%E7%AC%AC%E4%B8%83%E7%AB%A0%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[前言 最近一段时间重读了java编程思想，把一些东西重新理解记录一遍 目的 整理知识点，方便以后回顾，这一章主要讲解了java的复用类 正文 1.组合语法 满足has-a关系 在类中，创建一个其它类的对象，使用该对象的一些方法，对这个对象进行操作。 类中域为基本类型时能自动被初始化为0，对象引用会被初始化为Null。 初始化类中的引用，可以在四种情况下进行： 1、在定义对象的地方（在类的构造器调用之前就初始化了） 2、在类的构造器中 3、在需要使用这些对象之前（惰性初始化） 4、使用实例初始化 2.继承语法 使用继承我们一般认为导出类是一个或者像是一个，满足is-a或者is-like-a的关系，例如圆形是一个几何形 当创建一个导出类对象时，该对象包含了一个基类子对象。当初始化时，构造器的调用遵循由内到外的顺序，默认情况下调用基类的无参构造器，基类构造器都有参时，可以用super(“参数”)显式的调用基类构造器。 3.代理 代理和组合就是不满足继承关系，他们是包含关系，比如飞机包含控制系统 当一个类并不是另一个类的子类型，却要完全或部分用到另一个类的全部方法时，可以用代理。 在类Ship中创建另一个类的对象controls，然后构造所需要的全部方法，在方法里只需要使用相应的controls.方法。即可使用对象类的所有方法。 4.结合使用组合和继承 虽然编译器强制初始化基类，但是不强制初始化成员对象，所有在用组合的时候应该注意要自己初始化成员对象。 可以使用try finally强制对内存进行回收清理，自己编写函数回收内存，此时回收顺序是由外向内，最后使用super.dispose()回收基类内存。 Java中导出类重载某个基类方法，它并不会屏蔽其在基类中的任何版本，也就是在参数列表类型符合的情况下，基类中的该方法依旧可用。 @override是覆写关键字，如果添加这个注解而错误的重载（没有覆写）该方法，那么编译器会报错。 覆写（override）：函数名一样，返回值类型，参数列表类型都一样。子类函数的访问权限不能小于父类。 重载（overlode）：函数名一样，参数列表不一样，返回值类型可以相同也可以不同。 以上两种都是程序多态性的体现。 自己编写清理方法，不要使用finalize();1.可能永远不会调用，即使被调用也是按照他想要的顺序来回收 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155/** * Class Name: Share * Description: 清理，用来记录引用计数 * * author: CreamBing * time: 2019-01-11 14:32 * version: v1.0.0 */public class Share &#123; private int refcount = 0; private static long counter = 0; private final long id = ++counter; public Share() &#123; System.out.println("create"+this); &#125; public void addRef()&#123; refcount++; &#125; public int getRefcount() &#123; return refcount; &#125; protected void dispose()&#123; if(--refcount==0)&#123; System.out.println("dispose"+this); &#125; &#125; @Override public String toString() &#123; return "Share&#123;" + "refcount=" + refcount + ", id=" + id + '&#125;'; &#125; public static void main(String[] args) &#123; Share s1 = new Share(); Share s2 = new Share(); System.out.println("**********"); System.out.println(s1); System.out.println("************"); System.out.println(s2); &#125;&#125;/** * https://creambing.github.io Inc. * Copyright(c)2018-2025 All Rights Reserved. *//** * Class Name: Composing * Description: 共享类 * * author: CreamBing * time: 2019-01-11 14:42 * version: v1.0.0 */public class Composing &#123; private Share share; private static long count = 0; private final long id = ++count; public Composing(Share share) &#123; this.share = share; this.share.addRef(); System.out.println("create "+this); &#125; protected void dispose()&#123; System.out.println("dispose "+this); share.dispose(); &#125; @Override public String toString() &#123; return "Composing&#123;" + "share=" + share + ", id=" + id + '&#125;'; &#125;&#125;/** * Class Name: ReferenceCounting * Description: 对象引用计数 * &lt;p&gt; * author: CreamBing * time: 2019-01-11 14:48 * version: v1.0.0 */public class ReferenceCounting &#123; Share s1 = new Share(); Composing[] ca; public ReferenceCounting() &#123; this.ca = new Composing[]&#123;new Composing(s1), new Composing(s1), new Composing(s1)&#125;; &#125; @Override protected void finalize() throws Throwable &#123; if (s1.getRefcount() != 0) &#123; System.out.println("Composing没有清理干净，还有实例引用Share"); &#125; else &#123; System.out.println("Composing清理干净，开始垃圾回收"); super.finalize(); &#125; &#125; /** * createShare&#123;refcount=0, id=1&#125; * create Composing&#123;share=Share&#123;refcount=1, id=1&#125;, id=1&#125; * create Composing&#123;share=Share&#123;refcount=2, id=1&#125;, id=2&#125; * create Composing&#123;share=Share&#123;refcount=3, id=1&#125;, id=3&#125; * dispose Composing&#123;share=Share&#123;refcount=3, id=1&#125;, id=1&#125; * c[0] dispose * 开始强制垃圾回收 * ************************************* * dispose Composing&#123;share=Share&#123;refcount=2, id=1&#125;, id=2&#125; * dispose Composing&#123;share=Share&#123;refcount=1, id=1&#125;, id=3&#125; * disposeShare&#123;refcount=0, id=1&#125; * ca[1],ca[2]清理，所有Composing对象清理完毕 * 开始强制垃圾回收 * Composing清理干净，开始垃圾回收 * 注释掉********************************后面的东西 * createShare&#123;refcount=0, id=1&#125; * create Composing&#123;share=Share&#123;refcount=1, id=1&#125;, id=1&#125; * create Composing&#123;share=Share&#123;refcount=2, id=1&#125;, id=2&#125; * create Composing&#123;share=Share&#123;refcount=3, id=1&#125;, id=3&#125; * dispose Composing&#123;share=Share&#123;refcount=3, id=1&#125;, id=1&#125; * c[0] dispose * 开始强制垃圾回收 * ************************************* * Composing没有清理干净，还有实例引用Share * @param args */ public static void main(String[] args) &#123; ReferenceCounting r = new ReferenceCounting(); r.ca[0].dispose(); System.out.println("c[0] dispose"); System.out.println("开始强制垃圾回收"); System.runFinalizersOnExit(true); System.out.println("*************************************"); r.ca[1].dispose(); r.ca[2].dispose(); System.out.println("ca[1],ca[2]清理，所有Composing对象清理完毕"); System.out.println("开始强制垃圾回收"); System.runFinalizersOnExit(true); &#125;&#125; 5.在组合和继承之间选择 is-a 继承 hsa -a 组合 6.protected关键字 关键字protected表明，就类用户而言，它是private的，就继承自此类的导出类或者其它位于同一个包的类来说，它是可以访问的。 最好将域保持为private的，保留更改底层实现的权利。然后通过protected方法控制类的继承者的访问权限。 7.向上转型 将导出类转型成基类，继承要慎用，需要向上转型时，推荐使用继承。 向上转型会丢失方法和域 8.final关键字 final数据： 对于基本类型，final使数值恒定不变。对于对象的引用，final使引用恒定不变，但是对象自身是可以修改的。注意:数组也是一种引用。 带有恒定初值（即：编译期常量）的final static 基本类型全用大写命名，并且字与字之间用下划线隔开。 必须在域的定义处或者构造器中用表达式对final进行赋值，这真是final域在使用前总是初始化的原因。 final参数： 在函数参数列表中的final参数，在函数内无法修改它 f(final int i){ i++; } //非法 final方法： 使用场景： 1、把方法锁定，防止继承类修改，覆盖它。 2、提高效率。（逐渐淘汰） 类中所有的private方法都隐式地指定为final的。因为private方法无法被外界取用，所以并不算基类接口的一部分，所以尽管导出类含有相同名称的方法，但是互不干扰，也没有覆盖。 final类： 使用场景： 不可以作为基类被继承。 9.初始化及类的加载 类的代码在初次使用时才会被加载，通常是指加载发生在创建类的第一个对象之时，在访问static域或static方法时，也会发生加载。 注意，只要加载包含static方法的类，static初始化就会执行。注意子类创建对象调用构造器时基类构造器也会被调用，此时基类会被加载，基类的static将会被初始化。 基类staitic–&gt;子类static–&gt;基类基本类型设为默认值0，对象引用被设为Null–&gt;基类构造器–&gt;子类基本类型设为默认值0，对象引用被设为Null–&gt;子类构造器 总结 继承和组合都是从现有类型生成新类型，组合一般是将现有类型作为新类型的底层实现的一部分来加以复用，而继承复用的是接口，这对多态来说至关重要，所以分析一个系统的时候应该弄清楚那些是is-a,那些是has=a关系 参考资料 https://blog.csdn.net/severusyue/article/details/49274695 Java编程思想第四版读书笔记——第七章 复用类 severusyue]]></content>
      <categories>
        <category>书籍</category>
        <category>java</category>
        <category>java编程思想第四版</category>
      </categories>
      <tags>
        <tag>书籍</tag>
        <tag>java</tag>
        <tag>java编程思想第四版</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java编程思想第四版第六章读书笔记]]></title>
    <url>%2Fblog%2F2019%2F01%2F13%2Fjava%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E7%AC%AC%E5%9B%9B%E7%89%88%E7%AC%AC%E5%85%AD%E7%AB%A0%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[前言 最近一段时间重读了java编程思想，把一些东西重新理解记录一遍 目的 整理知识点，方便以后回顾，这一章主要讲解了java的访问权限控制 正文 1.包:库单元 Java代码文件，也可以成为编译单元（有时也成为转译单元）。 编译单元内有一个public类，该类名称必须与文件名称相同。 每个编译单元只能有一个public类。 Java包命名规则是必须全是小写字母。 package和import将单一的全局名字空间分开，使得不会出现名称冲突问题。 想要使用某类，需要指定全名或者使用import关键字，import可以使用该包中的public类。 使用静态导入 import static可以在系统中使用包中静态的方法。 jdk5之前需要设置classpath,那是因为引入jar需要指定jar的具体目录，因为java编译需要调用javac,5之前依赖tools.jar，相当与&quot;javac -Calsspath=%JAVA_HOME%\lib\tools.jar xx.xxx.Main XXX.java&quot;所以需要设置，jdk5之后不建议设置classpath,设置javahome的原因也是方便命令的输入 2.Java访问权限修饰词 访问权限： 不加修饰词，就是包访问权限。包内所有其他类对那个成员都有访问权限。对包外类都是private。 取得某成员访问权限的唯一途径是： 1、该成员是public 2、不加权限修饰词并将其他类放在同一个包内，包内其它成员可访问此成员。 3、继承而来的类既可以访问public又可以访问protected。 4、通过访问器和变异器方法（get/set方法），以读取和改变值。 public:接口访问权限： 任何人都可以访问它。不同包里的都可以。 默认包： 对于隶属于相同目录却没有给自己设定任何包名称的文件，Java默认其为该目录的默认包里，这样它们之间的包访问权限可以使它们互相访问。 private:私有 除了包含该类成员的类（这个private成员在的类）之外，任何其他类都无法访问这个成员。 好处： 1、可以控制如何创建该对象，别人必须使用特定构造器创建，例如单例模式，如果默认构造器是唯一并且是自己定义的private构造器，那么它可以防止被继承 2、对于辅助方法，可以指定其为private，防止误用它 protected:继承访问权限 protected成员除了只能被派生类使用外，还提供包访问权限。 3.接口和实现 访问权限的控制常被称为具体实现的隐藏，这被便是“封装”。 4.类的访问权限 1、每个编译单元（文件）只能有一个public类 2、public类的名称必须与文件名相匹配，包括大小写. 类只能是public或者包访问权限的，除了内部类 单例模式的五种实现方式 1.饿汉式(线程安全，调用效率高，但是不能延时加载) 1234567public class ImageLoader&#123; private static ImageLoader instance = new ImageLoader(); private ImageLoader()&#123;&#125; public static ImageLoader getInstance()&#123; return instance; &#125; &#125; 上来就把单例对象创建出来了，要用的时候直接返回即可，这种可以说是单例模式中最简单的一种实现方式。但是问题也比较明显。单例在还没有使用到的时候，初始化就已经完成了。也就是说，如果程序从头到位都没用使用这个单例的话，单例的对象还是会创建。这就造成了不必要的资源浪费。所以不推荐这种实现方式。 2.懒汉式(线程安全，调用效率不高，但是能延时加载)： 12345678910111213141516public class SingletonDemo2 &#123; //类初始化时，不初始化这个对象(延时加载，真正用的时候再创建) private static SingletonDemo2 instance; //构造器私有化 private SingletonDemo2()&#123;&#125; //方法同步，调用效率低 public static synchronized SingletonDemo2 getInstance()&#123; if(instance==null)&#123; instance=new SingletonDemo2(); &#125; return instance; &#125;&#125; 3.Double CheckLock实现单例：DCL也就是双重锁判断机制（由于JVM底层模型原因，偶尔会出问题，不建议使用） 1234567891011121314151617public class SingletonDemo5 &#123; private volatile static SingletonDemo5 SingletonDemo5; private SingletonDemo5() &#123; &#125; public static SingletonDemo5 newInstance() &#123; if (SingletonDemo5 == null) &#123; synchronized (SingletonDemo5.class) &#123; if (SingletonDemo5 == null) &#123; SingletonDemo5 = new SingletonDemo5(); &#125; &#125; &#125; return SingletonDemo5; &#125; &#125; 4.静态内部类实现模式（线程安全，调用效率高，可以延时加载） 12345678910111213public class SingletonDemo3 &#123; private static class SingletonClassInstance&#123; private static final SingletonDemo3 instance=new SingletonDemo3(); &#125; private SingletonDemo3()&#123;&#125; public static SingletonDemo3 getInstance()&#123; return SingletonClassInstance.instance; &#125; &#125; 5.枚举类（线程安全，调用效率高，不能延时加载，可以天然的防止反射和反序列化调用） 123456789public enum SingletonDemo4 &#123; //枚举元素本身就是单例 INSTANCE; //添加自己需要的操作 public void singletonOperation()&#123; &#125;&#125; 如何选用： -单例对象 占用资源少，不需要延时加载，枚举 好于 饿汉 -单例对象 占用资源多，需要延时加载，静态内部类 好于 懒汉式 5.总结 控制对成员的访问有两个原因： 1、是用户不要去触碰不该触碰的部分 2、让库类设计者可以改变类内部工作的方式，而不必担心对客户端程序员产生重大影响。 参考资料 https://blog.csdn.net/severusyue/article/details/49175943?utm_source=blogxgwz1 Java编程思想第四版读书笔记——第六章 访问权限控制 severusyue https://www.cnblogs.com/ngy0217/p/9006716.html java单例模式几种实现方式 点点积累]]></content>
      <categories>
        <category>书籍</category>
        <category>java</category>
        <category>java编程思想第四版</category>
      </categories>
      <tags>
        <tag>书籍</tag>
        <tag>java</tag>
        <tag>java编程思想第四版</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java编程思想第四版第五章读书笔记]]></title>
    <url>%2Fblog%2F2019%2F01%2F11%2Fjava%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E7%AC%AC%E5%9B%9B%E7%89%88%E7%AC%AC%E4%BA%94%E7%AB%A0%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[前言 最近一段时间重读了java编程思想，把一些东西重新理解记录一遍 目的 整理知识点，方便以后回顾，这一章主要讲解了java的初始化和清理 正文 1.用构造器确保初始化 使用构造器（constructor），在创建对象时初始化。分为带参数的初始化和不带参数的初始化。 构造器初始化之前会先进行域的初始化，基本类型和String会被给予相应默认值 2.方法重载 类型提升（向上提升）：int — long — float — double byte — short — int char — int 窄化转换：和向上提升反过来，注意先考虑降到byte再考虑char 返回值是无法区分重载方法的 3.默认构造器 没有构造器的时候，系统会自动生成一个无参的默认构造器。如果写了构造器，就别指望系统生成了，所以如果写了带参构造器，就不能无参初始化了。 另外只有私有构造器，该类无法继承 4.this关键字 this关键字只能在方法内部使用，表示对“调用方法的那个对象”的引用。 尽管可以用this调用一个构造器，但不能调用两个。当在一个构造器中调用另一个构造器时，需要用到this关键字。并且置于最起始处 将自身传递到外部方法，必须用this关键字 1234567891011121314151617181920public class Peeler &#123; //需要把工具类写出来 static Apple peel(Apple apple)&#123; System.out.println("皮削了"); return apple; &#125;&#125;public class Apple &#123; Apple getPeeled()&#123; return Peeler.peel(this); &#125; public static void main(String[] args) &#123; Apple a = new Apple(); a.getPeeled(); &#125;&#125; 除构造器外，编译器禁止在其他任何方法中调用构造器。 static方法是没有this的方法。所以有些人认为static方法不是“面向对象”的，这个概念还是有争议的 5.清理：终结处理和垃圾回收 垃圾回收器只知道释放那些经由new分配的内存。 123对象可能不被垃圾回收。垃圾回收不等于“析构”。垃圾回收只与内存有关（使用垃圾回收器的唯一原因就是回收程序不再使用的内存）。 不应该将finalize()作为统一的清理方法，因为它可能不被执行，这是一个陷阱。 无论是“垃圾回收”还是“终结”，都不保证一定会发生。 finalize()还有一个有趣的用法，它并不依赖于每次都要对finalize()进行调用，这就是对象“终结条件”的验证。 System.gc() 用于强制进行终结动作。比如 强制进入finalize（随着程序的运行也许程序自己也会调用这个方法），当某个关系的标记量有异，打印出来。可供程序员找出程序代码尤其是创建对象时隐晦的缺陷。 垃圾回收器如何工作： Java虚拟机采用一种自适应的垃圾回收技术。 要是没有新垃圾及产生，就会转换到 &quot;标记——清扫&quot;工作模式。 &quot;标记——清扫&quot;所依据的思路同样是从堆栈和静态存储区出发，遍历所有的引用，进而找出存活的对象，给对象一个标记。全部标记工作完成后，清理动作才会开始。 “停止——复制”的回收动作不是在后台运行的，它发生时，程序将会被暂停。它将所有活对象从旧堆复制到新堆，然后再释放旧堆中的对象所占内存。 如果所有对象都很稳定，垃圾回收器的效率降低，就切换到“标记——清扫”方式，同样，Java虚拟机会追踪“标记——清扫”的效果，如果堆空间出现很多碎片，就会切换回“停止——复制”方式。 Java虚拟机中有很多附加技术提升速度，比如“即时”编译器技术。这种技术将程序全部或部分翻译成本地机器码。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869public class Practice11 &#123; @Override protected void finalize() throws Throwable &#123; System.out.println("我被清理了"); super.finalize(); &#125; /** * output * Try 1: * Try 2: * Try 3: * Try 4: * 我被清理了 * @param args */ public static void main(String[] args) &#123; Practice11 p = new Practice11(); System.out.println("Try 1: "); System.runFinalization(); System.out.println("Try 2: "); Runtime.getRuntime().runFinalization(); System.out.println("Try 3: "); System.gc(); System.out.println("Try 4: "); // using deprecated since 1.1 method: System.runFinalizersOnExit(true); &#125;&#125;//用于终结条件的判断public class Practice12 &#123; //默认true,满的 private boolean flag=true; public Practice12(boolean flag) &#123; this.flag = flag; &#125; @Override protected void finalize() throws Throwable &#123; if(flag)&#123; System.out.println("我是满的,我被清理了"); super.finalize(); &#125;else &#123; System.out.println("我不是满的,我不清理"); &#125; &#125; /** * output * true * false * 我不是满的,我不清理 * 我是满的,我被清理了 * @param args */ public static void main(String[] args)throws Exception &#123; Practice12 p = new Practice12(true); Practice12 p1 = new Practice12(false); System.runFinalizersOnExit(true); Thread.sleep(10000); //貌似会保证引用调用完被清理 System.out.println(p.flag); System.out.println(p1.flag); &#125;&#125; 6.成员的初始化 所有变量在使用前都能得到适当的初始化。对于函数局部变量，Java以编译错误的形式强制初始化。不初始化编译就不成功。下面是各类型基本数据的初始值 123456789 boolean false char [ ] byte 0 short 0 int 0 long 0 float 0.0 double 0.0 reference null 7.构造器的初始化 无法阻止自动初始化的进行，它将在构造器被调用之前发生。因此，编译器不会强制一定在构造器某个地方或者在使用它们之前对元素进行初始化——因为初始化早已得到了保证。 静态数据初始化： 静态数据只占用一份存储区域。静态初始化只有在必要时候进行。只有在第一个类型对象创建（或第一次访问静态数据）的时候，他们才会被初始化。此后，静态对象不会再被初始化。 初始化顺序： 静态对象（只一次）——&gt; 非静态对象——&gt;构造器 可以使用静态块的方式，对静态对象成员进行初始化，放在static关键字后面，如下： 123456public class Spoon &#123; static int i; static &#123; i = 47; &#125; &#125; 非静态实例初始化： 12345678910111213public class Mug &#123; Mug mug1; Mug mug2; &#123; mug1 = new Mug(1); mug2 = new Mug(2); System.out.println("mug1 &amp; mug2 initialized"); &#125; Mug() &#123; &#125; Mug(int i) &#123; &#125;&#125; 如上，看起来比静态块少了个static关键字，它保证了每新建一个该类的对象，不论调用何种构造器，这些操作都会发生。实例初始化子句是发生在构造器之前执行.另外这种语法对于匿名内部类的初始化是必须的 8.数组初始化 注意数组的别名问题。 不确定在数组里需要多少个元素时，可以直接new。在运行时再创建。这里再提一下，数组元素中基本数据类型，数字和字符会被自动初始化为0，而布尔型会自动初始化为false。 Array.toString()方法属于java.util标准类库，它将产生一维数组的可打印版本。 试图使用数组中的空引用（null），则会在运行时产生异常。 可变参数列表(C通常称之为varags)： 所谓可变参数列表，可以理解为函数的参数列表中某类型的数量是不确定的。这个特性是在JavaSE5之后添加的。 12345static void printArray(Object... args) &#123; for(Object obj : args) System.out.print(obj + &quot; &quot;); System.out.println(); &#125; 有了可变参数，就不用显示的编写数组语法了，当指定参数，编译器会自动填充数组。也就是输入一个列表，编译器会自动将其转化为数组，作为可变参数列表接受。 0个参数传递给可变参数列表是可行的，当局有可选的尾随参数时，这一特性就会很有用。 对于如下方法： 123456 static void f(int required, String... trailing) &#123; System.out.print(&quot;required: &quot; + required + &quot; &quot;); for(String s : trailing) System.out.print(s + &quot; &quot;); System.out.println(); &#125; f(0)是可以代入的，尽管并没有String类型参数。 getClass()方法属于Object的一部分，它将产生对象的类，并且在打印该类时，可以看到该类型的编码字符串。前导[表示int类型。 它是这样用的： 1234static void g(int... args) &#123; System.out.print(args.getClass()); System.out.println(&quot; length &quot; + args.length); &#125; 输出是这样的： 12345 class [Ljava.lang.Character; length 1 class [Ljava.lang.Character; length 0 class [I length 1 class [I length 0 int[]: class [I 可以在单一的参数列表中将类型混合在一起，而自动包装机制将有选择的将Int提升为Integer。可变参数列表使重载变得复杂，编译器无法知道应该调用哪种方法。因此应当总是只在重载的一个版本上使用可变参数列表，或者压根不用。 数组初始化的几种方式 12345678910111213141516171819202122基本数据类型 int[] a = new int[10];//创建大小为10的int数组并自动初始化为零 int[] a1 = &#123;1,2&#125;;//创建并初始化 int[] a2 = new int[]&#123;1,2,4&#125;; int[] a3 = IntStream.of(1, 2, 3, 4, 5).toArray(); Arrays.stream(a).forEach(System.out::print); System.out.println(); Arrays.stream(a1).forEach(System.out::print); System.out.println(); Arrays.stream(a2).forEach(System.out::print); System.out.println();//对于包装类型 Integer[] b1 = &#123;1,2&#125;;//创建并初始化 Integer[] b2 = new Integer[]&#123;1,2,4&#125;; Integer[] b3 = Stream.of(1, 2, 3, 4, 5).toArray(Integer[]::new); //nullnullnullnullnullnullnullnullnullnull Integer[] b4 = new Integer[10]; //试图使用数组中的空引用，空指针异常 if(b4[0]==0)&#123; System.out.println(&quot;b4[0]==0&quot;); &#125; Stream.of(b4).forEach(System.out::print); 9.枚举类型 ava SE5添加了enum关键字 （枚举类型的实例都是常量，因此都用大写字母表示，如果有多个单词，就用下划线隔开。） 创建一个枚举类型： 123public enum Spiciness &#123; NOT,MILD,MEDIUM,HOT,FLAMING &#125; 创建enum实例： Spiciness howHot = Spiciness.MEDIUM; enum的一些特性： toString() 函数可以方便的显示某个实例的名字。 ordinal() 函数可以显示某个特定enum常量的申明顺序。 static values() 函数可以按照enum常量的申明顺序构成相应数组。 枚举类型可以配合switch case使用。 参考资料 https://blog.csdn.net/severusyue/article/details/48633599 Java编程思想第四版读书笔记——第五章 初始化与清理 severusyue]]></content>
      <categories>
        <category>书籍</category>
        <category>java</category>
        <category>java编程思想第四版</category>
      </categories>
      <tags>
        <tag>书籍</tag>
        <tag>java</tag>
        <tag>java编程思想第四版</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java编程思想第四版第四章读书笔记]]></title>
    <url>%2Fblog%2F2019%2F01%2F10%2Fjava%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E7%AC%AC%E5%9B%9B%E7%89%88%E7%AC%AC%E5%9B%9B%E7%AB%A0%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[前言 最近一段时间重读了java编程思想，把一些东西重新理解记录一遍 目的 整理知识点，方便以后回顾，这一章主要讲解了java的控制执行流程 正文 1.true和false Java不允许我们将一个数字作为布尔值使用，虽然这在C和C++里是允许的（在这些语句里，“真”是非零，“假”是零） 2.break和continue break用于强行退出循环，不执行循环中剩余的语句，只能跳出一层循环。而continue则停止执行当前的迭代（不执行本次循环的后续代码），然后退回循环起始处，开始下一次迭代。 3.臭名昭著的goto 不提倡使用goto，会给程序带来毁灭性灾害。 break和continue配合标签使用，效果更佳。 12345一般continue会返回最内层循环的开头（顶部），并继续执行。带标签的continue会达到标签的位置，并重新进入紧接在那个标签后面的循环。一般break会中断并跳出当前循环。带标签的break会中断并跳出标签所指的循环。在Java里需要使用标签的唯一理由就是因为有循 在Java里需要使用标签的唯一理由就是因为有循环嵌套存在，从而想从多层嵌套中break或continue。 4.switch switch中的选择因子必须是int或者char那样的整数值 参考资料 https://blog.csdn.net/severusyue/article/details/48632345?utm_source=blogxgwz5 Java编程思想第四版读书笔记——第四章 控制执行流程 severusyue]]></content>
      <categories>
        <category>书籍</category>
        <category>java</category>
        <category>java编程思想第四版</category>
      </categories>
      <tags>
        <tag>书籍</tag>
        <tag>java</tag>
        <tag>java编程思想第四版</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java编程思想第四版前三章读书笔记]]></title>
    <url>%2Fblog%2F2019%2F01%2F08%2Fjava%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E7%AC%AC%E5%9B%9B%E7%89%88%E5%89%8D%E4%B8%89%E7%AB%A0%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[前言 最近一段时间重读了java编程思想，把一些东西重新理解记录一遍 目的 整理知识点，方便以后回顾 正文 第一章 对象导论 1.抽象过程: 万物皆对象； 程序是对象的集合，它们通过发送消息来告知彼此所要做的； 每个对象都有自己的由其它对象构成的存储。 每个对象都有其类型，每个对象都是某个类的一个实例（instance）; 某一特定类型的所有对象都可以接受同样的消息。 2.每个对象都有一个接口 每个对象都只能满足某些请求，这些请求是由对象的接口（interface）所定义的，决定接口的便是类型。 3.每个对象都提供服务 将对象看做服务者可以提高对象的内聚性。高内聚性是软件设计的基本质量要求之一，可以将一个拥有很多功能的对象拆分成多个各司其职的对象。 4.被隐藏的具体实现 为什么要进行访问控制？ （1）让客户端程序员无法触及他们不该触及的部分——这些部分对于内部操作是必须的，但不是用户解决特定问题所需要的接口的一部分。减少客户端程序员需要考虑的东西，忽略不重要的东西。 （2）允许库设计者可以改变内部的工作方式而不用担心会影响到客户端程序员 5.复用具体实现 复用对象： （1）直接使用该类的对象； （2）创建一个成员对象； 使用现有的类合成新的类，称为“组合”，如果组合是动态发生的，则称为“聚合”。 在创建新类时，优先考虑组合，再考虑继承。 上面的关系可以解读如下: 123456(关联)Association：A类有B类有逻辑上的连接(聚合)Aggregation : A类有一个B类(组合)Composition : A类拥有一个B类(依赖)Dependency : A类使用了B类(继承)Inheritance : B类是一个A类 (或者B类扩展A类)(实现)Realization : B类实现了接口A 6.继承 导出类和基类具有相同的类型即一个圆也是一个几何形 有两种方法可以使基类和导出类产生差异 12直接在导出类中添加新方法，这些新方法并不是基类接口的一部分，应该考虑的是基类是否应该具备这些方法另一种更重要的使基类和导出类之间产生差异的方法是改变现有基类的方法，称为覆盖 “是一个”和“像是一个”的关系 如果继承只覆盖基类的方法，意味着导出类和基类是完全相同的类型，他们具有完全相同的接口，这被称为纯粹替代。某种意义上，是继承的理想方式，为is-a关系 如果继承在导出类必须添加新的接口元素，扩展了接口，这种替代并不完美，为is-like-a(像是一个)关系 7.伴随多态的可交互对象 将导出类看做它的基类的过程称为向上转型。 方法可以在不知道对象的实际类型时，做出正确的行为。 后期绑定 8.单根继承结构 除了C以外的所有OOP语言，所有类最终都继承自单一的基类。这个终极基类即Object; 单根继承使所有对象都具有统一的接口，给编程带来了更大的灵活性。 垃圾回收器的实现变的容易许多。 C如果这样，优点：额外的灵活性; 缺点：需要构建自己的继承体系，不兼容 9.容器 不同的容器提供了不同类型的接口和外部行; 不同的容器对于某些操作具有不同的效率 为了避免向下转型为错误的类型，因此有了参数化类型机制，参数化类型就是一个编译器可以自动定制用于特定类型上的类。 10.对象的创建和生命周期 对象的创建 C++认为效率控制是最重要的议题，在堆栈或者静态存储区域创建对象。 Java在创建对象的时候可以不用知道对象的确切数量，生命周期和类型。 Java完全采用了动态内存分配的方式。它认为对象变得复杂后，查找和释放存储空间的开销就不那么那么重要了。提高灵活性，牺牲了时间。 对象的生命周期 Java提供了“垃圾回收器”机制，可以自动发现对象何时不再被使用，继而销毁它。 垃圾回收器可以避免内存溢出的问题。 11.异常处理：处理错误 异常是一种对象，它从出错地点被“抛出”，并被专门设计用来处理特定类型错误的相应的异常处理器“捕获”。 异常不能忽略，所以它保证一定会在某处得到处理。它提供了一种从错误状况进行可靠恢复的路径。异常处理不是面向对象的特征。 12.并发编程 使用线程，但是可能遇到一个隐患，就是共享资源的问题。 某个任务锁定某项资源，完成其任务，然后释放资源锁，使其它任务可以使用这项资源。 13.Java与Internet 客户/服务器系统的核心思想是：系统具有一个中央信息存储池，用来存储某种数据，它通常位于数据库中，你可以根据需要将它分发给某些人员或机器集群。 信息存储池、用于分发信息的软件以及消息与软件所驻留的机器或机群被称为服务器; 第二章 一切都是对象 1.用引用操作对象 字符串可以用带引号的文本初始化 2.必须由你创建所有对象 (1) 寄存器。这是最快的保存区域，因为它位于和其他所有保存方式不同的 地方：处理器内部。然而，寄存器的数量十分有限，所以寄存器是根据需要由编 译器分配。我们对此没有直接的控制权，也不可能在自己的程序里找到寄存器存 在的任何踪迹。 (2) 堆栈。驻留于常规 RAM（随机访问存储器）区域，但可通过它的“堆栈 指针”获得处理的直接支持。堆栈指针若向下移，会创建新的内存；若向上移， 则会释放那些内存。这是一种特别快、特别有效的数据保存方式，仅次于寄存器。 创建程序时，Java 编译器必须准确地知道堆栈内保存的所有数据的“长度”以 及“存在时间”。这是由于它必须生成相应的代码，以便向上和向下移动指针。 这一限制无疑影响了程序的灵活性，所以尽管有些 Java 数据要保存在堆栈里— —特别是对象句柄，但 Java 对象并不放到其中。 (3) 堆。一种常规用途的内存池（也在 RAM 区域），其中保存了 Java 对象。 和堆栈不同，“内存堆”或“堆”（Heap）最吸引人的地方在于编译器不必知道 要从堆里分配多少存储空间，也不必知道存储的数据要在堆里停留多长的时间。 因此，用堆保存数据时会得到更大的灵活性。要求创建一个对象时，只需用 new 命令编制相关的代码即可。执行这些代码时，会在堆里自动进行数据的保存。当 然，为达到这种灵活性，必然会付出一定的代价：在堆里分配存储空间时会花掉 更长的时间！ (4) 静态存储。这儿的“静态”（Static）是指“位于固定位置”（尽管也在 RAM 里）。程序运行期间，静态存储的数据将随时等候调用。可用 static 关键字 指出一个对象的特定元素是静态的。但 Java 对象本身永远都不会置入静态存储 空间。 (5) 常数存储。常数值通常直接置于程序代码内部。这样做是安全的，因为 它们永远都不会改变。有的常数需要严格地保护，所以可考虑将它们置入只读存 储器（ROM）。 (6) 非 RAM 存储。若数据完全独立于一个程序之外，则程序不运行时仍可 存在，并在程序的控制范围之外。其中两个最主要的例子便是“流式对象”和“固 定对象”。对于流式对象，对象会变成字节流，通常会发给另一台机器。而对于 固定对象，对象保存在磁盘中。即使程序中止运行，它们仍可保持自己的状态不 变。对于这些类型的数据存储，一个特别有用的技巧就是它们能存在于其他媒体 中。一旦需要，甚至能将它们恢复成普通的、基于 RAM 的对象。Java 1.1 提供 了对 Lightweight persistence 的支持。未来的版本甚至可能提供更完整的方案 特殊情况：主要类型 有一系列类需特别对待；可将它们想象成“基本”、“主要”或者“主” （Primitive）类型，进行程序设计时要频繁用到它们。之所以要特别对待，是由 于用 new 创建对象（特别是小的、简单的变量）并不是非常有效，因为 new 将 对象置于“堆”里。所以对于这些主要类型，Java 采纳了与 C 和 C++相同的方法。也就 是说，不是用 new 创建变量，而是创建一个并非句柄的“自动”变量。这个变 量容纳了具体的值，并置于堆栈中，能够更高效地存取。 Java 决定了每种主要类型的大小。就象在大多数语言里那样，这些大小并 不随着机器结构的变化而变化。这种大小的不可更改正是 Java 程序具有很强移 植能力的原因之一。 3.特例:基本类型 主类型 大小 最小值 最大值 封装器类型 boolean 1 位 - - Boolean char 16 位 Unicode 0 Unicode 2的16次方-1 Character byte 8 位 -128 +127 Byte short 16 位 -2的15次方 +2的 15 次方-1 Short int 32 位 -2的31次方 +2的 31 次方-1 Integer long 64 位 -2的63次方 +2的 63 次方-1 Long float 32 位 IEEE754 IEEE754 Float double 64 位 IEEE754 IEEE754 Double float有一个符号位+8个指数位+23个尾数位 阶码的范围是-126～127 -126-23 即最小值为2的-149次方 最大值(2-2的-23次方)*2的127次方 Float.MIN_VALUE = 1.4e-45f Float.MAX_VALUE = 3.4028235e+38f double一样 1+11+52 解码的范围 -1022-1023 -1022-52 即最小值为2的-1074次方 最大值(2-2的-52)*2的1023次方 为什么java中对于float和double定义的最小值都是正数，而不是-Float.MAX_VALUE了？ 因为他们不是连续的，它们有精度，无法表示整个实数，最小值也是趋近于零，float无法表示-Float.MIN_VALUE和Float.MIN_VALUE之间的值，如果最小值用-Float.MAX_VALUE是不严谨的 高精度数字 Java 1.1 增加了两个类，用于进行高精度的计算：BigInteger 和 BigDecimal。 尽管它们大致可以划分为“封装器”类型，但两者都没有对应的“主类型”。 这两个类都有自己特殊的“方法”，对应于我们针对主类型执行的操作。也 就是说，能对 int 或 float 做的事情，对 BigInteger 和 BigDecimal 一样可以做。 只是必须使用方法调用，不能使用运算符。此外，由于牵涉更多，所以运算速度 会慢一些。我们牺牲了速度，但换来了精度。 BigInteger 支持任意精度的整数。也就是说，我们可精确表示任意大小的整 数值，同时在运算过程中不会丢失任何信息。 BigDecimal 支持任意精度的定点数字。例如，可用它进行精确的币值计算。 至于调用这两个类时可选用的构建器和方法，请自行参考联机帮助文档 4.Java 的数组 在 C++里，应尽量不要使用数组，换用标准模板库（Standard TemplateLibrary）里更安全的容器。 而一个 Java 可以保证被初始化，而且不可在它的范 围之外访问。由于系统自动进行范围检查，所以必然要付出一些代价：针对每个 数组，以及在运行期间对索引的校验，都会造成少量的内存开销。但由此换回的 是更高的安全性，以及更高的工作效率。为此付出少许代价是值得的。 创建对象数组时，实际创建的是一个句柄数组。而且每个句柄都会自动初始 化成一个特殊值，并带有自己的关键字：null（空）。一旦 Java 看到 null，就知 道该句柄并未指向一个对象。正式使用前，必须为每个句柄都分配一个对象。若 试图使用依然为 null 的一个句柄，就会在运行期报告问题。因此，典型的数组错 误在 Java 里就得到了避免。 也可以创建主类型数组。同样地，编译器能够担保对它的初始化，因为会将 那个数组的内存划分成零。 5.作用域 对于在作用域里 定义的名字，作用域同时决定了它的“可见性”以及“存在时间”。在 C，C++ 和 Java 里，作用域是由花括号的位置决定的 12345678910 &#123; int x = 12; /* only x available */ &#123; int q = 96; /* both x &amp; q available */ &#125; /* only x available */ /* q “out of scope” */&#125; 注意尽管在 C 和 C++里是合法的，但在 Java 里不能象下面这样书写代码： 1234567 &#123; int x = 12; &#123; int x = 96; /* illegal */ &#125;&#125; 编译器会认为变量 x 已被定义。所以 C 和 C++能将一个变量“隐藏”在一 个更大的作用域里。但这种做法在 Java 里是不允许的，因为 Java 的设计者认 为这样做使程序产生了混淆。 对象的作用域 Java 对象不具备与主类型一样的存在时间。用 new 关键字创建一个 Java 对象的时候，它会超出作用域的范围之外 123&#123;String s = new String(&quot;a string&quot;);&#125; /* 作用域的终点 */ 那么句柄 s 会在作用域的终点处消失。然而，s 指向的 String 对象依然占据 着内存空间。在上面这段代码里，我们没有办法访问对象，因为指向它的唯一一 个句柄已超出了作用域的边界。在后面的章节里，大家还会继续学习如何在程序 运行期间传递和复制对象句柄。 6.新建数据类型：类 定义一个类时（我们在 Java 里的全部工作就是定义类、制作那些类的对象 以及将消息发给那些对象），可在自己的类里设置两种类型的元素：数据成员（有 时也叫“字段”）以及成员函数（通常叫“方法”）。其中，数据成员是一种对象 （通过它的句柄与其通信），可以为任何类型。它也可以是主类型（并不是句柄） 之一 7.主成员的默认值 若某个主数据类型属于一个类成员，那么即使不明确（显式）进行初始化， 也可以保证它们获得一个默认值。 主类型 默认值 Boolean false Char ‘\u0000’(null) byte (byte)0 short (short)0 int 0 long 0L float 0.0f double 0.0d 一旦将变量作为类成员使用，就要特别注意由 Java 分配的默认值。这样做 可保证主类型的成员变量肯定得到了初始化（C不具备这一功能），可有效遏 止多种相关的编程错误。 然而，这种保证却并不适用于“局部”变量——那些变量并非一个类的字段。 所以，假若在一个函数定义中写入下述代码： int x; 那么 x 会得到一些随机值（这与 C 和 C是一样的），不会自动初始化成零。 我们责任是在正式使用 x 前分配一个适当的值。如果忘记，就会得到一条编译期 错误，告诉我们变量可能尚未初始化。这种处理正是 Java 优于 C的表现之一。 许多 C编译器会对变量未初始化发出警告，但在 Java 里却是错误。 8: 方法、自变量和返回值 迄今为止，我们一直用“函数”（Function）这个词指代一个已命名的子例程。 但在 Java 里，更常用的一个词却是“方法”（Method），代表“完成某事的途径”。 尽管它们表达的实际是同一个意思，但从现在开始，本书将一直使用“方法”， 而不是“函数”。 Java 的“方法”决定了一个对象能够接收的消息。 Java 的方法只能作为类的一部分创建。只能针对某个对象调用一个方法(正如马上就要学到的那样，“静态”方法可针对类调用，毋需一个对象) int x = a.f(); 象这样调用一个方法的行动通常叫作“向对象发送一条消息”。在上面的例 子中，消息是 f()，而对象是 a。面向对象的程序设计通常简单地归纳为“向对象 发送消息”。 正如在 Java 其他地方处理对象时一样，我们实际传递的是“句柄”（注释④）。 ④：对于前面提及的“特殊”数据类型 boolean，char，byte，short，int， long，，float 以及 double 来说是一个例外。但在传递对象时，通常都是指传递指 向对象的句柄。 9：使用其他组件 用 import 关键字准确告诉 Java 编译器我们希望的类是什么。import 的作用是 指示编译器导入一个“包”——或者说一个“类库”（在其他语言里，可将“库” 想象成一系列函数、数据以及类的集合。但请记住，Java 的所有代码都必须写 入一个类中）。 1import java.util.Vector; 它的作用是告诉编译器我们想使用 Java 的 Vector 类。然而，util 包含了数 量众多的类，我们有时希望使用其中的几个，同时不想全部明确地声明它们。为 达到这个目的，可使用“*”通配符。如下所示： 123456789101112131415161718192021222324252627282930313233343536373839import java.util.*;``` 需导入一系列类时，采用的通常是这个办法。应尽量避免一个一个地导入类#### 10:static 关键字通常，我们创建类时会指出那个类的对象的外观与行为。除非用 new 创建那 个类的一个对象，否则实际上并未得到任何东西。只有执行了 new 后，才会正 式生成数据存储空间，并可使用相应的方法。但在两种特殊的情形下，上述方法并不堪用。一种情形是只想用一个存储区 域来保存一个特定的数据——无论要创建多少个对象，甚至根本不创建对象。另 一种情形是我们需要一个特殊的方法，它没有与这个类的任何对象关联。也就是 说，即使没有创建对象，也需要一个能调用的方法。为满足这两方面的要求，可 使用 static（静态）关键字。一旦将什么东西设为 static，数据或方法就不会同 那个类的任何对象实例联系到一起当然，在正式使用前，由于static 方法不需要创建任何对象，所以它们不可简单地调用其他那些成员，同时不引用 一个已命名的对象，从而直接访问非 static 成员或方法（因为非 static 成员和方 法必须同一个特定的对象关联到一起）。&lt;font color=&quot;#eb4d4b&quot;&gt;尽管是“静态”的，但只要应用于一个数据成员，就会明确改变数据的创建 方式（一个类一个成员，以及每个对象一个非静态成员）。若应用于一个方法， 就没有那么戏剧化了。对方法来说，static 一项重要的用途就是帮助我们在不必 创建对象的前提下调用那个方法。正如以后会看到的那样，这一点是至关重要的 ——特别是在定义程序运行入口方法 main()的时候。 和其他任何方法一样，static 方法也能创建自己类型的命名对象。所以经常 把 static 方法作为一个“领头羊”使用，用它生成一系列自己类型的“实例”。&lt;/font&gt;## 第三章 操作符#### 1.使用Java操作符几乎所有Java操作符都只能操作“基本类型”，例外的是“=”，“==”和“!=”String类型支持“+”和“+=”#### 2.赋值对象的赋值其实是将“引用”赋值到另一个地方。如 c = d;那么c和d都指向原本只有d指向的对象。下面这个小例子挺好的t2赋给t1后，并非是互相独立桥归桥路归路。而是绑定在一起共同操作同一个对象。这种特殊的现象称为“别名现象”。#### 3.算术操作符整数除法后直接去掉小数位，而非四舍五入的结果。Random类对象#### 4.关系操作符==和!= 比较的是对象的引用。```javapublic class Equivalence &#123;public static void main(String[] args) &#123;Integer n1 = new Integer(47);Integer n2 = new Integer(47);System.out.println(n1 == n2);System.out.println(n1 != n2);&#125;&#125; /* Output:falsetrue 需要比较对象的实际内容使用equals()，此方法不适合基本类型。 然而，对于自定义类，需要比较对象的内容时，还需要覆盖equals()方法 5.逻辑操作符 与&amp;&amp;，或||，非！ 在使用逻辑操作符时，会遇到短路现象，即 boolean a =（2&gt;1）&amp;&amp; (3&lt;1) &amp;&amp; (5&gt;2) &amp;&amp; (9&gt;3); 在计算到(3&gt;1)为false时，后续两个式子就不再计算，结果a = false不会再改变 5.直接常量 直接常量后缀表明了它的类型，大写（或小写）L，表示long，大写（或小写）F，表示float，大写D，表示double 如： long n3 = 200; float f4 = 1r-43f; 十六进制 0x(0X) + 0~f 八进制 0+0~7 将变量初始化的超出表示范围，编译器会报错。 通过使用Integer和Long的toBinaryString()方法，可以轻松又随意的以二进制形式表示。 Java的指数计数法中，e表示10的幂次而非自然数2,.71那个e： float = 1.39e-43f; 表示1.39*10^(-43) 6.直接常量 与&amp;，或|，非~，异或^ &amp;=，!=，^=。然而并没有=，因为是一元操作符。 对于布尔值，按位操作符具有与逻辑操作符相同效果，但是它们不会中途短路。 7.移位操作符 左移位操作符（&lt;&lt;），低位补0。 “有符号”右移位操作符（&gt;&gt;），高位补0，符号保留。 “无符号”右移位操作符（&gt;&gt;&gt;），无论正负，高位补0。 char，byte，short移位前会被转换为int类型，得到结果也是int类型，只有右端低5位有效。（int类型只有32位）。 因此无符号右移时，它们会被先转成Int型，然后右移操作，然后截断，赋值给原来的类型，在这种情况下可能导致-1的结果。 8.类型转换操作符 可以对变量或者数值进行类型转换（cast）。 如果执行窄化转换，数据可能会丢失，编译器会觉得是不是我们搞错了没注意到，此时需要显式的进行类型转换，强调一下。执行扩展转换，则不必显式的进行类型转换。 float和double转化为整型值时，总会对该数字执行截尾。 对于基本数据类型进行算术运算或按位运算，只要类型比int小，在运算前这些书会自动转换成int，即会自动执行数据类型提升。 表达式中出现最大的数据类型决定了表达式最终的数据类型。 参考资料 https://my.oschina.net/jackieyeah/blog/224265 UML类图中的六大关系：关联、聚合、组合、依赖、继承、实现 JackieYeah https://www.cnblogs.com/yanquan/p/7248933.html 《THINKING IN JAVA》–第二章一切都是对象 延泉 https://blog.csdn.net/severusyue/article/details/48576589 Java编程思想第四版读书笔记——第三章 操作符 severusyue]]></content>
      <categories>
        <category>书籍</category>
        <category>java</category>
        <category>java编程思想第四版</category>
      </categories>
      <tags>
        <tag>书籍</tag>
        <tag>java</tag>
        <tag>java编程思想第四版</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[回溯与递归]]></title>
    <url>%2Fblog%2F2019%2F01%2F07%2F%E5%9B%9E%E6%BA%AF%E4%B8%8E%E9%80%92%E5%BD%92%2F</url>
    <content type="text"><![CDATA[前言 最近在leetcode刷题，对于平常不是很清楚的一些数据结构和算法重新回顾和巩固一遍 目的 了解回溯和递归的区别，另外弄清楚回溯的特点和应用场景 正文 回溯和递归的区别和联系 12递归:递归是一种算法结构,函数调用本身,最直接的递归应用就是计算连续数的阶乘，计算规律：n!=(n-1)!*n，还有汉诺塔的实现回溯:在按某种搜索策略搜索的过程中，当到达某一状态时，继续向前搜索已经确定不会得到正确答案的情况下，可以返回上一搜索状态，沿着新的可能性继续搜索。其求解过程的实质是一个先序遍历一棵“状态树”的过程 两者之间的联系:回溯多用递归实现 回溯的特点 123搜索策略:符合递归算法，问题解决可以化为子问题，算法类似，规模减小;控制策略:当遇到失败的搜索状态，需要返回上一状态，沿另外的路径搜索;数据结构:一般用数组保存搜索过程中的状态、路径。 选择回溯的前提 123选择：对于每个特定的解，肯定是由一步步构建而来的，而每一步怎么构建，肯定都是有限个选择，要怎么选择，这个要知道；同时，在编程时候要定下，优先或合法的每一步选择的顺序，一般是通过多个if或者for循环来排列条件：对于每个特定的解的某一步，他必然要符合某个解要求符合的条件，如果不符合条件，就要回溯，其实回溯也就是递归调用的返回结束：当到达一个特定结束条件时候，就认为这个一步步构建的解是符合要求的解了。把解存下来或者打印出来。对于这一步来说，有时候也可以另外写一个issolution函数来进行判断。注意，当到达第三步后，有时候还需要构建一个数据结构，把符合要求的解存起来，便于当得到所有解后，把解空间输出来。这个数据结构必须是全局的，作为参数之一传递给递归函数 回溯参数的设计 1234必须要有一个临时变量(可以就直接传递一个字面量或者常量进去)传递不完整的解，因为每一步选择后，暂时还没构成完整的解，这个时候这个选择的不完整解，也要想办法传递给递归函数。也就是，把每次递归的不同情况传递给递归调用的函数。可以有一个全局变量，用来存储完整的每个解，一般是个集合容器（也不一定要有这样一个变量，因为每次符合结束条件，不完整解就是完整解了，直接打印即可）。最重要的一点，一定要在参数设计中，可以得到结束条件。一个选择是可以传递一个量n，也许是数组的长度，也许是数量，等等。要保证递归函数返回后，状态可以恢复到递归前，以此达到真正回溯。 扩展 #784 LetterCasePermutation 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/** * creambing.com Inc. * Copyright (c) 2016-2017 All Rights Reserved. */package com.creambing.leetcode.backtracking;import java.util.LinkedList;import java.util.List;/** * Class Name:LetterCasePermutation784 * Description:字母大小写全排列 * * @author Bing * @create 2019-01-07 20:52 * @version v1.0 */public class LetterCasePermutation784 &#123; public List&lt;String&gt; letterCasePermutation(String S) &#123; //全局的结果集合，作为回溯入参，保存完整结果 List&lt;String&gt; result = new LinkedList&lt;&gt;(); //开始回溯，这里选用字符数组，方便遍历以及替换字符，同时还可以连接成完整结果 backtracking(S.toCharArray(), 0, result); return result; &#125; private void backtracking(char[] s, int pos, List&lt;String&gt; result) &#123; result.add(new String(s)); for (int j = pos; j &lt; s.length; j++) &#123; char ch = s[j]; if (Character.isAlphabetic(ch)) &#123; s[j] = flip(ch); backtracking(s, j+1, result); s[j]= ch; &#125; &#125; &#125; private char flip(char ch)&#123; return Character.isUpperCase(ch)? Character.toLowerCase(ch):Character.toUpperCase(ch); &#125; public static void main(String[] args) &#123; String s ="ab14c"; new LetterCasePermutation784().letterCasePermutation(s).forEach(System.out::println); &#125;&#125; 思路根据上面的对于回溯的理解设计参数，我们从最简单的情景来设计程序，假设串是a,那么结果就是a,A,那么这个最简单的逻辑是什么了？先把当前串写入集合中，把第i个字母大小转换(数字不管)就是下面这段,要注意的是:要保证递归函数返回后，状态可以恢复到递归前，以此达到真正回溯,因此注释的那段很重要，要加上，否则回溯会有问题 1234567891011121314public class LetterCasePermutation784 &#123; private void backtracking(char[] s, int pos, List&lt;String&gt; result) &#123; result.add(new String(s)); for (int j = pos; j &lt; s.length; j++) &#123; char ch = s[j]; if (Character.isAlphabetic(ch)) &#123; s[j] = flip(ch); backtracking(s, j+1, result); //s[j]= ch; &#125; &#125; &#125;&#125; 运行结果截图 运行流程分析 Runtime: 10 ms, faster than 45.47% of Java online submissions for Letter Case Permutation. #401 BinaryWatch(二进制手表) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869/** * creambing.com Inc. * Copyright (c) 2016-2017 All Rights Reserved. */package com.creambing.leetcode.backtracking;import java.util.ArrayList;import java.util.List;/** * Class Name:BinaryWatch401 * Description:二进制手表 * * @author Bing * @version v1.0 * @create 2019-01-08 19:00 */public class BinaryWatch401 &#123; public List&lt;String&gt; readBinaryWatch(int num) &#123; int[] hoursc = &#123;1, 2, 4, 8&#125;; int[] minutec = &#123;1, 2, 4, 8, 16, 32&#125;; List&lt;String&gt; result = new ArrayList&lt;&gt;(); //我们想给了n个灯亮，那么我们正常就是先在hour中选，然后在minute中选，差不多想到下面这种逻辑 List&lt;Integer&gt; hourList = new ArrayList&lt;&gt;(); List&lt;Integer&gt; minuteList = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; num; i++) &#123; //这里面关于最后一个回溯参数先前没有考虑，getHour中i=0开始遍历的，这里设置参数的原因是选过了就不能再选了 getHour(i, hourList, 0, hoursc, 0); getMinu(num - i, minuteList, 0, minutec, 0); for (int hour : hourList) &#123; for (int minu : minuteList) &#123; result.add(hour+":"+(minu&lt;10?"0"+minu:minu)); &#125; &#125; //这里一定要清空 hourList.clear(); minuteList.clear(); &#125; return result; &#125; private void getHour(int n, List&lt;Integer&gt; hourList, int hour, int[] hoursc, int index) &#123; //这段可以不加，但是为了效率，加上 if (n &lt; 0) &#123; return; &#125; if (n == 0 &amp;&amp; hour &lt; 12) &#123; hourList.add(hour); &#125; for (int i = index; i &lt; hoursc.length; i++) &#123; getHour(n - 1, hourList, hour + hoursc[i], hoursc, i + 1); &#125; &#125; private void getMinu(int n, List&lt;Integer&gt; minuList, int minu, int[] minuc, int index) &#123; if (n &lt; 0) &#123; return; &#125; if (n == 0 &amp;&amp; minu &lt; 60) &#123; minuList.add(minu); &#125; for (int i = index; i &lt; minuc.length; i++) &#123; getMinu(n - 1, minuList, minu + minuc[i], minuc, i + 1); &#125; &#125;&#125; 这里拿到题目之后，感觉可以用回溯发，开始设计回溯参数 1.最开始的时候没有设计最后一个参数，for循环中i=0而不是index,这样导致选了之后在选，重复了，这里我们没有恢复状态，因为我们也没有改变状态，我们只是遍历取合适的值 2.另外一个小问题是组合的时候需要清空列表 Runtime: 3 ms, faster than 56.44% of Java online submissions for Binary Watch. 其他需要回溯方法解决的leetcode题目:https://leetcode.com/tag/backtracking/ 参考资料 1.https://www.jianshu.com/p/4c5ccac18fac 递归2-回溯与递归 偏偏注定要落脚丶 2.https://blog.csdn.net/u014772862/article/details/51789015 回溯和递归区别 繁拾简忆 3.https://blog.csdn.net/sinat_27908213/article/details/80599460 回溯算法超通俗易懂详尽分析和例题 littlelufisher]]></content>
      <categories>
        <category>算法</category>
        <category>回溯</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>回溯</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[centos7在线安装docker]]></title>
    <url>%2Fblog%2F2018%2F11%2F30%2Fcentos7%E5%9C%A8%E7%BA%BF%E5%AE%89%E8%A3%85docker%2F</url>
    <content type="text"><![CDATA[前言 在线在centos7安装docker 目的 CentOS Linux release 7.5.1804 (Core) docker-ce.x86_64 3:18.09.0-3.el7 正文 1.确认系统是否是centos7，内核在3.10以上 123uname -r或者cat /etc/redhat-release 2.执行如下命令安装 在root用户下，或者在sudo执行 123456789yum install -y yum-utils \ device-mapper-persistent-data \ lvm2yum-config-manager \ --add-repo \ https://download.docker.com/linux/centos/docker-ce.repo yum install docker-ce 在第一次执行安装命令时，无法解析远程仓库，此时用浏览器访问了一下,确认可以访问，于是再次执行，安装成功，这说明这个网站针对国内不够稳定，最后下载的时候确实显示速度也比较慢 所以这里可以切换成阿里的源 http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo 3.启动并验证 12systemctl start docker.servicedocker run hello-world 4.centos7以下安装docker的方式 一.什么是epel? 如果既想获得 RHEL 的高质量、高性能、高可靠性，又需要方便易用(关键是免费)的软件包更新功能，那么 Fedora Project 推出的 EPEL(Extra Packages for Enterprise Linux)正好适合你。EPEL(http://fedoraproject.org/wiki/EPEL) 是由 Fedora 社区打造，为 RHEL 及衍生发行版如 CentOS、Scientific Linux 等提供高质量软件包的项目。 具体步骤链接:https://www.jianshu.com/p/4e74f11ee309,这个我没有亲自实验，想来应该可以，但是升级一大堆包毕竟感觉有点慌张，这里提供我之前的安装方式 通过epel安装已经行不通了，因为里面已经没有了docker-io的包了 2019/03/19实验可行 centos6最后支持的docker版本是1.7.1 123yum install https://get.docker.com/rpm/1.7.1/centos-6/RPMS/x86_64/docker-engine-1.7.1-1.el6.x86_64.rpmservice docker startdocker run hello-world docker1.7.1安装docker-compose 这里目前还是安装失败 参考资料 1.docker官方网站 [https://docs.docker.com/install/linux/docker-ce/centos/#install-using-the-repository] 2.各个操作系统安装docker社区版的官方网址 https://hub.docker.com/search/?type=edition&amp;offering=community 3.centos6.x安装docker http://icyleaf.com/2016/12/docker-with-centos/]]></content>
      <categories>
        <category>centos7</category>
        <category>docker</category>
        <category>在线</category>
      </categories>
      <tags>
        <tag>centos7</tag>
        <tag>docker</tag>
        <tag>在线</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[docker安装mangodb和redis]]></title>
    <url>%2Fblog%2F2018%2F11%2F29%2Fdocker%E5%AE%89%E8%A3%85mangodb%E5%92%8Credis%2F</url>
    <content type="text"><![CDATA[前言 在有docker环境和docker-compose的工具的机器上，快速搭建redis和mangodb的单机服务 目的 由于我在window上安装了docker,具体教程可看**windows上安装docker-ce**，以下命令都是在windows上操作 正文 安装redis 在cmd中执行以下命令下载redis镜像 1docker pull redis 在redis服务需要启动的目录中新建redis.yml文件，里面写入如下内容 1234567891011121314151617181920version: '3.1'services: redis: image: redis:latest container_name: redis hostname: redis restart: always networks: static-network: ipv4_address: 172.21.0.2 ports: - "16379:6379"networks: static-network: ipam: config: - subnet: 172.21.0.0/16 注意我们这里对于redis所在容器的ip进行了指定，当然也可以不用指定，可以服务开启后自己查看ip地址，另外容器ip不用172.21.0.1,不然会报错地址已被使用 进入redis.yml文件所在目录执行 1docker-compose -f redis.yml up -d 截图如下 利用redis-client客户端连接(客户端下载地址 https://redisdesktop.com/download) 这里在window下有个问题，就是我这里重新又定义了一个网络，我发现我不能ping通172.21.0.2这个容器ip，所以只能通过127.0.0.1:16379连接 不过之前定义的consuls的网络是可以ping通的,后来发现ping通的不是docker中的，而是电信网关连接的其他网络，我们现在将网络改为consuls桥接的网络看看 123456789101112131415161718version: '3.1'services: redis: image: redis:latest container_name: redis hostname: redis restart: always networks: consuls_static-network: ipv4_address: 172.20.0.5 ports: - "16379:6379"networks: consuls_static-network: external: true 这里只是展示一下docker-compose使用已有网络的写法，虽然改了能够ping通，但不是这个网络，这个和linux上有差别 linux上docker新建桥接网络，是可以互通的，但是windows上不行 我注意到docker 的setting中有network这个选项 然后我们查看一下window的路由链路 1route print 这里我们发现10.0.75.0/24的子网的网关为10.0.75.1和docker setting配置一样，正好对上了，但是并没有172.20.0.5的子网，虽然docker中已经有了，这也正说明windows上的docker和linux上的docker不一样，因为linux上只要新建了网络，就有链路了 所以我们这里新建一个匹配的桥接网络 1docker network create -d bridge --subnet=10.0.75.0/24 --gateway=10.0.75.1 usable_net 123456789101112131415161718192021222324version: '3.1'services: redis: image: redis:latest container_name: redis hostname: redis restart: always networks: usable_net: ipv4_address: 10.0.75.5 ports: - "16379:6379"networks: usable_net: external: true#或者如下networks: usable_net: ipam: config: - subnet: 10.0.75.0/24 结果我发现这样做之后redis都连接不上了，于是还原回去利用最开始的方法，自己自定义网络， 但是我们发现我们自定义的网络中连网关都没有 扩展 这部分是在Linux作为宿主机的测试，centos7在线安装docker + linux上安装docker-compose(centos7.5+docker18.09+docker-composev1.22.0) 因为可以ping通，所以我在linux宿主机上既可以通过本地的16379也可以用docker的ip(172.21.0.2)+6379访问，但是在windows上我只能用16379,因为docker机器我无法ping通 这里遗留了两个问题: 12windows上network配置有什么用？为什么windows作为宿主机无法ping通自定义桥接网络的容器ip? 但是我们还是无法ping通，我们手动添加路由试试 1route add 192.172.0.0 mask 255.255.0.0 192.168.5.105 https://download.studio3t.com/studio-3t/windows/2018.5.1/studio-3t-x64.zip 参考资料 1.docker-compose v3 [https://docs.docker.com/compose/compose-file/#ipv4_address-ipv6_address] 2.docker-compose networks [https://docs.docker.com/compose/networking/#configure-the-default-network]]]></content>
      <categories>
        <category>docker-compose</category>
        <category>mangodb</category>
        <category>redis</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>docker-compose</tag>
        <tag>mangodb</tag>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nodejs微服务集成consul]]></title>
    <url>%2Fblog%2F2018%2F11%2F23%2Fnodejs%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%9B%86%E6%88%90consul%2F</url>
    <content type="text"><![CDATA[前言 **使用Sidecar来整合非jvm微服务**这篇文章讲解了非jvm集成到springcloud体系中的方法 需要说明的是上述方法是用Netflix的sidecar,然而它依赖Eureka作为服务发现组件，consul有自己的注册接口 目的 利用consul的http api将nodejs微服务注册到consul中 正文 js中有目前实现最为完备的Consul 客户端是node-consul 它支持的功能有 123456789ACL: 访问控制Agent: 检查/服务注册Health: 健康信息获取Catalog: 目录列表KV: 键值对存取Event: 发送事件与列表Query: 查询服务信息Status: Raft一致性的状态信息... 不过我目前就只需要当node程序启动时能将服务注册到consul中，关闭程序时能注销 我发现Consul-SDK实现了这一点 使用方法在nodejs工程目录下运行命令安装,当时安装的版本为1.1.9，其中依赖的consul(即node-consul)版本为0.27.0，当前最新为0.34.1 1npm i consul-sdk --save 在根目录下添加consul.json，check是我后面添加健康检查自己修改源码所加的配置 123456789101112&#123; "serverHost": "localhost", "serverPort": 18500, "secure": false, "name": "node-service", "host": "192.168.5.105", "port": 3000, "check":&#123; "http":"http://192.168.5.105:3000/health", "interval":"10s" &#125;&#125; 在app.js中引入consul-sdk 1require('consul-sdk'); 这样在项目启动和结束就会触发相应的注册和注销操作 由于我现在的consul服务器端版本是1.3.0，这个js版本的consul客户端版本是0.27.0，其中注销时报错405，get方法不被允许 需要修改consul源码包中service.js中注销逻辑中get方法为put方法，和注册一样 我们对比一下js版本的consul客户端和java版本的客户端(spring-cloud-starter-consul-discovery),在服务发现的功能上 12js实现了服务注册和注销，但是还没有健康检查，如果注销失败会出现下面截图中出现的事情，服务在consul上依然存在并且正常java实现了服务注册和健康检查，并没有服务注销(不知道是不是我没有配置) 其实node-consul是支持健康检查的，只不过consul-sdk不支持，但它是依赖node-consul来做的，我们把consul-sdk源码修改一下 其实consul-sdk是对consul的一层封装，作者用es5写的，可以借鉴思路自己改写 同时配置文件添加上面那一段check. 下面我们在我们之前实现的网关服务中**springcloud使用zuul聚合微服务**添加代码来调用一下node中的相关服务 添加服务类和控制类 1234567891011121314151617181920212223242526272829303132333435363738@Servicepublic class NodeRibbonService &#123; @Autowired RestTemplate restTemplate; @HystrixCommand(fallbackMethod = "fallback") public String getHealthInfo() &#123; return restTemplate.getForObject("http://node-service/health", String.class); &#125; public String fallback(Throwable throwable) &#123; System.out.println("node-service /health 报错:"+throwable); Map&lt;String, Object&gt; map = Maps.newHashMap(); map.put("status", "unkown"); return new Gson().toJson(map); &#125;&#125;@RestController@RequestMapping("/un")public class UserAndNodeController &#123; @Autowired UserRibbonService userRibbonService; @Autowired NodeRibbonService nodeRibbonService; @RequestMapping(value = "/getUserAndNodeHealth",method = RequestMethod.GET) public Map&lt;String, Object&gt; getUserAndNodeHealth()&#123; List&lt;User&gt; users = userRibbonService.getAllUsers1(); String s = nodeRibbonService.getHealthInfo(); Map&lt;String, Object&gt; map = Maps.newHashMap(); map.put("users",users); map.put("node",s); return map; &#125;&#125; 调用接口http://localhost:1051/un/getUserAndNodeHealth 关掉node服务，但是没有在consul上注销并且consul上显示node服务正常 利用上面修改源码程序退出成功在consul上注销后再调用 关掉node程序，增加健康检查后，但是在consul上不注销，此时consul上显示node服务不健康，调用该接口直接走hytrix,和java类似 参考资料 1.js版本的consul客户端 [https://github.com/silas/node-consul#agent-service-register] 2.Consul-SDK博客地址 [http://www.moye.me/2016/10/26/node-consul-sdk/] 3.consul-sdkgithub地址 [https://github.com/rockdragon/node-consul-sdk] 4.consul官网service的http api [https://www.consul.io/api/agent/service.html]]]></content>
      <categories>
        <category>nodejs</category>
        <category>consul</category>
      </categories>
      <tags>
        <tag>nodejs</tag>
        <tag>consul</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Sidecar来整合非jvm微服务]]></title>
    <url>%2Fblog%2F2018%2F11%2F21%2F%E4%BD%BF%E7%94%A8Sidecar%E6%9D%A5%E6%95%B4%E5%90%88%E9%9D%9Ejvm%E5%BE%AE%E6%9C%8D%E5%8A%A1%2F</url>
    <content type="text"><![CDATA[前言 由于语言多样，系统复杂，有时候一个健壮的系统可能是由多种语言组成的，针对一个非jvm的接口平台，我们可以利用sidecar整合进来 目的 利用zuul可以调用已经注册到注册中心的服务，利用sidecar调用非jvm的服务，这样就可以对外提供一个整合了jvm和非jvm的网关服务 正文 利用idea新建一个node项目 在idea中新建一个node工程，没有的话，先添加nodejs插件 编写node项目，添加health端点 在app.js中添加 123var healthRouter = require('./routes/health');app.use('/health', healthRouter); 在routes中添加health.js中添加如下 123456789var express = require('express');var router = express.Router();/* GET users listing. */router.get('/', function(req, res, next) &#123; res.send(JSON.stringify(&#123;"status":"UP"&#125;));&#125;);module.exports = router; 访问http://localhost:3000/health显示 编写java sidecar整合这个node服务 参考资料]]></content>
      <categories>
        <category>java</category>
        <category>springcloud</category>
        <category>sidecar</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>springcloud</tag>
        <tag>sidecar</tag>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springcloud使用zuul聚合微服务]]></title>
    <url>%2Fblog%2F2018%2F10%2F30%2Fspringcloud%E4%BD%BF%E7%94%A8zuul%E8%81%9A%E5%90%88%E5%BE%AE%E6%9C%8D%E5%8A%A1%2F</url>
    <content type="text"><![CDATA[前言 1.springcloud编写用户微服务 2.springcloud编写电影微服务 3.springcloud集成网关ZUUL 依上面教程，我已经实现了用户，电影微服务以及zuul网关，微服务的设计难点之一在于对原有业务的拆分， 在我看来每个微服务职责要尽可能单一，但是这样同样也带来了一个问题，那就是微服务之间不可避免的一 些交集.例如终端需要查询用户信息和电影信息，这里有两种做法 1.让终端查询用户信息后在查询电影信息 2.网关层查询用户信息和电影信息，聚合后返回给终端 后一种方式显然更好一些，因为他节省了带宽，相较于终端两次请求网关，显然网关两次请求微服务的网络情况更好 目的 利用RXJAVA聚合微服务，这里面其实很多东西可以讨论，关于分布式协议和分布式事务,这次先简单的说明 一下查询聚合，因为查询是幂等操作，不需要事务 正文 工程初始化 可以参见这篇博客**springcloud集成网关ZUUL** 验证: http://localhost:1051/api/user/user/getAll http://localhost:1051/api/movie/movie/findOneById?id=2 集成feign,添加用户和电影的消费端 可以参见这篇博客**springcloud集成feign** 仿照user创建movie的feign客户端 1234567891011121314@FeignClient(name = &quot;consul-movie&quot;)public interface MovieFeignClient &#123; @RequestMapping(value = &quot;/movie/findOneById&quot;,method = RequestMethod.GET) Movie findOneById(@RequestParam(&quot;id&quot;) Long id);&#125;错误的写法@FeignClient(name = &quot;consul-movie&quot;)public interface MovieFeignClient &#123; @RequestMapping(value = &quot;/movie/findOneById&quot;,method = RequestMethod.GET) Movie findOneById(Long id);&#125; get多参数写法 12直接写Long id或者直接是User user这种对象，feign依然会用post方式调用，所以会报错接口不支持需要用@RequestParam(&quot;id&quot;)注解，或者@RequestParam Map&lt;String,Object&gt; map 扩展 20181031更新:zuul上的service中添加hystrix回退并没有执行，如下图，想着service中利用的是 feign实现的，所以给feign加上回退，需要在配置上加上feign.hystrix.enabled=true 123456789101112131415161718192021222324252627282930313233343536373839404142@FeignClient(name = "consul-movie",fallback = MovieFeignClient.MovieFeignClientFallBack.class)public interface MovieFeignClient &#123; @RequestMapping(value = "/movie/findOneById",method = RequestMethod.GET) Movie findOneById(@RequestParam("id") Long id); @Component class MovieFeignClientFallBack implements MovieFeignClient&#123; @Override public Movie findOneById(Long id) &#123; Movie movie = new Movie(); movie.setId(-1L); return movie; &#125; &#125;&#125;//加上日志的版本@FeignClient(name = "consul-movie",fallbackFactory = MovieFeignClient.MovieFeignClientFallBackFactory.class)public interface MovieFeignClient &#123; @RequestMapping(value = "/movie/findOneById",method = RequestMethod.GET) Movie findOneById(@RequestParam("id") Long id); @Component class MovieFeignClientFallBackFactory implements FallbackFactory&lt;MovieFeignClient&gt;&#123; private static final Logger LOGGER = LoggerFactory.getLogger(MovieFeignClientFallBackFactory.class); @Override public MovieFeignClient create(Throwable throwable) &#123; return new MovieFeignClient() &#123; @Override public Movie findOneById(Long id) &#123; LOGGER.error("MovieFeignClient findOneById fallback;reason was:[&#123;&#125;]",throwable); Movie movie = new Movie(); movie.setId(-1L); return movie; &#125; &#125;; &#125; &#125;&#125; 集成ribbon 添加一个配置类java 123456789@Componentpublic class RibbonConf &#123; @Bean @LoadBalanced public RestTemplate restTemplate()&#123; return new RestTemplate(); &#125;&#125; 添加ribbon调用服务类 123456789101112131415161718192021222324252627282930313233343536@Servicepublic class MovieRibbonService &#123; @Autowired private RestTemplate restTemplate; @HystrixCommand(fallbackMethod = "fallback") public Observable&lt;Movie&gt; findOneById(Long id) &#123; return Observable.create(observer -&gt; &#123; Movie movie = restTemplate.getForObject("http://consul-movie/movie/findOneById", Movie.class, id); observer.onNext(movie); observer.onComplete(); &#125;); &#125; public Observable&lt;Movie&gt; fallback(Long id) &#123; return Observable.create(observer -&gt; &#123; Movie movie = new Movie(); movie.setId(-1L); observer.onNext(movie); observer.onComplete(); &#125;); &#125; @HystrixCommand(fallbackMethod = "fallback1") public Movie findOneById1(Long id) &#123; return restTemplate.getForObject("http://consul-movie/movie/findOneById", Movie.class, id); &#125; public Movie fallback1(Long id,Throwable throwable) &#123; System.out.println("consul-movie /movie/findOneById 报错:"+throwable); Movie movie = new Movie(); movie.setId(-1L); return movie; &#125;&#125; 新建聚合controller和服务(RXjava) 针对feign实现的service,之前在上面截图中可以发现我在上面加了HystrixCommand没有用，所以去掉了，不知道是不是因为里面是feign实现的，所以下面会有ribbon实现 123456789101112131415161718192021222324252627282930313233343536/** * creambing.com Inc. * Copyright (c) 2016-2017 All Rights Reserved. */package com.springcloud.consulzuulum.service.rxjava;import com.springcloud.consulzuulum.feign.movie.Movie;import com.springcloud.consulzuulum.feign.movie.MovieFeignClient;import io.reactivex.Observable;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;/** * Class Name:MovieService * Description:movie rxjava 服务类 * * @author Bing * @version v1.0 * @create 2018-10-30 22:01 */@Servicepublic class MovieService &#123; @Autowired MovieFeignClient movieFeignClient; public Observable&lt;Movie&gt; findOneById(Long id) &#123; return Observable.create(observer -&gt; &#123; Movie movie = movieFeignClient.findOneById(id); observer.onNext(movie); observer.onComplete(); &#125;); &#125;&#125; 控制类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117/** * creambing.com Inc. * Copyright (c) 2016-2017 All Rights Reserved. */package com.springcloud.consulzuulum.controller;import com.google.common.collect.Maps;import com.springcloud.consulzuulum.feign.movie.Movie;import com.springcloud.consulzuulum.feign.movie.MovieFeignClient;import com.springcloud.consulzuulum.feign.user.User;import com.springcloud.consulzuulum.feign.user.UserFeignClient;import com.springcloud.consulzuulum.service.rxjava.MovieService;import com.springcloud.consulzuulum.service.rxjava.UserService;import io.reactivex.Observable;import io.reactivex.Observer;import io.reactivex.disposables.Disposable;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestMethod;import org.springframework.web.bind.annotation.RestController;import org.springframework.web.context.request.async.DeferredResult;import java.util.HashMap;import java.util.List;import java.util.Map;/** * Class Name:UserAndMovieController * Description:用户和电影聚合控制类 * * @author Bing * @version v1.0 * @create 2018-10-30 17:11 */@RestController@RequestMapping("/um")public class UserAndMovieController &#123; @Autowired UserFeignClient userFeignClient; @Autowired MovieFeignClient movieFeignClient; @Autowired UserService userService; @Autowired MovieService movieService; @RequestMapping(value = "/getUserAndMovie", method = RequestMethod.GET) Map&lt;String, Object&gt; getUserAndMovie(Long id) &#123; Long startTime = System.currentTimeMillis(); Map&lt;String, Object&gt; result = new HashMap&lt;&gt;(); //同步调用 List&lt;User&gt; users = userFeignClient.getAllUser(); Movie movie = movieFeignClient.findOneById(id); result.put("users", users); result.put("movie", movie); Long endTime = System.currentTimeMillis(); System.out.println("getUserAndMovie同步调用花费时间:"+(endTime-startTime)); return result; &#125; @RequestMapping(value = "/getUserAndMovieUseRx", method = RequestMethod.GET) DeferredResult&lt;HashMap&lt;String,Object&gt;&gt; getUserAndMovieUseRx(Long id) &#123; Long startTime = System.currentTimeMillis(); //rx异步调用 Observable&lt;HashMap&lt;String,Object&gt;&gt; observable = aggregateObservable(id); DeferredResult&lt;HashMap&lt;String,Object&gt;&gt; result = toDefer(observable); Long endTime = System.currentTimeMillis(); System.out.println("getUserAndMovieUseRx异步调用花费时间:"+(endTime-startTime)); return result; &#125; public Observable&lt;HashMap&lt;String,Object&gt;&gt; aggregateObservable(Long id)&#123; return Observable.zip( userService.getAllUsers(), movieService.findOneById(id), (users,movie) -&gt; &#123; HashMap&lt;String,Object&gt; map = Maps.newHashMap(); map.put("users",users); map.put("movie",movie); return map; &#125; ); &#125; public DeferredResult&lt;HashMap&lt;String,Object&gt;&gt; toDefer(Observable&lt;HashMap&lt;String,Object&gt;&gt; details)&#123; DeferredResult&lt;HashMap&lt;String, Object&gt;&gt; result = new DeferredResult&lt;&gt;(); details.subscribe(new Observer&lt;HashMap&lt;String, Object&gt;&gt;() &#123; @Override public void onSubscribe(Disposable disposable) &#123; System.out.println(""); &#125; @Override public void onNext(HashMap&lt;String, Object&gt; stringObjectHashMap) &#123; result.setResult(stringObjectHashMap); &#125; @Override public void onError(Throwable throwable) &#123; System.out.println("发生错误:"+throwable); &#125; @Override public void onComplete() &#123; System.out.println("完成"); &#125; &#125;); return result; &#125;&#125; 访问 feign http://localhost:1051/um/getUserAndMovieUseRx?id=1 hystrix有效 rxjava+ribbon http://localhost:1051/um/getUserAndMovieUseRibbon?id=1 hystrix无效 ribbon http://localhost:1051/um/getAllUserRibbon hystrix有效 ribbon http://localhost:1051/um/getUserAndMovieUseRibbon1?id=1 hystrix有效]]></content>
      <categories>
        <category>java</category>
        <category>springcloud</category>
        <category>zuul</category>
        <category>rxjava</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>springcloud</tag>
        <tag>zuul</tag>
        <tag>rxjava</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springcloud编写电影微服务]]></title>
    <url>%2Fblog%2F2018%2F10%2F30%2Fspringcloud%E7%BC%96%E5%86%99%E7%94%B5%E5%BD%B1%E5%BE%AE%E6%9C%8D%E5%8A%A1%2F</url>
    <content type="text"><![CDATA[前言 1.springcloud Finchley.SR2版本 2.springboot 版本2.0.6.RELEASE 3.h2 4.jooq 5.consul 搭建一个电影微服务 目的 利用idea快速搭建一个springcloud集成上述功能的微服务，可以查询电影 正文 初始化工程 方法跟**springcloud编写用户微服务**中前期准备工程一般，勾选下列依赖 在resources文件夹下新增bootstrap.yml文件，写入以下内容 123456789101112131415161718192021222324252627282930313233343536#tomcat启动启动端口server: port: 1018spring: application: #项目名称 name: consul-movie cloud: consul: #consul server的host或者ip host: localhost #consul server的端口 port: 18500 config: #开启consul配置中心 enabled: true #consul表示consul上面文件的格式 有四种 YAML PROPERTIES KEY-VALUE FILES format: YAML #表示consul上面的KEY值(或者说文件的名字) 默认是data data-key: configuration #prefix设置配置值的基本文件夹 prefix: config #defaultContext设置所有应用程序使用的文件夹名 default-context: $&#123;spring.application.name&#125; discovery: #开启consul服务发现 enabled: true #开启consul服务的名称 service-name: consul-movie #服务检查的路径 health-check-path: /actuator/health #服务检查的时间间隔 health-check-interval: 10s #服务检查的完整路径 health-check-url: http://192.168.0.150:$&#123;server.port&#125;$&#123;spring.cloud.consul.discovery.health-check-path&#125; tags: dev 初始化H2数据库 这时候决定手动初始化datasource,同时集成第三方数据库连接池进来，详情**springboot集成druid** 此时consul上的配置如下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758spring: datasource: url: jdbc:h2:mem:test #url: jdbc:h2:file:~/.h2/testdb #url: jdbc:h2:~/testuser driverClassName: org.h2.Driver username: sa password: 123456 platform: h2 schema: classpath:db/schema.sql data: classpath:db/data.sql initialization-mode: always #springboot2.0加上上述sql才会执行 # 下面为druid连接池的补充设置，应用到上面所有数据源中 # 初始化大小，最小，最大 initialSize: 1 minIdle: 3 maxActive: 20 # 配置获取连接等待超时的时间 maxWait: 60000 # 配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位是毫秒 timeBetweenEvictionRunsMillis: 60000 # 配置一个连接在池中最小生存的时间，单位是毫秒 minEvictableIdleTimeMillis: 30000 validationQuery: select &apos;x&apos; testWhileIdle: true testOnBorrow: false testOnReturn: false # 打开PSCache，并且指定每个连接上PSCache的大小 poolPreparedStatements: true maxPoolPreparedStatementPerConnectionSize: 20 # 配置监控统计拦截的filters，去掉后监控界面sql无法统计 filters: stat # 通过connectProperties属性来打开mergeSql功能；慢SQL记录 connectionProperties: druid.stat.mergeSql=true;druid.stat.slowSqlMillis=5000 # 合并多个DruidDataSource的监控数据 useGlobalDataSourceStat: true h2: console: settings: web-allow-others: true #进行该配置后，h2 web consloe就可以在远程访问了。否则只能在本机访问。 path: /h2-console #进行该配置，你就可以通过YOUR_URL/h2-console访问h2 web consloe。YOUR_URL是你程序的访问URl。 enabled: true #进行该配置，程序开启时就会启动h2 web consloe。当然这是默认的，如果你不想在启动程序时启动h2 web consloe，那么就设置为false。#Actuator的健康检查开启所有包括health，info，metrics等management: endpoints: web: exposure: include: &quot;*&quot; #开启health端点详细检查 endpoint: health: show-details: alwayslogging: level: root: INFO org.hibernate: INFO org.hibernate.type.descriptor.sql.BasicBinder: TRACE org.hibernate.type.descriptor.sql.BasicExtractor: TRACE 根据配置在resources目录下，新增db文件夹，下面新增schema.sql和data.sql文件，内容分别如下 12345drop table movie if exists;create table movie (id bigint generated by default as identity ,movie_name varchar(40),score decimal(10,2),primary key (id));insert into movie (id,movie_name,score) values (1,&apos;肖申克的救赎&apos;,100.00);insert into movie (id,movie_name,score) values (2,&apos;这个杀手不太冷&apos;,101.00); 在pom中添加依赖druid 12345&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.1.10&lt;/version&gt;&lt;/dependency&gt; 在主程序平级目录新增db目录，新增DataSourceBean.java和DatasourceConf.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101@Configuration@Component@Datapublic class DataSourceBean &#123; private static final Logger LOGGER = LoggerFactory.getLogger(DataSourceBean.class); @Autowired DatasourceConf datasourceConf; @Bean public DataSource getDataSource() &#123; DruidDataSource datasource = new DruidDataSource(); datasource.setUrl(datasourceConf.getUrl()); datasource.setUsername(datasourceConf.getUsername()); datasource.setPassword(datasourceConf.getPassword()); datasource.setDriverClassName(datasourceConf.getDriverClassName()); //configuration datasource.setInitialSize(datasourceConf.getInitialSize()); datasource.setMinIdle(datasourceConf.getMinIdle()); datasource.setMaxActive(datasourceConf.getMaxActive()); datasource.setMaxWait(datasourceConf.getMaxWait()); datasource.setTimeBetweenEvictionRunsMillis(datasourceConf.getTimeBetweenEvictionRunsMillis()); datasource.setMinEvictableIdleTimeMillis(datasourceConf.getMinEvictableIdleTimeMillis()); datasource.setValidationQuery(datasourceConf.getValidationQuery()); datasource.setTestWhileIdle(datasourceConf.getTestWhileIdle()); datasource.setTestOnBorrow(datasourceConf.getTestOnBorrow()); datasource.setTestOnReturn(datasourceConf.getTestOnReturn()); datasource.setPoolPreparedStatements(datasourceConf.getPoolPreparedStatements()); datasource.setMaxPoolPreparedStatementPerConnectionSize(datasourceConf.getMaxPoolPreparedStatementPerConnectionSize()); datasource.setUseGlobalDataSourceStat(datasourceConf.getUseGlobalDataSourceStat()); try &#123; datasource.setFilters(datasourceConf.getFilters()); &#125; catch (SQLException e) &#123; LOGGER.error(&quot;druid configuration initialization filter: &quot; + e); &#125; datasource.setConnectionProperties(datasourceConf.getConnectionProperties()); return datasource; &#125; /** * 配置监控服务器 * * @return 返回监控注册的servlet对象 */ @Bean public ServletRegistrationBean statViewServlet() &#123; ServletRegistrationBean servletRegistrationBean = new ServletRegistrationBean(new StatViewServlet(), &quot;/druid/*&quot;); // 添加IP白名单 servletRegistrationBean.addInitParameter(&quot;allow&quot;, &quot;192.168.14.32,127.0.0.1&quot;); // 添加IP黑名单，当白名单和黑名单重复时，黑名单优先级更高 servletRegistrationBean.addInitParameter(&quot;deny&quot;, &quot;192.168.14.32&quot;); // 添加控制台管理用户 servletRegistrationBean.addInitParameter(&quot;loginUsername&quot;, &quot;druid&quot;); servletRegistrationBean.addInitParameter(&quot;loginPassword&quot;, &quot;123456&quot;); // 是否能够重置数据 servletRegistrationBean.addInitParameter(&quot;resetEnable&quot;, &quot;false&quot;); return servletRegistrationBean; &#125; /** * 配置服务过滤器 * * @return 返回过滤器配置对象 */ @Bean public FilterRegistrationBean statFilter() &#123; FilterRegistrationBean filterRegistrationBean = new FilterRegistrationBean(new WebStatFilter()); // 添加过滤规则 filterRegistrationBean.addUrlPatterns(&quot;/*&quot;); // 忽略过滤格式 filterRegistrationBean.addInitParameter(&quot;exclusions&quot;, &quot;*.js,*.gif,*.jpg,*.png,*.css,*.ico,/druid/*,&quot;); return filterRegistrationBean; &#125;&#125;@ConfigurationProperties(prefix = &quot;spring.datasource&quot;)@Component@Datapublic class DatasourceConf &#123; private String url; private String username; private String password; private String driverClassName; private int initialSize; private int minIdle; private int maxActive; private int maxWait; private int timeBetweenEvictionRunsMillis; private int minEvictableIdleTimeMillis; private String validationQuery; private Boolean testWhileIdle; private Boolean testOnBorrow; private Boolean testOnReturn; private Boolean poolPreparedStatements; private int maxPoolPreparedStatementPerConnectionSize; private String filters; private String connectionProperties; private Boolean useGlobalDataSourceStat;&#125; 重新启动主程序，此时会报一个小错，具体原因是由于druid开启了如下配置，当数据库为h2并且需要执 行新增表操作时，sql统计分析会合并异常，具体看github上面的issue 12# 配置监控统计拦截的filters，去掉后监控界面sql无法统计filters: stat 检查 1.查看h2 ui,是否user表和数据是否写入 http://localhost:1016/h2-console/ 2.查看druid监控页面 http://127.0.0.1:1016/druid/sql.html 集成jooq generate工具 具体教程可见**springboot集成jooq** 扩展 这里和user有一些不同的是，我将h2的数据库类型改成了内存，结果jooq-codegen-maven无法生成 1234567&lt;!-- JDBC connection parameters --&gt;&lt;jdbc&gt; &lt;driver&gt;org.h2.Driver&lt;/driver&gt; &lt;url&gt;jdbc:h2:mem:test&lt;/url&gt; &lt;user&gt;sa&lt;/user&gt; &lt;password&gt;123456&lt;/password&gt;&lt;/jdbc&gt; 需要改成文件类型 1234567&lt;!-- JDBC connection parameters --&gt;&lt;jdbc&gt; &lt;driver&gt;org.h2.Driver&lt;/driver&gt; &lt;url&gt;jdbc:h2:~/testmovie&lt;/url&gt; &lt;user&gt;sa&lt;/user&gt; &lt;password&gt;123456&lt;/password&gt;&lt;/jdbc&gt; 因为h2选择的是内存数据库，不管我是否将h2数据库开启(程序运行或不运行),然后执行jooq generate,都无法生成 如果我将h2类型改为file,那么这个时候不能运行源程序，才能执行jooq generate，否则执行jooq generate的时候会报错数据库使用中 扩展 在maven package时，由于集成了jooq generate工具，会执行一遍，这样如果自己修改了相关类会被还原，所以在打包时希望不执行相关驱动可以加如下配置 放在pom驱动配置的configuration标签内 20181030更新:注意这个标签添加之后，无论编译打包甚至直接运行这个插件都不再生成相关东西，如果你现在需要重新运行一遍，请先提交或者保存你做过的修改，然后注释掉这个，运行完之后再加上，然后再将你做的修改重新添加回来 12&lt;!-- install 跳过 --&gt;&lt;skip&gt;true&lt;/skip&gt; 在打包的过程中，执行了springboot中的一些test，当从consul上远程读取yml配置时爆了如下错，忽略测试打包成功后，启动工程仍然报错，然而idea中自己run的时候却没有报错 对比了相关命令 远程yml配置中含有中文，务必在使用java -Dfile.encoding=UTF-8 -jar .\consul-movie-0.0.1-SNAPSHOT.jar指定utf8编码 不然打包会失败，启动失败，会报上面的错 https://github.com/jOOQ/jOOQ/blob/master/jOOQ-examples/jOOQ-spring-example/pom.xml]]></content>
      <categories>
        <category>java</category>
        <category>微服务</category>
        <category>springcloud</category>
        <category>实战</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>springcloud</tag>
        <tag>jooq</tag>
        <tag>h2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springcloud集成feign]]></title>
    <url>%2Fblog%2F2018%2F10%2F29%2Fspringcloud%E9%9B%86%E6%88%90feign%2F</url>
    <content type="text"><![CDATA[前言 Feign是声明式、模板化的HTTP客户端，可以更加快捷优雅的调用HTTP API。在部分场景下和Ribbon类似，都是进行数据的请求处理，但是在请求参数使用实体类的时候显然更加方便，同时还支持安全性、授权控制等。 Feign是集成了Ribbon的，也就是说如果引入了Feign，那么Ribbon的功能也能使用，比如修改负载均衡策略等。 目的 1.springcloud Finchley.SR2版本 2.springboot 版本2.0.6.RELEASE 以consul为服务发现和配置中心的前提下，集成一个针对**springcloud编写用户微服务**的用户消费服务 正文 初始化工程 方法跟**springcloud集成consul**中前期准备工程一般，勾选下列依赖 如果不是上述方法初始化，添加依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;&lt;/dependency&gt; 在resources文件夹下新增bootstrap.yml文件，写入以下内容 123456789101112131415161718192021222324252627282930313233343536#tomcat启动启动端口server: port: 1020spring: application: #项目名称 name: consul-feign cloud: consul: #consul server的host或者ip host: localhost #consul server的端口 port: 18500 config: #开启consul配置中心 enabled: true #consul表示consul上面文件的格式 有四种 YAML PROPERTIES KEY-VALUE FILES format: YAML #表示consul上面的KEY值(或者说文件的名字) 默认是data data-key: configuration #prefix设置配置值的基本文件夹 prefix: config #defaultContext设置所有应用程序使用的文件夹名 default-context: $&#123;spring.application.name&#125; discovery: #开启consul服务发现 enabled: true #开启consul服务的名称 service-name: consul-feign #服务检查的路径 health-check-path: /actuator/health #服务检查的时间间隔 health-check-interval: 10s #服务检查的完整路径 health-check-url: http://192.168.0.150:$&#123;server.port&#125;$&#123;spring.cloud.consul.discovery.health-check-path&#125; tags: dev 添加controller类和feign接口 这里的user类就是springcloud编写用户微服务中jooq-codegen-maven3.10.8生成的实体对象 所以最好是将这些实体模块化，这样在共同需要的地方引用即可，不用像我这样图简便就直接复制过来 1234567891011121314151617181920@RestController@RequestMapping(&quot;/user&quot;)public class UserController &#123; @Autowired UserFeignClient userFeignClient; @RequestMapping(value = &quot;/getAll&quot;,method = RequestMethod.GET) public List&lt;User&gt; getAll()&#123; return userFeignClient.getAllUser(); &#125;&#125;@FeignClient(name = &quot;consul-user&quot;)public interface UserFeignClient &#123; @RequestMapping(value = &quot;/user/getAll&quot;,method = RequestMethod.GET) List&lt;User&gt; getAllUser();&#125; 20181030更新:get多参数写法 12直接写Long id或者直接是User user这种对象，feign依然会用post方式调用，所以会报错接口不支持需要用@RequestParam(&quot;id&quot;) Long id，或者@RequestParam Map&lt;String,Object&gt; map 最终的工程结构 修改主类 主类上添加@EnableFeignClients注解，否则报错找不到UserFeignClient 集成健康检查和hystrix 添加依赖 1234567891011121314健康检查需加依赖&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt;hystrix需加&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix&lt;/artifactId&gt;&lt;/dependency&gt; 远程配置添加健康检查详细监控以及支持hystrix 12345678910111213#Actuator的健康检查开启所有包括health，info，metrics等management: endpoints: web: exposure: include: &quot;*&quot; #开启health端点详细检查 endpoint: health: show-details: alwaysfeign: hystrix: enabled: true 修改主类 主类上添加@EnableHystrix注解，否则没有/actuator/hystrix.stream信息，另外上面的配置需要打开，不然没数据]]></content>
      <categories>
        <category>java</category>
        <category>springcloud</category>
        <category>feign</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>springcloud</tag>
        <tag>feign</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springcloud集成网关ZUUL]]></title>
    <url>%2Fblog%2F2018%2F10%2F29%2Fspringcloud%E9%9B%86%E6%88%90%E7%BD%91%E5%85%B3ZUUL%2F</url>
    <content type="text"><![CDATA[前言 Routing in an integral part of a microservice architecture. For example, / may be mapped to your web application, /api/users is mapped to the user service and /api/shop is mapped to the shop service. Zuul is a JVM based router and server side load balancer by Netflix. 路由在微服务架构的一个组成部分。 例如，/可以映射到您的Web应用程序，/api/users映射到用户服务，并且/api/shop映射到商店服务。 Zuul是Netflix的基于JVM的路由器和服务器端负载均衡器。 其功能包括 12345678910验证见解压力测试金丝雀测试动态路由服务迁移减载安全静态响应处理主动/主动流量管理 Zuul的规则引擎允许规则和过滤器基本上用任何JVM语言编写，内置支持Java和Groovy 目的 1.springcloud Finchley.SR2版本 2.springboot 版本2.0.6.RELEASE 以consul为服务发现和配置中心的前提下，集成一个zuul网关服务 正文 初始化工程 方法跟**springcloud集成consul**中前期准备工程一般，勾选下列依赖 20181029更新:上面不用勾选hystrix,下面也说明了zuul中已经集成了 在resources文件夹下新增bootstrap.yml文件，写入以下内容 123456789101112131415161718192021222324252627282930313233343536#tomcat启动启动端口server: port: 1050spring: application: #项目名称 name: consul-zuul cloud: consul: #consul server的host或者ip host: localhost #consul server的端口 port: 18500 config: #开启consul配置中心 enabled: true #consul表示consul上面文件的格式 有四种 YAML PROPERTIES KEY-VALUE FILES format: YAML #表示consul上面的KEY值(或者说文件的名字) 默认是data data-key: configuration #prefix设置配置值的基本文件夹 prefix: config #defaultContext设置所有应用程序使用的文件夹名 default-context: $&#123;spring.application.name&#125; discovery: #开启consul服务发现 enabled: true #开启consul服务的名称 service-name: consul-zuul #服务检查的路径 health-check-path: /actuator/health #服务检查的时间间隔 health-check-interval: 10s #服务检查的完整路径 health-check-url: http://192.168.0.150:$&#123;server.port&#125;$&#123;spring.cloud.consul.discovery.health-check-path&#125; tags: dev 在远程配置中心上添加如下配置 123456789101112131415zuul: routes: user: # 可以随便写，在zuul上面唯一即可；当这里的值 = service-id时，service-id可以不写。 path: /api/user/** # 想要映射到的路径 service-id: consul-user # consul中的service-name#Actuator的健康检查开启所有包括health，info，metrics等management: endpoints: web: exposure: include: &quot;*&quot; #开启health端点详细检查 endpoint: health: show-details: always 修改主类，在主类上加上@EnableZuulProxy注解，这样就完成了 扩展 由于zuul已经集成hystrix，所以当打开详细健康检查时可以看到hystrix已经打开 同时查看 http://localhost:1050/actuator/hystrix.stream 注意当没有接口调用时，会显示一直ping,需要调用一个接口，这个页面数据是实时刷新的 参考资料 1.自定义zuul过滤器 2.zuul比较详细的说明 3.springcloud+zuul+hystrix]]></content>
      <categories>
        <category>java</category>
        <category>springcloud</category>
        <category>zuul</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>springcloud</tag>
        <tag>zuul</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springboot集成jooq]]></title>
    <url>%2Fblog%2F2018%2F10%2F26%2Fspringboot%E9%9B%86%E6%88%90jooq%2F</url>
    <content type="text"><![CDATA[前言 说明一下springboot2.0.6.RELEASE集成jooq3.10.8以及jooq-codegen-maven3.10.8 目的 简单说明一下jooq的集成和用法 正文 初始化工程 idea初始化工程方法可以参见**springcloud编写用户微服务** h2 以h2为梨子说明一下 添加依赖 123456789&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jooq&lt;/artifactId&gt;&lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.h2database&lt;/groupId&gt; &lt;artifactId&gt;h2&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt;&lt;/dependency&gt; 扩展 这种不需要写版本的是因为父工程为springboot或者用下面那种写法 123456789101112131415161718&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.0.6.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;&lt;/parent&gt;或者&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-cloud.version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/dependencyManagement&gt; 添加驱动工具 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970&lt;plugin&gt; &lt;!-- Specify the maven code generator plugin --&gt; &lt;!-- Use org.jooq for the Open Source Edition org.jooq.pro for commercial editions, org.jooq.pro-java-6 for commercial editions with Java 6 support, org.jooq.trial for the free trial edition Note: Only the Open Source Edition is hosted on Maven Central. Import the others manually from your distribution --&gt; &lt;groupId&gt;org.jooq&lt;/groupId&gt; &lt;artifactId&gt;jooq-codegen-maven&lt;/artifactId&gt; &lt;!-- The plugin should hook into the generate goal --&gt; &lt;executions&gt; &lt;execution&gt; &lt;goals&gt; &lt;goal&gt;generate&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;!-- Manage the plugin&apos;s dependency. In this example, we&apos;ll use a PostgreSQL database --&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.h2database&lt;/groupId&gt; &lt;artifactId&gt;h2&lt;/artifactId&gt; &lt;version&gt;1.4.197&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;!-- Specify the plugin configuration. The configuration format is the same as for the standalone code generator --&gt; &lt;configuration&gt; &lt;!-- install 跳过 --&gt; &lt;skip&gt;true&lt;/skip&gt; &lt;!-- JDBC connection parameters --&gt; &lt;jdbc&gt; &lt;driver&gt;org.h2.Driver&lt;/driver&gt; &lt;url&gt;jdbc:h2:~/testuser&lt;/url&gt; &lt;user&gt;sa&lt;/user&gt; &lt;password&gt;123456&lt;/password&gt; &lt;/jdbc&gt; &lt;!-- Generator parameters --&gt; &lt;generator&gt; &lt;database&gt; &lt;name&gt;org.jooq.util.h2.H2Database&lt;/name&gt; &lt;includes&gt;.*&lt;/includes&gt; &lt;excludes&gt;&lt;/excludes&gt; &lt;!-- In case your database supports catalogs, e.g. SQL Server: &lt;inputCatalog&gt;public&lt;/inputCatalog&gt; --&gt; &lt;inputSchema&gt;PUBLIC&lt;/inputSchema&gt; &lt;/database&gt; &lt;generate&gt; &lt;instanceFields&gt;true&lt;/instanceFields&gt; &lt;pojos&gt;true&lt;/pojos&gt; &lt;daos&gt;true&lt;/daos&gt; &lt;springAnnotations&gt;true&lt;/springAnnotations&gt; &lt;/generate&gt; &lt;target&gt; &lt;packageName&gt;com.springcloud.consuluser.dao&lt;/packageName&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;/target&gt; &lt;/generator&gt; &lt;/configuration&gt;&lt;/plugin&gt; 扩展 1.这是以h2作为梨子，如果要用mysql的话差不过需要修改相关位置 2.maven package打包忽略插件 放在pom驱动配置的configuration标签内 20181030更新:注意这个标签添加之后，无论编译打包甚至直接运行这个插件都不再生成相关东西，如果你现在需要重新运行一遍，请先提交或者保存你做过的修改，然后注释掉这个，运行完之后再加上，然后再将你做的修改重新添加回来 12&lt;!-- install 跳过 --&gt;&lt;skip&gt;true&lt;/skip&gt; 3.需要生成相关dao和实体，添加如下配置 123456&lt;generate&gt; &lt;instanceFields&gt;true&lt;/instanceFields&gt; &lt;pojos&gt;true&lt;/pojos&gt; &lt;daos&gt;true&lt;/daos&gt; &lt;springAnnotations&gt;true&lt;/springAnnotations&gt;&lt;/generate&gt; 4.20181030更新:当h2的数据库类型为内存时，结果jooq-codegen-maven无法生成 1234567&lt;!-- JDBC connection parameters --&gt;&lt;jdbc&gt; &lt;driver&gt;org.h2.Driver&lt;/driver&gt; &lt;url&gt;jdbc:h2:mem:test&lt;/url&gt; &lt;user&gt;sa&lt;/user&gt; &lt;password&gt;123456&lt;/password&gt;&lt;/jdbc&gt; 需要改成文件类型 1234567&lt;!-- JDBC connection parameters --&gt;&lt;jdbc&gt; &lt;driver&gt;org.h2.Driver&lt;/driver&gt; &lt;url&gt;jdbc:h2:~/testmovie&lt;/url&gt; &lt;user&gt;sa&lt;/user&gt; &lt;password&gt;123456&lt;/password&gt;&lt;/jdbc&gt; jooq-codegen-maven以上配置生成的目录结构如下 yml配置文件添加相关配置 123456789101112131415161718192021222324252627282930313233343536373839404142spring: datasource: #url: jdbc:h2:mem:test #url: jdbc:h2:file:~/.h2/testdb url: jdbc:h2:~/testuser driverClassName: org.h2.Driver username: sa password: 123456 platform: h2 schema: classpath:db/schema.sql data: classpath:db/data.sql initialization-mode: always #springboot2.0加上上述sql才会执行 # 下面为druid连接池的补充设置，应用到上面所有数据源中 # 初始化大小，最小，最大 initialSize: 1 minIdle: 3 maxActive: 20 # 配置获取连接等待超时的时间 maxWait: 60000 # 配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位是毫秒 timeBetweenEvictionRunsMillis: 60000 # 配置一个连接在池中最小生存的时间，单位是毫秒 minEvictableIdleTimeMillis: 30000 validationQuery: select &apos;x&apos; testWhileIdle: true testOnBorrow: false testOnReturn: false # 打开PSCache，并且指定每个连接上PSCache的大小 poolPreparedStatements: true maxPoolPreparedStatementPerConnectionSize: 20 # 配置监控统计拦截的filters，去掉后监控界面sql无法统计 filters: stat # 通过connectProperties属性来打开mergeSql功能；慢SQL记录 connectionProperties: druid.stat.mergeSql=true;druid.stat.slowSqlMillis=5000 # 合并多个DruidDataSource的监控数据 useGlobalDataSourceStat: true h2: console: settings: web-allow-others: true #进行该配置后，h2 web consloe就可以在远程访问了。否则只能在本机访问。 path: /h2-console #进行该配置，你就可以通过YOUR_URL/h2-console访问h2 web consloe。YOUR_URL是你程序的访问URl。 enabled: true #进行该配置，程序开启时就会启动h2 web consloe。当然这是默认的，如果你不想在启动程序时启动h2 web consloe，那么就设置为false。 扩展 1.上面的配置中添加initialization-mode之后才会初始化schema.sql和data.sql 2.initialization-mode配置之后的是druid的补充配置，需结合java程序手动初始化或者添加spring.datasource.type=com.alibaba.druid.pool.DruidDataSource自动初始化，不过这种初始化之前我的druid监控页面无法打开 3.h2的控制页面配置如上，如果不加无法访问 4.集成druid,详情见**springboot集成druid** 参考资料 java api doc jooq-codegen-maven其他配置 jooq官方example]]></content>
      <categories>
        <category>java</category>
        <category>springboot2</category>
        <category>jooq</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>springboot2</tag>
        <tag>jooq</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springboot集成druid]]></title>
    <url>%2Fblog%2F2018%2F10%2F26%2Fspringboot%E9%9B%86%E6%88%90druid%2F</url>
    <content type="text"><![CDATA[前言 Druid是Java语言中最好的数据库连接池。Druid能够提供强大的监控和扩展功能 目的 springboot2.0.6.RELEASE集成druid1.1.10 正文 添加依赖 12345&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.1.10&lt;/version&gt;&lt;/dependency&gt; 添加配置 123456789101112131415161718192021222324252627282930313233343536spring: datasource: #url: jdbc:h2:mem:test #url: jdbc:h2:file:~/.h2/testdb url: jdbc:h2:~/testuser driverClassName: org.h2.Driver username: sa password: 123456 platform: h2 schema: classpath:db/schema.sql data: classpath:db/data.sql initialization-mode: always #springboot2.0加上上述sql才会执行 # 下面为druid连接池的补充设置，应用到上面所有数据源中 # 初始化大小，最小，最大 initialSize: 1 minIdle: 3 maxActive: 20 # 配置获取连接等待超时的时间 maxWait: 60000 # 配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位是毫秒 timeBetweenEvictionRunsMillis: 60000 # 配置一个连接在池中最小生存的时间，单位是毫秒 minEvictableIdleTimeMillis: 30000 validationQuery: select &apos;x&apos; testWhileIdle: true testOnBorrow: false testOnReturn: false # 打开PSCache，并且指定每个连接上PSCache的大小 poolPreparedStatements: true maxPoolPreparedStatementPerConnectionSize: 20 # 配置监控统计拦截的filters，去掉后监控界面sql无法统计 filters: stat # 通过connectProperties属性来打开mergeSql功能；慢SQL记录 connectionProperties: druid.stat.mergeSql=true;druid.stat.slowSqlMillis=5000 # 合并多个DruidDataSource的监控数据 useGlobalDataSourceStat: true 初始化datasource 1.添加spring.datasource.type=com.alibaba.druid.pool.DruidDataSource自动初始化，不过这种初始化之前我的druid监控页面无法打开 2.利用java程序手动初始化 在java源码，springboot主程序的所在目录的子目录下，添加如下两个文件DataSourceBean.java和DatasourceConf.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102@ConfigurationProperties(prefix = &quot;spring.datasource&quot;)@Component@Datapublic class DatasourceConf &#123; private String url; private String username; private String password; private String driverClassName; private int initialSize; private int minIdle; private int maxActive; private int maxWait; private int timeBetweenEvictionRunsMillis; private int minEvictableIdleTimeMillis; private String validationQuery; private Boolean testWhileIdle; private Boolean testOnBorrow; private Boolean testOnReturn; private Boolean poolPreparedStatements; private int maxPoolPreparedStatementPerConnectionSize; private String filters; private String connectionProperties; private Boolean useGlobalDataSourceStat;&#125;@Configuration@Component@Datapublic class DataSourceBean &#123; private static final Logger LOGGER = LoggerFactory.getLogger(DataSourceBean.class); @Autowired DatasourceConf datasourceConf; @Bean public DataSource getDataSource() &#123; DruidDataSource datasource = new DruidDataSource(); datasource.setUrl(datasourceConf.getUrl()); datasource.setUsername(datasourceConf.getUsername()); datasource.setPassword(datasourceConf.getPassword()); datasource.setDriverClassName(datasourceConf.getDriverClassName()); //configuration datasource.setInitialSize(datasourceConf.getInitialSize()); datasource.setMinIdle(datasourceConf.getMinIdle()); datasource.setMaxActive(datasourceConf.getMaxActive()); datasource.setMaxWait(datasourceConf.getMaxWait()); datasource.setTimeBetweenEvictionRunsMillis(datasourceConf.getTimeBetweenEvictionRunsMillis()); datasource.setMinEvictableIdleTimeMillis(datasourceConf.getMinEvictableIdleTimeMillis()); datasource.setValidationQuery(datasourceConf.getValidationQuery()); datasource.setTestWhileIdle(datasourceConf.getTestWhileIdle()); datasource.setTestOnBorrow(datasourceConf.getTestOnBorrow()); datasource.setTestOnReturn(datasourceConf.getTestOnReturn()); datasource.setPoolPreparedStatements(datasourceConf.getPoolPreparedStatements()); datasource.setMaxPoolPreparedStatementPerConnectionSize(datasourceConf.getMaxPoolPreparedStatementPerConnectionSize()); datasource.setUseGlobalDataSourceStat(datasourceConf.getUseGlobalDataSourceStat()); try &#123; datasource.setFilters(datasourceConf.getFilters()); &#125; catch (SQLException e) &#123; LOGGER.error(&quot;druid configuration initialization filter: &quot; + e); &#125; datasource.setConnectionProperties(datasourceConf.getConnectionProperties()); return datasource; &#125; /** * 配置监控服务器 * * @return 返回监控注册的servlet对象 */ @Bean public ServletRegistrationBean statViewServlet() &#123; ServletRegistrationBean servletRegistrationBean = new ServletRegistrationBean(new StatViewServlet(), &quot;/druid/*&quot;); // 添加IP白名单 servletRegistrationBean.addInitParameter(&quot;allow&quot;, &quot;192.168.14.32,127.0.0.1&quot;); // 添加IP黑名单，当白名单和黑名单重复时，黑名单优先级更高 servletRegistrationBean.addInitParameter(&quot;deny&quot;, &quot;192.168.14.32&quot;); // 添加控制台管理用户 servletRegistrationBean.addInitParameter(&quot;loginUsername&quot;, &quot;druid&quot;); servletRegistrationBean.addInitParameter(&quot;loginPassword&quot;, &quot;123456&quot;); // 是否能够重置数据 servletRegistrationBean.addInitParameter(&quot;resetEnable&quot;, &quot;false&quot;); return servletRegistrationBean; &#125; /** * 配置服务过滤器 * * @return 返回过滤器配置对象 */ @Bean public FilterRegistrationBean statFilter() &#123; FilterRegistrationBean filterRegistrationBean = new FilterRegistrationBean(new WebStatFilter()); // 添加过滤规则 filterRegistrationBean.addUrlPatterns(&quot;/*&quot;); // 忽略过滤格式 filterRegistrationBean.addInitParameter(&quot;exclusions&quot;, &quot;*.js,*.gif,*.jpg,*.png,*.css,*.ico,/druid/*,&quot;); return filterRegistrationBean; &#125;&#125; 20191025更新 当集成oracle,配置需要修改 validationQuery: select ‘x’ FROM DUAL 1234567891011121314151617181920212223242526272829303132spring: datasource: url: jdbc:oracle:thin:@172.20.1.100:1521:orcl driverClassName: oracle.jdbc.OracleDriver username: sop password: sop platform: oracle initialization-mode: always #springboot2.0加上上述sql才会执行 # 下面为druid连接池的补充设置，应用到上面所有数据源中 # 初始化大小，最小，最大 initialSize: 1 minIdle: 3 maxActive: 20 # 配置获取连接等待超时的时间 maxWait: 60000 # 配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位是毫秒 timeBetweenEvictionRunsMillis: 60000 # 配置一个连接在池中最小生存的时间，单位是毫秒 minEvictableIdleTimeMillis: 30000 validationQuery: select 'x' FROM DUAL testWhileIdle: true testOnBorrow: false testOnReturn: false # 打开PSCache，并且指定每个连接上PSCache的大小 poolPreparedStatements: true maxPoolPreparedStatementPerConnectionSize: 20 # 配置监控统计拦截的filters，去掉后监控界面sql无法统计 filters: stat # 通过connectProperties属性来打开mergeSql功能；慢SQL记录 connectionProperties: druid.stat.mergeSql=true;druid.stat.slowSqlMillis=5000 # 合并多个DruidDataSource的监控数据 useGlobalDataSourceStat: true 监控地址为 http://localhost:8081/druid/ 参考资料 Druid 介绍及配置]]></content>
      <categories>
        <category>java</category>
        <category>springboot2</category>
        <category>druid</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>springboot2</tag>
        <tag>druid</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springcloud编写用户微服务]]></title>
    <url>%2Fblog%2F2018%2F10%2F26%2Fspringcloud%E7%BC%96%E5%86%99%E7%94%A8%E6%88%B7%E5%BE%AE%E6%9C%8D%E5%8A%A1%2F</url>
    <content type="text"><![CDATA[前言 1.springcloud Finchley.SR2版本 2.springboot 版本2.0.6.RELEASE 3.h2 4.jooq 5.consul 搭建一个用户微服务 目的 利用idea快速搭建一个springcloud集成上述功能的微服务，可以查询用户 正文 初始化工程 方法跟**springcloud集成consul**中前期准备工程一般，勾选下列依赖 在resources文件夹下新增bootstrap.yml文件，写入以下内容 123456789101112131415161718192021222324252627282930313233343536#tomcat启动启动端口server: port: 1016spring: application: #项目名称 name: consul-user cloud: consul: #consul server的host或者ip host: localhost #consul server的端口 port: 18500 config: #开启consul配置中心 enabled: true #consul表示consul上面文件的格式 有四种 YAML PROPERTIES KEY-VALUE FILES format: YAML #表示consul上面的KEY值(或者说文件的名字) 默认是data data-key: configuration #prefix设置配置值的基本文件夹 prefix: config #defaultContext设置所有应用程序使用的文件夹名 default-context: $&#123;spring.application.name&#125; discovery: #开启consul服务发现 enabled: true #开启consul服务的名称 service-name: consul-user #服务检查的路径 health-check-path: /actuator/health #服务检查的时间间隔 health-check-interval: 10s #服务检查的完整路径 health-check-url: http://192.168.0.101:$&#123;server.port&#125;$&#123;spring.cloud.consul.discovery.health-check-path&#125; tags: dev 启动主工程,查看consul ui发现程序正常注册 如果程序未能正常注册，查看程序是否正常启动或者这里的ip需要写成程序所在机器的ip,consul集群所在的机器能够访问 初始化H2数据库 由于已经使用了consul作为配置中心,直接在consul配置界面新增如下配置 启动之后发现datasource循环依赖 这时候决定手动初始化datasource,同时集成第三方数据库连接池进来，详情**springboot集成druid** 此时consul上的配置如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647spring: datasource: url: jdbc:h2:mem:test #内存 #url: jdbc:h2:file:~/.h2/testdb #文件 driverClassName: org.h2.Driver username: sa password: 123456 platform: h2 schema: classpath:db/schema.sql data: classpath:db/data.sql initialization-mode: always #springboot2.0加上上述sql才会执行 # 下面为druid连接池的补充设置，应用到上面所有数据源中 # 初始化大小，最小，最大 initialSize: 1 minIdle: 3 maxActive: 20 # 配置获取连接等待超时的时间 maxWait: 60000 # 配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位是毫秒 timeBetweenEvictionRunsMillis: 60000 # 配置一个连接在池中最小生存的时间，单位是毫秒 minEvictableIdleTimeMillis: 30000 validationQuery: select &apos;x&apos; testWhileIdle: true testOnBorrow: false testOnReturn: false # 打开PSCache，并且指定每个连接上PSCache的大小 poolPreparedStatements: true maxPoolPreparedStatementPerConnectionSize: 20 # 配置监控统计拦截的filters，去掉后监控界面sql无法统计 filters: stat # 通过connectProperties属性来打开mergeSql功能；慢SQL记录 connectionProperties: druid.stat.mergeSql=true;druid.stat.slowSqlMillis=5000 # 合并多个DruidDataSource的监控数据 useGlobalDataSourceStat: true h2: console: settings: web-allow-others: true #进行该配置后，h2 web consloe就可以在远程访问了。否则只能在本机访问。 path: /h2-console #进行该配置，你就可以通过YOUR_URL/h2-console访问h2 web consloe。YOUR_URL是你程序的访问URl。 enabled: true #进行该配置，程序开启时就会启动h2 web consloe。当然这是默认的，如果你不想在启动程序时启动h2 web consloe，那么就设置为false。logging: level: root: INFO org.hibernate: INFO org.hibernate.type.descriptor.sql.BasicBinder: TRACE org.hibernate.type.descriptor.sql.BasicExtractor: TRACE 根据配置在resources目录下，新增db文件夹，下面新增schema.sql和data.sql文件，内容分别如下 12345drop table user if exists;create table user (id bigint generated by default as identity ,username varchar(40),name varchar(20),age int(3),balance decimal(10,2),primary key (id));insert into user (id,username,name,age,balance) values (1,&apos;admin&apos;,&apos;zb&apos;,20,100.00);insert into user (id,username,name,age,balance) values (2,&apos;liuman&apos;,&apos;柳曼&apos;,20,101.00); 在pom中添加依赖druid 12345&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.1.10&lt;/version&gt;&lt;/dependency&gt; 在主程序平级目录新增db目录，新增DataSourceBean.java和DatasourceConf.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101@Configuration@Component@Datapublic class DataSourceBean &#123; private static final Logger LOGGER = LoggerFactory.getLogger(DataSourceBean.class); @Autowired DatasourceConf datasourceConf; @Bean public DataSource getDataSource() &#123; DruidDataSource datasource = new DruidDataSource(); datasource.setUrl(datasourceConf.getUrl()); datasource.setUsername(datasourceConf.getUsername()); datasource.setPassword(datasourceConf.getPassword()); datasource.setDriverClassName(datasourceConf.getDriverClassName()); //configuration datasource.setInitialSize(datasourceConf.getInitialSize()); datasource.setMinIdle(datasourceConf.getMinIdle()); datasource.setMaxActive(datasourceConf.getMaxActive()); datasource.setMaxWait(datasourceConf.getMaxWait()); datasource.setTimeBetweenEvictionRunsMillis(datasourceConf.getTimeBetweenEvictionRunsMillis()); datasource.setMinEvictableIdleTimeMillis(datasourceConf.getMinEvictableIdleTimeMillis()); datasource.setValidationQuery(datasourceConf.getValidationQuery()); datasource.setTestWhileIdle(datasourceConf.getTestWhileIdle()); datasource.setTestOnBorrow(datasourceConf.getTestOnBorrow()); datasource.setTestOnReturn(datasourceConf.getTestOnReturn()); datasource.setPoolPreparedStatements(datasourceConf.getPoolPreparedStatements()); datasource.setMaxPoolPreparedStatementPerConnectionSize(datasourceConf.getMaxPoolPreparedStatementPerConnectionSize()); datasource.setUseGlobalDataSourceStat(datasourceConf.getUseGlobalDataSourceStat()); try &#123; datasource.setFilters(datasourceConf.getFilters()); &#125; catch (SQLException e) &#123; LOGGER.error(&quot;druid configuration initialization filter: &quot; + e); &#125; datasource.setConnectionProperties(datasourceConf.getConnectionProperties()); return datasource; &#125; /** * 配置监控服务器 * * @return 返回监控注册的servlet对象 */ @Bean public ServletRegistrationBean statViewServlet() &#123; ServletRegistrationBean servletRegistrationBean = new ServletRegistrationBean(new StatViewServlet(), &quot;/druid/*&quot;); // 添加IP白名单 servletRegistrationBean.addInitParameter(&quot;allow&quot;, &quot;192.168.14.32,127.0.0.1&quot;); // 添加IP黑名单，当白名单和黑名单重复时，黑名单优先级更高 servletRegistrationBean.addInitParameter(&quot;deny&quot;, &quot;192.168.14.32&quot;); // 添加控制台管理用户 servletRegistrationBean.addInitParameter(&quot;loginUsername&quot;, &quot;druid&quot;); servletRegistrationBean.addInitParameter(&quot;loginPassword&quot;, &quot;123456&quot;); // 是否能够重置数据 servletRegistrationBean.addInitParameter(&quot;resetEnable&quot;, &quot;false&quot;); return servletRegistrationBean; &#125; /** * 配置服务过滤器 * * @return 返回过滤器配置对象 */ @Bean public FilterRegistrationBean statFilter() &#123; FilterRegistrationBean filterRegistrationBean = new FilterRegistrationBean(new WebStatFilter()); // 添加过滤规则 filterRegistrationBean.addUrlPatterns(&quot;/*&quot;); // 忽略过滤格式 filterRegistrationBean.addInitParameter(&quot;exclusions&quot;, &quot;*.js,*.gif,*.jpg,*.png,*.css,*.ico,/druid/*,&quot;); return filterRegistrationBean; &#125;&#125;@ConfigurationProperties(prefix = &quot;spring.datasource&quot;)@Component@Datapublic class DatasourceConf &#123; private String url; private String username; private String password; private String driverClassName; private int initialSize; private int minIdle; private int maxActive; private int maxWait; private int timeBetweenEvictionRunsMillis; private int minEvictableIdleTimeMillis; private String validationQuery; private Boolean testWhileIdle; private Boolean testOnBorrow; private Boolean testOnReturn; private Boolean poolPreparedStatements; private int maxPoolPreparedStatementPerConnectionSize; private String filters; private String connectionProperties; private Boolean useGlobalDataSourceStat;&#125; 重新启动主程序，此时会报一个小错，具体原因是由于druid开启了如下配置，当数据库为h2并且需要执 行新增表操作时，sql统计分析会合并异常，具体看github上面的issue 12# 配置监控统计拦截的filters，去掉后监控界面sql无法统计filters: stat 检查 1.查看h2 ui,是否user表和数据是否写入 http://localhost:1016/h2-console/ 2.查看druid监控页面 http://127.0.0.1:1016/druid/sql.html 集成jooq generate工具 具体教程可见**springboot集成jooq** 扩展 在maven package时，由于集成了jooq generate工具，会执行一遍，这样如果自己修改了相关类会被还原，所以在打包时希望不执行相关驱动可以加如下配置 放在pom驱动配置的configuration标签内 20181030更新:注意这个标签添加之后，无论编译打包甚至直接运行这个插件都不再生成相关东西，如果你现在需要重新运行一遍，请先提交或者保存你做过的修改，然后注释掉这个，运行完之后再加上，然后再将你做的修改重新添加回来 12&lt;!-- install 跳过 --&gt;&lt;skip&gt;true&lt;/skip&gt; 在打包的过程中，执行了springboot中的一些test，当从consul上远程读取yml配置时爆了如下错，忽略测试打包成功后，启动工程仍然报错，然而idea中自己run的时候却没有报错 对比了相关命令 远程yml配置中含有中文，务必在使用java -Dfile.encoding=UTF-8 -jar .\consul-user-0.0.1-SNAPSHOT.jar指定utf8编码 不然打包会失败，启动失败，会报上面的错 https://github.com/jOOQ/jOOQ/blob/master/jOOQ-examples/jOOQ-spring-example/pom.xml]]></content>
      <categories>
        <category>java</category>
        <category>微服务</category>
        <category>springcloud</category>
        <category>实战</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>springcloud</tag>
        <tag>jooq</tag>
        <tag>h2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springcloud集成consul]]></title>
    <url>%2Fblog%2F2018%2F10%2F23%2Fspringcloud%E9%9B%86%E6%88%90consul%2F</url>
    <content type="text"><![CDATA[前言 1.springcloud Finchley.SR2版本 2.springboot 版本2.0.6.RELEASE 集成consul作为配置中心和服务发现中心，同时开启健康检查 目的 利用idea快速搭建一个springcloud集成上述功能的微服务 正文 利用idea新建工程 新建springboot maven工程 设置项目信息 勾选自动配置 勾选consul配置中心 勾选consul服务发现中心 完成 新建bootstrap.yml文件,添加如下内容，并启动主程序 123456789101112131415161718192021222324252627282930313233343536#tomcat启动启动端口server: port: 1015spring: application: #项目名称 name: springcloud-consul cloud: consul: #consul server的host或者ip host: localhost #consul server的端口 port: 18500 config: #开启consul配置中心 enabled: true #consul表示consul上面文件的格式 有四种 YAML PROPERTIES KEY-VALUE FILES format: YAML #表示consul上面的KEY值(或者说文件的名字) 默认是data data-key: configuration #prefix设置配置值的基本文件夹 prefix: config #defaultContext设置所有应用程序使用的文件夹名 default-context: $&#123;spring.application.name&#125; discovery: #开启consul服务发现 enabled: true #开启consul服务的名称 service-name: springcloud-consul #服务检查的路径 health-check-path: /actuator/health #服务检查的时间间隔 health-check-interval: 10s #服务检查的完整路径 health-check-url: http://192.168.0.101:$&#123;server.port&#125;$&#123;spring.cloud.consul.discovery.health-check-path&#125; tags: dev 启动主程序,发现报错 添加依赖 1234 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt; 重新启动正常 访问健康检查端点 http://ip:port/actuator/health 在consul ui上查看 访问consul ui http://localhost:18500/ consul 作为配置中心 访问consul ui 添加配置信息 12app: port: 3232 新增conf目录，新增如下代码 12345678910111213141516@Component@ConfigurationProperties(prefix = &quot;app&quot;)@Datapublic class AppConf &#123; private static final Logger LOGGER = LoggerFactory.getLogger(AppConf.class); private int port; @PostConstruct public void printConf()&#123; LOGGER.info(&quot;加载配置port:[&#123;&#125;]&quot;,port); &#125;&#125; 重新启动主程序 附加 工程pom 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.springcloud&lt;/groupId&gt; &lt;artifactId&gt;consul1&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;name&gt;consul1&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.0.6.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;spring-cloud.version&gt;Finchley.SR2&lt;/spring-cloud.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-consul-config&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-consul-discovery&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-cloud.version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 参考资料 springcloud-consul中文文档]]></content>
      <categories>
        <category>java</category>
        <category>微服务</category>
        <category>springcloud</category>
        <category>consul</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>consul</tag>
        <tag>springcloud</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[windows上安装docker-ce]]></title>
    <url>%2Fblog%2F2018%2F10%2F21%2Fwindows%E4%B8%8A%E5%AE%89%E8%A3%85docker-ce%2F</url>
    <content type="text"><![CDATA[Welcome to my blog, enter password to read. Incorrect Password! No content to display! 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]]></content>
      <categories>
        <category>windows</category>
        <category>docker</category>
        <category>安装</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>安装</tag>
        <tag>windows</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[docker-compose搭建consul集群]]></title>
    <url>%2Fblog%2F2018%2F10%2F21%2Fdocker-compose%E6%90%AD%E5%BB%BAconsul%E9%9B%86%E7%BE%A4%2F</url>
    <content type="text"><![CDATA[Welcome to my blog, enter password to read. Incorrect Password! No content to display! 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]]></content>
      <categories>
        <category>docker-compose</category>
        <category>consul集群</category>
      </categories>
      <tags>
        <tag>docker-compose</tag>
        <tag>consul集群</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springboot+Aop+自定义注解实现日志记录]]></title>
    <url>%2Fblog%2F2018%2F10%2F21%2Fspringboot-Aop-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3%E5%AE%9E%E7%8E%B0%E6%97%A5%E5%BF%97%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[前言 AOP（Aspect Orient Programming），也就是面向方面编程，作为面向对象编程的一种补充，专门用于处理系统中分布于各个模块（不同方法）中的交叉关注点的问题，在Java EE应用中，常常通过AOP来处理一些具有横切性质的系统级服务，如事务管理、安全检查、缓存、对象池管理等。AOP实现的关键就在于AOP框架自动创建的AOP代理，AOP代理主要分为静态代理和动态代理两大类，静态代理以AspectJ为代表；而动态代理则以Spring AOP为代表 目的 简单说明一下AspectJ，另外实现一个springboot+Aop+自定义注解实现日志记录的梨子 正文 AspectJ AspectJ 是一个基于 Java 语言的 AOP 框架，提供了强大的 AOP 功能，其他很多 AOP 框架都借鉴或采纳其中的一些思想。 AspectJ 是 Java 语言的一个 AOP 实现，其主要包括两个部分：第一个部分定义了如何表达、定义 AOP 编程中的语法规范，通过这套语言规范，我们可以方便地用 AOP 来解决 Java 语言中存在的交叉关注点问题；另一个部分是工具部分，包括编译器、调试工具等。 AspectJ 是编译期增强的框架，需要遵从相关语法然后用他的工具编译织入 springboot aop 添加依赖 123456789101112&lt;!-- AOP依赖模块 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!-- 测试 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667自定义注解@Target(ElementType.METHOD)@Retention(RetentionPolicy.RUNTIME)public @interface AnalysisActuator &#123; String note() default &quot;&quot;;&#125;定义切面@Aspect@Componentpublic class AnalysisActuatorAspect &#123; final static Logger log = LoggerFactory.getLogger(AnalysisActuatorAspect.class); ThreadLocal&lt;Long&gt; beginTime = new ThreadLocal&lt;&gt;(); @Pointcut(&quot;@annotation(analysisActuator)&quot;) public void serviceStatistics(AnalysisActuator analysisActuator) &#123; &#125; @Before(&quot;serviceStatistics(analysisActuator)&quot;) public void doBefore(JoinPoint joinPoint, AnalysisActuator analysisActuator) &#123; // 记录请求到达时间 beginTime.set(System.currentTimeMillis()); &#125; @After(&quot;serviceStatistics(analysisActuator)&quot;) public void doAfter(AnalysisActuator analysisActuator) &#123; log.info(&quot;statistic time:&#123;&#125;, note:&#123;&#125;&quot;, System.currentTimeMillis() - beginTime.get(), analysisActuator.note()); &#125;&#125;服务改写@Servicepublic class PersonServiceForAopImpl implements PersonService &#123; @AnalysisActuator(note = &quot;[PersonServiceForAopImpl]插入&quot;) @Override public int insert(Object obj) &#123; System.out.println(&quot;成功插入一个person&quot;); return 1; &#125; @AnalysisActuator(note = &quot;[PersonServiceForAopImpl]更新&quot;) @Override public int update(Object obj) &#123; System.out.println(&quot;成功更新一个person&quot;); return 1; &#125;&#125;测试服务@RunWith(SpringRunner.class)@SpringBootTestpublic class TestPersonServiceForAopImpl &#123; @Qualifier(&quot;personServiceForAopImpl&quot;) @Autowired PersonService personService; @Test public void testInsert()&#123; personService.insert(new Object()); &#125;&#125; 执行结果 参考资料 1.Spring AOP实现原理与CGLIB应用 2.使用Spring Boot的AOP处理自定义注解]]></content>
      <categories>
        <category>java</category>
        <category>springboot</category>
        <category>aop</category>
        <category>注解</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>springboot</tag>
        <tag>aop</tag>
        <tag>注解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CGLib代理]]></title>
    <url>%2Fblog%2F2018%2F10%2F21%2FCGLib%E4%BB%A3%E7%90%86%2F</url>
    <content type="text"><![CDATA[前言 **java动态代理**这篇博客介绍了java的动态代理，那么这里同样不得不介绍一下CGLib代理。JDK的动态代理机制只能代理实现了接口的类，而不能实现接口的类就不能实现JDK的动态代理.cglib是针对类来实现代理的，他的原理是对指定的目标类生成一个子类，并覆盖其中方法实现增强，但因为采用的是继承，所以不能对final修饰的类进行代理 目的 简单介绍一下cglib的代理应用 正文 同样用java动态代理的那个梨子 cglib代理 添加依赖 12345&lt;dependency&gt; &lt;groupId&gt;cglib&lt;/groupId&gt; &lt;artifactId&gt;cglib&lt;/artifactId&gt; &lt;version&gt;3.2.4&lt;/version&gt;&lt;/dependency&gt; 12345678910111213141516171819202122232425262728293031public class CglibProxyInterceptor implements MethodInterceptor &#123; //通过Enhancer 创建代理对象 private Enhancer enhancer = new Enhancer(); //通过Class对象获取代理对象 public &lt;T&gt; T getProxy(Class c)&#123; //设置创建子类的类 enhancer.setSuperclass(c); enhancer.setCallback(this); return (T)enhancer.create(); &#125; @Override public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable &#123; System.out.println(&quot;CglibProxyInterceptor 代理方法&quot;); return methodProxy.invokeSuper(o,objects); &#125; public static void main(String[] args) &#123; //原来的调用方式 PersonService personService = new PersonServiceImpl(); personService.insert(new Object()); personService.update(new Object()); System.out.println(&quot;**********************&quot;); CglibProxyInterceptor proxy = new CglibProxyInterceptor(); PersonService personServiceProxy = proxy.getProxy(PersonServiceImpl.class); personServiceProxy.insert(new Object()); personServiceProxy.update(new Object()); &#125;&#125; 执行结果 与java动态代理相比 123456相同点: 1.两个都新增了一个代理类，代理的类限制不大,扩展性很高 2.两种方式都不需要修改接口类以及实现类，只需要修改调用的地方即可，利用代理类调用不同点: 1.jdk动态代理需要对接口代理，cglib对非final修辞的类都可以代理 2.cglib是第三方包,需要添加依赖]]></content>
      <categories>
        <category>java</category>
        <category>CGLib</category>
        <category>代理</category>
      </categories>
      <tags>
        <tag>CGLib</tag>
        <tag>代理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java动态代理]]></title>
    <url>%2Fblog%2F2018%2F10%2F21%2Fjava%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%2F</url>
    <content type="text"><![CDATA[前言 **java反射基础用法**这边博客讲解了java反射的一些基础用法，那么动态代理就是利用反射实现的一个高级用法 目的 简单介绍一下动态代理的用法，JDK提供的代理只能针对接口做代理,我们有更强大的代理**CGLib代理** 正文 假设有个personservice服务类接口以及实现类，现如今需要在尽可能少量修改代码的前提下，让原来的方法增加一些其他方法 1234567891011121314151617181920212223public interface PersonService &#123; //插入一个person int insert(Object obj); //更新一个person int update(Object obj);&#125;public class PersonServiceImpl implements PersonService &#123; @Override public int insert(Object obj) &#123; System.out.println(&quot;成功插入一个person&quot;); return 1; &#125; @Override public int update(Object obj) &#123; System.out.println(&quot;成功更新一个person&quot;); return 1; &#125;&#125; 静态代理 123456789101112131415161718192021222324252627282930313233public class SimplePersonServiceProxy implements PersonService&#123; //被代理接口类 private PersonService personService; public SimplePersonServiceProxy(PersonService personService) &#123; this.personService = personService; &#125; @Override public int insert(Object obj) &#123; System.out.println(&quot;SimplePersonServiceProxy 插入静态代理方法&quot;); return personService.insert(obj); &#125; @Override public int update(Object obj) &#123; System.out.println(&quot;SimplePersonServiceProxy 更新静态代理方法&quot;); return personService.update(obj); &#125; public static void main(String[] args) &#123; //原来的调用方式 PersonService personService = new PersonServiceImpl(); personService.insert(new Object()); personService.update(new Object()); System.out.println(&quot;**********************&quot;); //增加功能的调用方法，原来的PersonService和PersonServiceImpl代码都不需要变 PersonService proxy = new SimplePersonServiceProxy(new PersonServiceImpl()); proxy.insert(new Object()); proxy.update(new Object()); &#125;&#125; 执行结果: 动态代理 12345678910111213141516171819202122232425262728public class DynamicProxyHandler implements InvocationHandler &#123; //被代理对象，这里跟静态代理对比，这里的代码扩展性更高，可以是任何对象 private Object object; public DynamicProxyHandler(Object object) &#123; this.object = object; &#125; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; System.out.println(&quot;DynamicProxyHandler java动态代理方法&quot;); return method.invoke(object,args); &#125; public static void main(String[] args) &#123; //原来的调用方式 PersonService personService = new PersonServiceImpl(); personService.insert(new Object()); personService.update(new Object()); System.out.println(&quot;**********************&quot;); //增加功能的调用方法，原来的PersonService和PersonServiceImpl代码都不需要变 PersonService proxy = (PersonService) Proxy.newProxyInstance(PersonService.class.getClassLoader(),new Class[]&#123;PersonService.class&#125;,new DynamicProxyHandler(new PersonServiceImpl())); proxy.insert(new Object()); proxy.update(new Object()); &#125;&#125; 执行结果: 对比两种方式，我们可以得出结论 123456789相同点: 1.两个都新增了一个代理类，并且属性都是代理类，只不过静态代理的属性限制的更大，必须是 代理接口类 2.两种方式都不需要修改接口类以及实现类，只需要修改调用的地方即可，利用代理类调用不同点 1.静态代理需要实现代理接口，并且属性为代理类接口，这说明每个接口都需要实现一个静态代 理类，扩展性不高，正因为如此，其每个代理的类中的方法可以各自写相关的代理方法 2.动态代理类由于其属性为Object,所以可以代理任何接口,扩展性高，不过由于每个方法执行 前的代理方法都是一样的，所以更适合做一些通用的代理]]></content>
      <categories>
        <category>java</category>
        <category>动态代理</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>动态代理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java反射基础用法]]></title>
    <url>%2Fblog%2F2018%2F10%2F15%2Fjava%E5%8F%8D%E5%B0%84%E5%9F%BA%E7%A1%80%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[前言 Java让我们在运行时识别对象和类的信息，主要有2种方式: 12传统的RTTI，它假定我们在编译时已经知道了所有的类型信息;反射机制，它允许我们在运行时发现和使用类的信息; 目的 简单介绍一下反射的机制和应用. 正文 class对象 class对象包含了与类有关的信息,是用来创建所有“常规”对象的.每个类都会产生一个对应的Class对象，也就是保存在.class文件。所有类都是在对其第一次使用时，动态加载到JVM的，当程序创建一个对类的静态成员的引用时，就会加载这个类.Class对象仅在需要的时候才会加载，static初始化是在类加载时进行的 扩展 1234567891011121314151617181920212223242526272829303132public class TestClass &#123; public static void main(String[] args) &#123; //静态内部类-静态属性 System.out.println(InnerClass.staticName); System.out.println(&quot;**************************&quot;); //静态内部类-普通属性 InnerClass in = new InnerClass(); System.out.println(in.name); System.out.println(&quot;**************************&quot;); //外部类-普通属性 System.out.println(new OutterClass().outterName); System.out.println(&quot;**************************&quot;); //外部类-静态属性 System.out.println(OutterClass.outterStaticName); &#125; static class InnerClass &#123; public static String staticName = &quot;innerStaticName&quot;; public String name = &quot;innerName&quot;; static &#123; System.out.println(&quot;静态内部类静态块&quot;); &#125; public InnerClass() &#123; System.out.println(&quot;静态内部类已经构造好了&quot;); &#125; &#125;&#125; 上面代码运行的结果: 结论: 说明当第一次引用一个类的静态属性时，该类会加载到jvm中并调用静态块初始化类时会调用相应构造方法，由于该类已经加载到jvm中，所以不会调用静态块第三点同时印证了第二点，第一次初始化某个类时，该类加载到jvm中，首先调用静态块方法，然后调用相应构造方法第四点印证第二点 获取class对象引用的两种方式及区别 12使用功能”.class”来创建Class对象的引用使用功能Class.forName(“xxx”) 区别: 想在运行时使用类型信息，必须获取对象(比如类Base对象)的Class对象的引用，使用功能Class.forName(“Base”)可以实现该目的，或者使用base.class。注意，有一点很有趣，使用功能”.class”来创建Class对象的引用时，不会自动初始化该Class对象，使用forName()会自动初始化该Class对象。为了使用类而做的准备工作一般有以下3个步骤: 123加载：由类加载器完成，找到对应的字节码，创建一个Class对象链接：验证类中的字节码，为静态域分配空间初始化：如果该类有超类，则对其初始化，执行静态初始化器和静态初始化块 扩展 1234567891011121314151617181920212223242526272829303132333435363738394041public class BaseMain &#123; public static void main(String[] args) throws Exception &#123; //通过obj.class获取class对象的引用 Class clz1 = StaticBase.class; System.out.println(&quot;*********************&quot;); //通过Class.获取class对象的引用--静态内部类 Class clz2 = Class.forName(&quot;com.example.demo.java.reflect.BaseMain$StaticBase&quot;); //通过Class.获取class对象的引用--普通内部类 Class clz3 = Class.forName(&quot;com.example.demo.java.reflect.BaseMain$Base&quot;); System.out.println(&quot;*********************&quot;); //内部类的构造方法获取 clz3也可以换成Base.class Constructor con3 = clz3.getDeclaredConstructor(BaseMain.class); //私有构造需要设置 con3.setAccessible(true); Object obj3 = con3.newInstance(BaseMain.class.newInstance()); &#125; static class StaticBase &#123; static int num = 1; static &#123; System.out.println(&quot;StaticBase 静态块:num = &quot; + num); &#125; &#125; public class BaseParent&#123; public BaseParent() &#123; System.out.println(&quot;父类被构造了&quot;); &#125; &#125; private class Base extends BaseParent&#123; int num = 2; private Base() &#123; System.out.println(&quot;普通内部类被构造了:num = &quot; + num); &#125; &#125;&#125; 执行结果: 结论 123obj.class确实不会初始化类Class.forName会调用静态块初始化子类构造先初始化父类构造 反射获取私有属性和方法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class ReflectDemo &#123; public static void main(String[] args) throws Exception &#123; OutterClass out = new OutterClass(); System.out.println(&quot;***************&quot;); getAllFields(out); System.out.println(&quot;***************&quot;); getAllMethods(out); &#125; /** * 获取一个对象的所有属性 * @param obj */ public static void getAllFields (Object obj) throws Exception&#123; //获取该类包括父类的属性，未注释的表示只有该类的 //Field[] fields = obj.getClass().getFields(); Field[] fields = obj.getClass().getDeclaredFields(); for(Field f : fields)&#123; f.setAccessible(true); System.out.println(&quot;属性-值:&quot;+f.getName()+&quot;-&quot;+f.get(obj)); &#125; &#125; public static void getAllMethods (Object obj) throws Exception &#123; //获取该类包括父类的属性，未注释的表示只有该类的 //Method[] methods = obj.getClass().getMethods(); Method[] methods = obj.getClass().getDeclaredMethods(); for(Method m : methods)&#123; m.setAccessible(true); System.out.println(m+&quot;\n参数个数:&quot;+m.getParameterCount()); switch (m.getParameterCount())&#123; case 0: m.invoke(obj); break; case 1: m.invoke(obj,&quot;hello&quot;); break; default: System.out.println(&quot;参数个数大于1&quot;); &#125; &#125; &#125;&#125; 执行结果:]]></content>
      <categories>
        <category>java</category>
        <category>语法</category>
        <category>反射</category>
      </categories>
      <tags>
        <tag>java语法</tag>
        <tag>反射</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[okhttp3链式调用]]></title>
    <url>%2Fblog%2F2018%2F10%2F13%2Fokhttp3%E9%93%BE%E5%BC%8F%E8%B0%83%E7%94%A8%2F</url>
    <content type="text"><![CDATA[前言 HTTP是现代应用常用的一种交换数据和媒体的网络方式，高效地使用HTTP能让资源加载更快，节省带宽。OkHttp是一个高效的HTTP客户端，它有以下默认特性： 1234支持HTTP/2，允许所有同一个主机地址的请求共享同一个socket连接连接池减少请求延时透明的GZIP压缩减少响应数据的大小缓存响应内容，避免一些完全重复的请求 目的 介绍一些okhttp3的基本用法 正文 获取OkHttpClient客户端 12345678//简单获取OkHttpClient client = new OkHttpClient();//设置超时时间private static final OkHttpClient client = new OkHttpClient.Builder() .connectTimeout(10, TimeUnit.SECONDS) .readTimeout(20, TimeUnit.SECONDS) .build(); get请求 普通get请求 1234567891011121314String url = &quot;https://www.baidu.com/&quot;;OkHttpClient okHttpClient = new OkHttpClient();Request request = new Request.Builder() .url(url) .build();Call call = okHttpClient.newCall(request);try &#123; Response response = call.execute(); if (response.isSuccessful()) &#123; System.out.println(response.body().string()); &#125;&#125; catch (IOException e) &#123; e.printStackTrace();&#125; 设置header参数 可以设置例如Cookie，User-Agent什么的 123456Request request = new Request.Builder() .url(url) .header(&quot;键&quot;, &quot;值&quot;) .header(&quot;键&quot;, &quot;值&quot;) ... .build(); post请求 普通的表单提交 1234567891011121314151617181920String url = &quot;https://www.baidu.com/&quot;;OkHttpClient okHttpClient = new OkHttpClient();RequestBody body = new FormBody.Builder() .add(&quot;键&quot;, &quot;值&quot;) .add(&quot;键&quot;, &quot;值&quot;) .build();Request request = new Request.Builder() .url(url) .post(body) .build();Call call = okHttpClient.newCall(request);try &#123; Response response = call.execute(); System.out.println(response.body().string());&#125; catch (IOException e) &#123; e.printStackTrace();&#125; 参考资料 OkHttp3的基本用法 简书 许宏川]]></content>
      <categories>
        <category>java</category>
        <category>http调用客户端</category>
      </categories>
      <tags>
        <tag>http调用客户端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[xxl-job-V1.9.1实现jobapi远程调用]]></title>
    <url>%2Fblog%2F2018%2F10%2F12%2Fxxl-job-V1-9-1%E5%AE%9E%E7%8E%B0jobapi%E8%BF%9C%E7%A8%8B%E8%B0%83%E7%94%A8%2F</url>
    <content type="text"><![CDATA[前言 **xxl-job**是一个非常好用的分布式java任务调度框架,目前实际应用中框架建议我们在其管理页面手动新增调度 任务,但是由于一些情况,我们更加希望能够通过代码动态添加job,官方在job-core中提供了相关api,位置:com.xxl.job.core.biz.AdminBiz.java但是提供的功能有限,无法满足我们的需求,但是根据后面官方的说法，可以通过修改xxl-jobadmin的源码,实现其部分接口可以绕过登陆来远程调用 目的 通过修改xxl-jobadmin的源码,实现其部分接口可以绕过登陆来远程调用: 1234567任务列表查询任务新增任务更新任务删除任务暂停任务恢复任务触发 正文 下载xxl-job-v1.9.1的源码 xxl-job-v1.9.1 下载地址 目前我们用的是v1.9.1的,此版本适合这种方式，如果是后续版本建议看一下官方文档，没准官方给出了更合适的方法 修改源码重新打包 准确修改位置为com.xxl.job.admin.controller.JobInfoController中的接口方法上加上@PermessionLimit(limit = false) 测试 通过postman调用接口,一个是未修改源码的,请求被登陆拦截 修改源码后，调用后通过json方式返回 参考资料 1.官方针对远程调用的方法解决]]></content>
      <categories>
        <category>java</category>
        <category>分布式</category>
        <category>任务调度框架</category>
      </categories>
      <tags>
        <tag>xxl-job</tag>
        <tag>分布式java调度框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux上安装docker-compose]]></title>
    <url>%2Fblog%2F2018%2F09%2F10%2Flinux%E4%B8%8A%E5%AE%89%E8%A3%85docker-compose%2F</url>
    <content type="text"><![CDATA[前言 linux上安装docker-compose,为了在安装了docker的机器上更加方便的编排容器 目的 利用docker-compose快速编排docker容器 正文 wget 1wget https://github.com/docker/compose/releases/download/1.22.0/docker-compose-Linux-x86_64 如果wget没有安装,利用下面命令安装 1yum install wget 另外如果wget下载不下来,因为直接从github上下载,国内可能网速并不理想 docker-compose v1.22.0 下载 提取码:ixnx mv并设置环境变量 1234567891011mv docker-compose-Linux-x86_64 docker-composemkdir -p /apps/softs/docker_compose/cd /apps/softs/docker_compose/cp /dev/zkandkafka/docker-compose /apps/softs/docker_compose/chmod +x docker-compose修改环境变量vi /etc/profileDOCKER_COMPOSE_HOME=/apps/softs/docker_compose/PATH=$PATH:$DOCKER_COMPOSE_HOMEexport PATHsource /etc/profile 验证 1docker-compose -v 其他 docker-compose版本]]></content>
      <categories>
        <category>docker-compose</category>
        <category>docker服务编排工具</category>
      </categories>
      <tags>
        <tag>docker-compose</tag>
        <tag>docker服务编排工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java程序打成docker镜像]]></title>
    <url>%2Fblog%2F2018%2F08%2F25%2Fjava%E7%A8%8B%E5%BA%8F%E6%89%93%E6%88%90docker%E9%95%9C%E5%83%8F%2F</url>
    <content type="text"><![CDATA[前言 本片教程适合idea+java+maven的环境,另外需要有docker环境,如果windows上没有，可以将程序拷贝到linux上有docker的环境上执行相关操作 docker环境安装教程[] 目的 将java程序打进docker镜像中,方便docker方式部署 正文 mavne添加以下依赖并执行生成Dockerfile 在pom文件的bulid中添加如下驱动 123456789101112131415161718192021&lt;plugin&gt; &lt;groupId&gt;com.spotify&lt;/groupId&gt; &lt;artifactId&gt;docker-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.0.0&lt;/version&gt; &lt;configuration&gt; &lt;imageName&gt;api&lt;/imageName&gt; &lt;baseImage&gt;java&lt;/baseImage&gt; &lt;maintainer&gt;test@email.com&lt;/maintainer&gt; &lt;workdir&gt;/ROOT&lt;/workdir&gt; &lt;cmd&gt;["java", "-version"]&lt;/cmd&gt; &lt;entryPoint&gt;["java", "-jar", "$&#123;project.build.finalName&#125;.jar"]&lt;/entryPoint&gt; &lt;!-- 这里是复制 jar 包到 docker 容器指定目录配置 --&gt; &lt;resources&gt; &lt;resource&gt; &lt;targetPath&gt;/ROOT&lt;/targetPath&gt; &lt;directory&gt;$&#123;project.build.directory&#125;&lt;/directory&gt; &lt;include&gt;$&#123;project.build.finalName&#125;.jar&lt;/include&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;/configuration&gt;&lt;/plugin&gt; 执行docker_build之后会自动生成Dockerfile,如果你的windows上有docker,会生成镜像,由于我的机器上没有，因为新版的docker安装到window上有 系统限制，详情查看这篇博客[] Dockerfile内容如下 123456FROM javaMAINTAINER test@email.comWORKDIR /ROOTADD /ROOT/xxx.jar /ROOT/ENTRYPOINT [&quot;java&quot;, &quot;-jar&quot;, &quot;xxx.jar&quot;]CMD [&quot;java&quot;, &quot;-version&quot;] 转移到linux上有docker环境的机器上开始build 修改一下Dockerfile,将配置文件也打入进去,上面驱动也可以改造成通过Dockerfile打包,而不是写到pom中 1234567FROM javaMAINTAINER test@email.comWORKDIR /ROOTADD ./xxx.jar /ROOT/ADD ./conf /ROOT/ENTRYPOINT [&quot;java&quot;, &quot;-jar&quot;, &quot;xxx.jar&quot;]CMD [&quot;java&quot;, &quot;-version&quot;] linux上目录结构如下 执行build指令 1docker build -t job:0814 . 终端打印成功截图 docker images验证截图]]></content>
      <categories>
        <category>java</category>
        <category>Dockerfile</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>镜像</tag>
        <tag>Dockerfile</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[docker镜像迁移]]></title>
    <url>%2Fblog%2F2018%2F08%2F24%2Fdocker%E9%95%9C%E5%83%8F%E8%BF%81%E7%A7%BB%2F</url>
    <content type="text"><![CDATA[前言 一般正规的做法应该是将自己做好的镜像push到远程仓库去,然后需要的时候从远处仓库拉取.由于目前我还没有建立私有远程仓库 所以这篇博客主要是讲手动导出镜像的方法 目的 手动导出镜像以便于在其他地方使用 正文 查看镜像列表 1docker images save导出镜像 指令: docker save repository:tag &gt; 自定义导出名字.tar 推荐 或者 docker save image_id &gt; 自定义导出名字.tar 1docker save webapi:0814 &gt; webapi0814.tar 截图: load导入镜像 1docker load -qi webapi0814.tar 截图: 验证: docker images 查看一下导入情况,这里说明一下,如果之前指令是通过save imageid导出的镜像的话,这里导入的时候仓库和标签名可能为空,推荐save repository:tag导出]]></content>
      <categories>
        <category>docker</category>
        <category>镜像</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>迁移</tag>
        <tag>镜像</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[docker离线安装包准备]]></title>
    <url>%2Fblog%2F2018%2F08%2F23%2Fdocker%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85%E5%8C%85%E5%87%86%E5%A4%87%2F</url>
    <content type="text"><![CDATA[前言 在一台有网络的centos上准备docker-ce.18离线安装包,然后可以根据**docker离线安装**这篇博客离线安装docker 下面的操作都是在有网络的centos7上进行操作的 目的 为离线安装docker提供相关依赖和程序包 正文 建立本地文件夹 1mkdir -p /apps/docker/packages 修改yum源镜像地址 先看一下有没有wget ,没有先装一下，在备份 1yum install wget 备份原来的repo 123cd /etc/yum.repos.d/mkdir backupmv ./CentOS-* ./backup/ 下载阿里的镜像源并应用 123wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repoyum clean allyum makecache 截图: 下载createrepo软件包及其依赖 1repotrack -a x86_64 -p /apps/docker/packages createrepo 如果上诉指令不存在,先安装yum-utils 1yum install -y yum-utils 截图: 再次执行repotrack上面那个指令,开始下载依赖包 截图: 下载libgudev1和systemd-sysv，是因为centos7.2的libgudev1和systemd-sysv依赖systemd-219-19.el7.x86_64， 而docker-ce需要systemd-219-30el7.x86_64.下载 libgudev1和systemd-sysv软件包机器依赖 12repotrack -a x86_64 -p /apps/docker/packages libgudev1repotrack -a x86_64 -p /apps/docker/packages systemd-sysv 下载docker-ce及依赖 由于你的yum远程仓库可能没有docker-ce的相关依赖,建议之前先执行下面的命令添加阿里的docker仓库镜像 1yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo 然后下载docker-ce相关依赖 1repotrack -a x86_64 -p /apps/docker/packages docker-ce 压缩下载 执行下面的命令,将在/apps/docker目录下生成一个docker-ce-18-offline-yum.tgz的包,这个包通过xftp下载后可以在其他地方离线安装docker 只要离线的电脑上有yum命令并且是centos7以上的系统 12cd /apps/dockertar -zcvf docker-ce-18-offline-yum.tgz /apps/docker/packages]]></content>
      <categories>
        <category>docker</category>
        <category>离线</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>离线</tag>
        <tag>安装包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo在多台电脑之间迁移写作]]></title>
    <url>%2Fblog%2F2018%2F08%2F21%2Fhexo%E5%9C%A8%E5%A4%9A%E5%8F%B0%E7%94%B5%E8%84%91%E4%B9%8B%E9%97%B4%E8%BF%81%E7%A7%BB%E5%86%99%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[Welcome to my blog, enter password to read. Incorrect Password! No content to display! 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]]></content>
      <categories>
        <category>博客</category>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>hexo</tag>
        <tag>迁移</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[docker离线安装]]></title>
    <url>%2Fblog%2F2018%2F08%2F21%2Fdocker%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[Welcome to my blog, enter password to read. Incorrect Password! No content to display! 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]]></content>
      <categories>
        <category>docker</category>
        <category>离线</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>离线</tag>
        <tag>安装</tag>
      </tags>
  </entry>
</search>
